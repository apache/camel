= JIRA Component (deprecated)

*Available as of Camel version 3.0*
*Available as of Camel version 2.15*


The JIRA component interacts with the JIRA API by encapsulating
Atlassian's https://bitbucket.org/atlassian/jira-rest-java-client/src/master/[REST
Java Client for JIRA]. It currently provides polling for new issues and
new comments.  It is also able to create new issues, add comments, change issues, add/remove watchers, add attachment
and transition the state of an issue.

Rather than webhooks, this endpoint relies on simple polling. Reasons
include:

* Concern for reliability/stability
* The types of payloads we're polling aren't typically large (plus, paging is available in the API)
* The need to support apps running somewhere not publicly accessible where a webhook would fail

Note that the JIRA API is fairly expansive.  Therefore, this component could be easily expanded to provide additional
interactions.

Maven users will need to add the following dependency to their pom.xml
for this component:

[source,xml]
---------------------------------------
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-jira</artifactId>
    <version>${camel-version}</version>
</dependency>
---------------------------------------

== URI format

[source,text]
-------------------------
jira://type[?options]
-------------------------

== JIRA Options


// component options: START
The JIRA component has no options.
// component options: END

The Jira type accepts the following operations:

For consumers:

* newIssues: retrieve only new issues after the route is started
* newComments: retrieve only new comments after the route is started

For producers:

* addIssue: add an issue
* addComment: add a comment on a given issue
* attach: add an attachment on a given issue
* deleteIssue: delete a given issue
* updateIssue: update fields of a given issue
* transitionIssue: transition a status of a given issue
* watchers: add/remove watchers of a given issue

As Jira is fully customizable, you must assure the fields IDs exists for the project and workflow, as they can change between different Jira servers.

// endpoint options: START
The JIRA endpoint is configured using URI syntax:

----
jira:type
----

with the following path and query parameters:

==== Path Parameters (1 parameters):


[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *type* | *Required* Operation to perform such as create a new issue or a new comment |  | JIRAType
|===


==== Query Parameters (9 parameters):


[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *password* (common) | Password for login |  | String
| *serverUrl* (common) | *Required* URL to the JIRA server |  | String
| *username* (common) | Username for login |  | String
| *bridgeErrorHandler* (consumer) | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | boolean
| *delay* (consumer) | Delay in seconds when querying JIRA using the consumer. | 6000 | int
| *jql* (consumer) | JQL is the query language from JIRA which allows you to retrieve the data you want. For example jql=project=MyProject Where MyProject is the product key in Jira. |  | String
| *exceptionHandler* (consumer) | To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored. |  | ExceptionHandler
| *exchangePattern* (consumer) | Sets the exchange pattern when the consumer creates an exchange. |  | ExchangePattern
| *synchronous* (advanced) | Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported). | false | boolean
|===
// endpoint options: END

// spring-boot-auto-configure options: START
=== Spring Boot Auto-Configuration


The component supports 2 options, which are listed below.



[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *camel.component.jira.enabled* | Enable jira component | true | Boolean
| *camel.component.jira.resolve-property-placeholders* | Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders. | true | Boolean
|===
// spring-boot-auto-configure options: END


== Client Factory

You can bind the `JiraRestClientFactory` with name *JiraRestClientFactory* in the registry to have it automatically set in the Jira endpoint.

== Authentication

Camel-jira supports *https://developer.atlassian.com/cloud/jira/platform/jira-rest-api-basic-authentication/[Basic Authentication]* and *https://developer.atlassian.com/cloud/jira/platform/jira-rest-api-oauth-authentication/[OAuth 3 legged authentication]*.

We recommend to use OAuth whenever possible, as it provides the best security for your users and system.

=== Basic authentication requirements:

* An username and password

=== OAuth authentication requirements:

Follow the tutorial in https://developer.atlassian.com/cloud/jira/platform/jira-rest-api-oauth-authentication/[Jira OAuth documentation]
to generate the client private key, consumer key, verification code and access token.

* a private key, generated locally on your system.
* A verification code, generated by Jira server.
* The consumer key, set in the Jira server settings.
* An access token, generated by Jira server.

== JQL:

The JQL URI option is used by both consumer endpoints.  Theoretically,
items like "project key", etc. could be URI options themselves.
 However, by requiring the use of JQL, the consumers become much more
flexible and powerful.

At the bare minimum, the consumers will require the following:

[source,text]
--------------------------------------------------------------
jira://[type]?[required options]&jql=project=[project key]
--------------------------------------------------------------

One important thing to note is that the newIssues consumer will
automatically set the JQL as:

* append `ORDER BY key desc` to your JQL
* prepend `id > latestIssueId` to retrieve issues added after the camel route was started.

This is in order to optimize startup processing, rather than having to index every single
issue in the project.

Another note is that, similarly, the newComments consumer will have to
index every single issue *and* comment in the project. Therefore, for
large projects, it's *vital* to optimize the JQL expression as much as
possible. For example, the JIRA Toolkit Plugin includes a "Number of
comments" custom field -- use '"Number of comments" > 0' in your query.
Also try to minimize based on state (status=Open), increase the polling
delay, etc. Example:

[source,text]
----------------------------------------------------------------------------------------------------------------------------------------------
jira://[type]?[required options]&jql=RAW(project=[project key] AND status in (Open, \"Coding In Progress\") AND \"Number of comments\">0)"
----------------------------------------------------------------------------------------------------------------------------------------------

== Operations

See a list of required headers to set when using the Jira operations. The author field for the producers is automatically set to the authenticated user in the Jira side.

If any required field is not set, then an IllegalArgumentException is throw.

There are operations that requires `id` for fields suchs as: issue type, priority, transition. Check the valid `id` on your jira project as they may differ on a jira installation and project workflow.

== AddIssue

Required:

* `ProjectKey`: The project key, example: CAMEL, HHH, MYP.
* `IssueTypeId` or `IssueTypeName`: The `id` of the issue type or the name of the issue type, you can see the valid list in `\http://jira_server/rest/api/2/issue/createmeta?projectKeys=SAMPLE_KEY`.
* `IssueSummary`: The summary of the issue.

Optional:

* `IssueAssignee`: the assignee user
* `IssuePriorityId` or `IssuePriorityName`: The priority of the issue, you can see the valid list in `\http://jira_server/rest/api/2/priority`.
* `IssueComponents`: A list of string with the valid component names.
* `IssueWatchersAdd`: A list of strings with the usernames to add to the watcher list.
* `IssueDescription`: The description of the issue.

== AddComment

Required:

* `IssueKey`: The issue key identifier.
* body of the exchange is the description.

== AttachFile

Only one file should attach per invocation.

Required:

* `IssueKey`: The issue key identifier.
* body of the exchange should be of type `GenericFile`

== DeleteIssue

Required:

* `IssueKey`: The issue key identifier.

== TransitionIssue

Required:

* `IssueKey`: The issue key identifier.
* `IssueTransitionId`: The issue transition `id`.
* body of the exchange is the description.

== UpdateIssue

* `IssueKey`: The issue key identifier.
* `IssueTypeId` or `IssueTypeName`: The `id` of the issue type or the name of the issue type, you can see the valid list in `\http://jira_server/rest/api/2/issue/createmeta?projectKeys=SAMPLE_KEY`.
* `IssueSummary`: The summary of the issue.
* `IssueAssignee`: the assignee user
* `IssuePriorityId` or `IssuePriorityName`: The priority of the issue, you can see the valid list in `\http://jira_server/rest/api/2/priority`.
* `IssueComponents`: A list of string with the valid component names.
* `IssueDescription`: The description of the issue.

== Watcher

* `IssueKey`: The issue key identifier.
* `IssueWatchersAdd`: A list of strings with the usernames to add to the watcher list.
* `IssueWatchersRemove`: A list of strings with the usernames to remove from the watcher list.
