[[properties-component]]
= Properties Component
//THIS FILE IS COPIED: EDIT THE SOURCE FILE:
:page-source: core/camel-base/src/main/docs/properties-component.adoc
//Written by hand, not generated.
:docTitle: Properties
:artifactId: camel-base
:description: The properties component is used for property placeholders in your Camel application, such as endpoint URIs.
:since: 2.3
:supportLevel: Stable

*Since Camel {since}*

The properties component is used for property placeholders in your Camel application, such as endpoint URIs.
It is *not* a regular Camel component with producer and consumer for routing messages.
However, for historical reasons it was named `PropertiesComponent` and this name is commonly known so we keep using it.

IMPORTANT: See the xref:latest@manual:ROOT:using-propertyplaceholder[Property Placeholder] documentation for general information on using property placeholders in Camel.

The properties component requires to load the properties (key=value pairs) from an external source such as `.properties` files.
The component is pluggable and you can configure to use other sources or write a custom implementation (for example to load from a database).


== Defining location of properties files

The properties component needs to know a location(s) where to resolve the properties.
You can define one to many locations.
Multiple locations can be separated by comma such as:

[source,java]
----
pc.setLocation("com/mycompany/myprop.properties,com/mycompany/other.properties");
----

You can mark a location to be optional, which means that Camel will ignore the location if not present:

[source,java]
----
pc.setLocations(
    "com/mycompany/override.properties;optional=true"
    "com/mycompany/defaults.properties");
----

=== Using system and environment variables in locations

The location now supports using placeholders for JVM system properties and OS environments variables.

For example:

[source]
----
location=file:${karaf.home}/etc/foo.properties
----

In the location above we defined a location using the file scheme using the JVM system property with key `karaf.home`.

To use an OS environment variable instead you would have to prefix with
`env:`.
You can also prefix with `env.`, however this style is not recommended because all the other functions use colon.

[source]
----
location=file:${env:APP_HOME}/etc/foo.properties
----

Where `APP_HOME` is an OS environment.

[NOTE]
====
Some OS'es (such as Linux) do not support dashes in environment variable names, so here we are using `APP_HOME`.
But if you specify `APP-HOME` then Camel 3 will automatic lookup the value as `APP_HOME` (with underscore) as fallback.
====

You can have multiple placeholders in the same location, such as:

[source]
----
location=file:${env:APP_HOME}/etc/${prop.name}.properties
----

=== Defining location of properties files in Spring XML

Spring XML offers two variations to configure.
You can define a spring bean as a `PropertiesComponent` which resembles the way done in Java.
Or you can use the `<propertyPlaceholder>` tag.

[source,xml]
----
<bean id="properties" class="org.apache.camel.component.properties.PropertiesComponent">
    <property name="location" value="classpath:com/mycompany/myprop.properties"/>
</bean>
----

Using the `<propertyPlaceholder>` allows to configure this within the `<camelContext>` tag.

[source,xml]
----
<camelContext>
   <propertyPlaceholder id="properties" location="com/mycompany/myprop.properties"/>
</camelContext>
----

For fine grained configuration of the location, then this can be done as follows:

[source,xml]
----
<camelContext>
  <propertyPlaceholder id="myPropertyPlaceholder">
    <propertiesLocation
      resolver = "classpath"
      path     = "com/my/company/something/my-properties-1.properties"
      optional = "false"/>
    <propertiesLocation
      resolver = "classpath"
      path     = "com/my/company/something/my-properties-2.properties"
      optional = "false"/>
    <propertiesLocation
      resolver = "file"
      path     = "${karaf.home}/etc/my-override.properties"
      optional = "true"/>
   </propertyPlaceholder>
</camelContext>
----

== Additional property placeholder supported in Spring XML

The property placeholders is also supported in many of the Camel Spring XML tags such as `<package>, <packageScan>, <contextScan>, <jmxAgent>, <endpoint>, <routeBuilder>, and the others.

The example below has property placeholder in the `<jmxAgent>` tag:

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <propertyPlaceholder id="properties" location="org/apache/camel/spring/jmx.properties"/>
    <!-- we can use property placeholders when we define the JMX agent -->
    <jmxAgent id="agent" disabled="{{myjmx.disabled}}"
              usePlatformMBeanServer="{{myjmx.usePlatform}}"
              statisticsLevel="RoutesOnly" useHostIPAddress="true"/>
    <route id="foo" autoStartup="false">
        <from uri="seda:start"/>
        <to uri="mock:result"/>
    </route>
</camelContext>
----

You can also define property placeholders in the various attributes on the `<camelContext>` tag such as `trace` as shown here:

[source,xml]
----
<camelContext trace="{{foo.trace}}" xmlns="http://camel.apache.org/schema/spring">
    <propertyPlaceholder id="properties" location="org/apache/camel/spring/processor/myprop.properties"/>
    <template id="camelTemplate" defaultEndpoint="{{foo.cool}}"/>
    <route>
        <from uri="direct:start"/>
        <setHeader name="{{foo.header}}">
            <simple>${in.body} World!</simple>
        </setHeader>
        <to uri="mock:result"/>
    </route>
</camelContext>
----

== Using JVM system properties or Environment variables as override or fallback values

The properties components supports using JVM system properties and also OS environment variables as values which can either be used as override or fallback values.

The default mode is that both of them are in override mode, and they are check in the following order:

1. OS environment variable (override mode)
2. JVM system property (override mode)
3. Property files and other locations
4. OS environment variable (fallback mode)
5. JVM system property (fallback mode)

The check stops at first found property value for the key.

You can control these modes using the `systemPropertiesMode` and `environmentVariableMode`
options on the properties component.


== Using out of the box functions

The xref:properties-component.adoc[Properties] component includes the following functions out of the box:

* `env` - A function to lookup the property from OS environment variables
* `sys` - A function to lookup the property from Java JVM system properties
* `service` - A function to lookup the property from OS environment variables using the service naming idiom
* `service.name` - A function to lookup the property from OS environment variables using the service naming idiom returning the hostname part only
* `service.port` - A function to lookup the property from OS environment variables using the service naming idiom returning the port part only

As you can see these functions is intended to make it easy to lookup values from the environment.
As they are provided out of the box, they can easily be used as shown below:

[source,xml]
----
  <camelContext xmlns="http://camel.apache.org/schema/blueprint">
    <route>
      <from uri="direct:start"/>
      <to uri="{{env:SOMENAME}}"/>
      <to uri="{{sys:MyJvmPropertyName}}"/>
    </route>
  </camelContext>
----

You can use default values as well, so if the property does not exist, you can define a default value as shown below, where the default value is a `log:foo` and `log:bar` value.

[source,xml]
----
  <camelContext xmlns="http://camel.apache.org/schema/blueprint">
    <route>
      <from uri="direct:start"/>
      <to uri="{{env:SOMENAME:log:foo}}"/>
      <to uri="{{sys:MyJvmPropertyName:log:bar}}"/>
    </route>
  </camelContext>
----

The service function is for looking up a service which is defined using OS environment variables using the service naming idiom, to refer to a service location using `hostname : port`

* __NAME__**_SERVICE_HOST**
* __NAME__**_SERVICE_PORT**

in other words the service uses `_SERVICE_HOST` and `_SERVICE_PORT` as prefix.
So if the service is named FOO, then the OS environment variables should be set as

[source]
----
export $FOO_SERVICE_HOST=myserver
export $FOO_SERVICE_PORT=8888
----

For example if the FOO service a remote HTTP service, then we can refer to the service in the Camel endpoint uri, and use the HTTP component to make the HTTP call:

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/blueprint">
  <route>
    <from uri="direct:start"/>
    <to uri="http://{`{service:FOO}`}/myapp"/>
  </route>
</camelContext>
----

And we can use default values if the service has not been defined, for example to call a service on localhost, maybe for unit testing etc

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/blueprint">
  <route>
    <from uri="direct:start"/>
    <to uri="http://{`{service:FOO:localhost:8080}`}/myapp"/>
  </route>
</camelContext>
----

== Using custom functions (advanced)

The xref:properties-component.adoc[Properties] component allow to plugin 3rd party functions which can be used during parsing of the property placeholders.
These functions are then able to do custom logic to resolve the placeholders, such as looking up in databases, do custom computations, or whatnot.
The name of the function becomes the prefix used in the placeholder.
This is best illustrated in the example code below

[source,xml]
----
<beans>
    <bean id="beerFunction" class="MyBeerFunction"/>

    <camelContext>
      <propertyPlaceholder id="properties">
        <propertiesFunction ref="beerFunction"/>
      </propertyPlaceholder>

      <route>
        <from uri="direct:start"/>
        <to uri="{{beer:FOO}}"/>
        <to uri="{{beer:BAR}}"/>
      </route>
    </camelContext>
</beans>
----

Here we have a Camel XML route where we have defined the
`<propertyPlaceholder>` to use a custom function, which we refer to be the bean id - eg the `beerFunction`.
As the beer function uses `"beer"` as its name, then the placeholder syntax can trigger the beer function by starting with `beer:value`.

The implementation of the function is only two methods as shown below:

[source,java]
----
public static final class MyBeerFunction implements PropertiesFunction {

    @Override
    public String getName() {
        return "beer";
    }

    @Override
    public String apply(String remainder) {
        return "mock:" + remainder.toLowerCase();
    }
}
----

The function must implement the `org.apache.camel.spi.PropertiesFunction` interface.
The method `getName` is the name of the function, eg beer.
And the `apply` method is where we implement the custom logic to do.
As the sample code is from an unit test, it just returns a value to refer to a mock endpoint.

To register a custom function from Java code is as shown below:

[source,java]
----
PropertiesComponent pc = context.getPropertiesComponent();
pc.addFunction(new MyBeerFunction());
----

== PropertySource

The regular `PropertySource` will lookup the property on-demand, for example to lookup values from a backend source such as a database or HashiCorp Vault etc.

=== LoadablePropertySource

A `PropertySource` can define that it supports loading all its properties from the source at once, for example from file system.
This allows Camel properties component to load these properties at once during startup.

=== Using 3rd-party PropertySource

The properties component allows to plugin 3rd party sources to load and lookup properties via the `PropertySource`
API from camel-api.

For example the `camel-microprofile-config` component is implemented using this.
The 3rd-party `PropertySource` can automatic be discovered from classpath when Camel is starting up.
This is done by include the file `META-INF/services/org/apache/camel/property-source-factory` file which refers to the fully qualified class name of the `PropertySource` implementation.

See xref:components:others:microprofile-config.adoc[MicroProfile Config] component as an example.

You can also register 3rd-party property sources via Java API:

[source,java]
----
PropertiesComponent pc = context.getPropertiesComponent();
pc.addPropertySource(myPropertySource);
----


== Spring Boot Auto-Configuration

The component supports 10 options, which are listed below.

[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *camel.component.properties.auto-discover-properties-sources* | Whether to automatically discovery instances of PropertiesSource from registry and service factory. | true | Boolean
| *camel.component.properties.default-fallback-enabled* | If false, the component does not attempt to find a default for the key by looking after the colon separator. | true | Boolean
| *camel.component.properties.encoding* | Encoding to use when loading properties file from the file system or classpath.
If no encoding has been set, then the properties files is loaded using ISO-8859-1 encoding (latin-1) as documented by java.util.Properties#load(java.io.InputStream) |  | String
| *camel.component.properties.environment-variable-mode* | Sets the OS environment variables mode (0 = never, 1 = fallback, 2 = override).
The default mode (override) is to use OS environment variables if present, and override any existing properties.
OS environment variable mode is checked before JVM system property mode | 2 | Integer
| *camel.component.properties.ignore-missing-location* | Whether to silently ignore if a location cannot be located, such as a properties file not found. | false | Boolean
| *camel.component.properties.initial-properties* | Sets initial properties which will be used before any locations are resolved.
The option is a java.util.Properties type. |  | String
| *camel.component.properties.location* | A list of locations to load properties.
You can use comma to separate multiple locations.
This option will override any default locations and only use the locations from this option. |  | String
| *camel.component.properties.override-properties* | Sets a special list of override properties that take precedence and will use first, if a property exist.
The option is a java.util.Properties type. |  | String
| *camel.component.properties.properties-parser* | To use a custom PropertiesParser.
The option is a org.apache.camel.component.properties.PropertiesParser type. |  | String
| *camel.component.properties.system-properties-mode* | Sets the JVM system property mode (0 = never, 1 = fallback, 2 = override).
The default mode (override) is to use system properties if present, and override any existing properties.
OS environment variable mode is checked before JVM system property mode | 2 | Integer
|===
