= Variables

*Available from Camel 4.4*

In Camel 4.4, we have introduced the concept of _variables_.

A variable is a key/value that can hold a value that can either be private per `Exchange` or global shared
in the `CamelContext`.

NOTE: You can also use _exchange properties_ as variables but the exchange properties are also used internally by Camel,
and some EIPs and components. With the newly introduced _variables_ then these are exclusively for end users.

== Variable Repository

The variables are stored in one or more `org.apache.camel.spi.VariableRepository`. By default, there are the following repositories

- `ExchangeVariableRepository` - A private repository per `Exchange` that holds variables that are private for the lifecycle of each `Exchange`.
- `GlobalVariableRepository` - Uses `global` as id. A shared global repository for the entire `CamelContext`.

The `ExchangeVariableRepository` is special as its private per exchange and is the default repository when used during routing.

TIP: There is also `org.apache.camel.spi.BrowsableVariableRepository` which is an extension to `VariableRepository` that
has APIs to browse the currently variables. This is used by Camel with Camel JBang, and JMX to be able to see the current variables
from management tooling, CLI and the developer console.

=== Custom variable repositories

You can implement custom `org.apache.camel.spi.VariableRepository` and plugin to be used out of the box with Apache Camel.
For example, you can build a custom repository that stores the variables in a database, so they are persisted.

Each repository must have its own unique id. However, it's also possible to replace the default `global` repository with another.

== Getting and setting variables from Java API

To get a local variable from the current exchange, you can do this via Java API:

[source,java]
----
String myValue = "...";
exchange.setVariable("myKey", myValue);

// and later to get the variable
Object val = exchange.getVariable("myKey");

// you can get the value as a specific type
String str = exchange.getVariable("myKey", String.class);
----

The API on `Exchange` will by default get the variables from its local private repository.
However, you can also get variables from other repositories, such as the `global` as show:

[source,java]
----
Object val = exchange.getVariable("global:myGlobalKey");
----

And you can also assign a global variable by prefixing with `global:` as follows:

[source,java]
----
exchange.setVariable("global:myGlobalKey", someObjectHere);
----

There is also API on `CamelContext` to get variables. However, this API will by default get from the `global` repository,
as it's not possible to get variables from any inflight `Exchange` currently being routed.

[source,java]
----
Object val = context.getVariable("myGlobalKey");

// you can get the value as a specific type
String str = context.getVariable("myGlobalKey", String.class);
----

== Setting and getting variables from DSL

It is also possible to use variables in Camel xref:routes.adoc[routes] using the
setVariable, removeVariable, and convertVariableTo EIPs.

These EIPs makes it possible to set and remove variables from routes. And you can also access variables from the xref:components:languages:simple-language.adoc[Simple] language.

In the following route we set a variable on the exchange which we use later to build a human-readable event message:

[tabs]
====
Java::
+
[source,java]
----
from("kafka:order.in")
  .setVariable("customerId", jq(".customer.custId"))
  .setVariable("country", jq(".customer.address.co"))
  .transform().simple("Order received from customer ${variable.customerId} in ${variable.country}")
  .to("kafka:order.event");
----

XML::
+
[source,xml]
----
<route>
    <from uri="kafka:order.in"/>
    <setVariable name="customerId">
        <jq>.customer.custId</jq>
    </setVariable>
    <setVariable name="country">
        <jq>.customer.address.co</jq>
    </setVariable>
    <transform>
        <simple>Order received from customer ${variable.customerId} in ${variable.country}</simple>
    </transform>
    <to uri="kafka:order.event"/>
</route>
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: kafka:order.in
      steps:
        - setVariable:
            name: customerId
            jq:
              expression: .customer.custId
        - setVariable:
            name: country
            jq:
              expression: .customer.address.co
        - transform:
            simple:
              expression: "Order received from customer ${variable.customerId} in ${variable.country}"
        - to:
            uri: kafka:order.event
----
====

== Configuring initial variables on startup

When Camel is starting then it's possible to configure initial variables.

This can be done in `application.properties` as shown below:

[source,properties]
----
camel.variable.greeting = Random number
camel.variable.random = 999
----

The variables are default set on the `global` repository, but you can specify a custom repository by
prefixing with `id:` in the key, such as below:

[source,properties]
----
camel.variable.acme:gold = true
camel.variable.greeting = Random number
camel.variable.random = 999
----

Here the gold variable is set on the `acme` repository, and the other variables are set on the `global` repository.

The value of a variable can also be loaded from file system, such as a JSon file. To do this you should
prefix the value with `resource:file:` or `resource:classpath:` to load from file system or classpath,
as shown below:

[source,properties]
----
camel.variable.user-template = resource:file:/etc/user.json
----

== Using Variables with EIPs

The following commonly used EIPs for sending and receiving, and transforming messages, have
first class support for using variables with the message body:

- from
- to
- toD
- enrich
- pollEnrich
- wireTap
- unmarshal
- marshal

The intention is to make it more convenient and easy to _gather data_ from other systems without any ceremony to keep
existing data by using techniques such as storing the data temporary using headers or exchange properties,
or with the xref:components:eips:claimCheck-eip.adoc[Claim Check] EIP.

=== Important concept when using variables and EIPs

It is **important** to understand that the variables only use the message **body** and does not have support for anything else such
as message headers. This is on purpose to keep it simpler and only work with the message body as the user data. If you have need
to use variables with both message body and headers, then you can use `setVariable` and `getVariable`.

The EIPs listed above have support for using variables when sending and receiving data. This is done by using the `variableSend` and `variableReceive` options
to specify the name of the variable. When the EIP uses variables then the _data_ itself (i.e. message body) is only what is
different from 'standard' Camel.

For example given the following `Message` containing:

[source,properties]
----
header.foo=123
header.bar=456
body=Hello World
----

And a remote service is called via the route below, and this service returns a new header and body:

[tabs]
====
Java::
+
[source,java]
----
from("direct:service")
  .to("http:myservice")
  .to("log:after");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:service"/>
  <to uri="http:myservice"/>
  <to uri="log:after"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:service"
  steps:
    - to: "http:myservice"
    - to: "log:after"
----
====

Then calling this route, then the `Message` is updated:

[source,properties]
----
header.foo=123
header.bar=456
header.level=gold
body=Bye World
----

However, if you use a variable (_myVar_) as the _sink_ to store the returned data from calling the remote service as shown:

[tabs]
====
Java::
+
[source,java]
----
from("direct:service")
  .toV("http:myservice", null, "myVar")
  .to("log:after");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:service"/>
  <to uri="http:myservice" variableReceive="myVar"/>
  <to uri="log:after"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:service"
  steps:
    - to:
        uri: http:myservice
        variableReceive: myVar
    - to: "log:after"
----
====

Then the `Message` body is not changed, but everything else is changed as without using variables:

[source,properties]
----
header.foo=123
header.bar=456
header.level=gold
body=Hello World
----

And the variable contains the data:

[source,properties]
----
myVar=Bye World
----

=== Using variable to store a copy of the incoming message body

You can configure the `from` to store a copy of the message body into a variable. This makes it easy to have quick access
to the original incoming message body via the variable.

The following example from a unit test shows how to do this. Notice how Java DSL uses `fromV` to make it possible to specify
the name of the variable. In XML and YAML DSL you specify this using the `variableReceive` parameter.

[tabs]
====
Java::
+
[source,java]
----
fromV("direct:start", "myKey")
    .transform().simple("Bye ${body}")
    .to("mock:foo")
    .setBody(variable("myKey"))
    .to("mock:result");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:start" variableReceive="myKey"/>
  <transform>
    <simple>Bye ${body}</simple>
  </transform>
  <to uri="mock:foo"/>
  <setBody>
    <variable>myKey</variable>
  </setBody>
  <to uri="mock:result"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:start"
  variableReceive: "myKey"
  steps:
    - transform:
        simple: "Bye ${body}"
    - to: "mock:foo"
    - setBody:
        variable: "myKey"
    - to: "mock:result"
----
====

=== Using variables when sending and receiving messages to an endpoint

You can configure the `to` to use variables for any of the following (or both) when sending and receiving:

- variableSend - name of variable that contains the message body to send instead of the current message body on the `Exchange`.
- variableReceive - name of variable that should store the returned message payload (will not change the message body on the `Exchange`).

For example, you can use the `variableSend` to tell Camel to use the variable as the message body when sending to an endpoint.
If the `variableReceive` is also configured, then the reply message will be stored in the variable instead of the `Exchange` message body.

IMPORTANT: This is only the message body. Message headers keep acting as usual.

In the following example, we use a variable named `hello` as the message body when sending to the `direct:foo` endpoint:

[tabs]
====
Java::
+
[source,java]
----
from("direct:send")
    .setVariable("hello", simple("Camel"))
    .to("mock:before")
    .toV("direct:foo", "hello", null)
    .to("mock:result");

from("direct:foo")
    .transform().simple("Bye ${body}");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:send"/>
  <setVariable name="hello">
    <simple>Camel</simple>
  </setVariable>
  <to uri="mock:before"/>
  <to uri="direct:foo" variableSend="hello"/>
  <to uri="mock:result"/>
</route>
<route>
  <from uri="direct:foo"/>
  <transform>
    <simple>Bye ${body}</simple>
  </transform>
</route>
----
YAML::
+
[source,yaml]
----
- route:
    from:
      uri: direct:send
      steps:
        - setVariable:
            name: hello
            simple:
              expression: Camel
        - to:
            uri: mock:before
        - to:
            uri: direct:foo
            variableSend: hello
        - to:
            uri: mock:result
- route:
    from:
      uri: direct:foo
      steps:
        - transform:
            simple:
              expression: "Bye ${body}"
----
====

If you only want to store the result in a variable instead of the current `Exchange` message body, then you should use `variableReceive`
as shown in the following:

[tabs]
====
Java::
+
[source,java]
----
from("direct:receive")
    .toV("direct:foo", null, "bye")
    .to("mock:after")
    .setBody(simple("${variable:bye}"))
    .to("mock:result");

from("direct:foo")
    .transform().simple("Bye ${body}");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:receive"/>
  <to uri="direct:foo" variableReceive="bye"/>
  <to uri="mock:after"/>
  <setBody>
    <simple>${variable:bye}</simple>
  </setBody>
  <to uri="mock:result"/>
</route>
<route>
  <from uri="direct:foo"/>
  <transform>
    <simple>Bye ${body}</simple>
  </transform>
</route>
----
YAML::
+
[source,yaml]
----
- route:
    from:
      uri: direct:receive
      steps:
        - to:
            uri: direct:foo
            variableReceive: bye
        - to:
            uri: mock:after
        - setBody:
            variable: bye
        - to:
            uri: mock:result
- route:
    from:
      uri: direct:foo
      steps:
        - transform:
            simple:
              expression: "Bye ${body}"
----
====

And you can also use both of them together which means you are using variables for both what to send, and to store the result in a variable.
This means the current `Exchange` message body is not in use at all.

[tabs]
====
Java::
+
[source,java]
----
from("direct:sendAndReceive")
    .setVariable("hello", simple("Camel"))
    .to("mock:before")
    .toV("direct:foo", "hello", "bye")
    .to("mock:result");

from("direct:foo")
    .transform().simple("Bye ${body}");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:sendAndReceive"/>
  <setVariable name="hello">
    <simple>Camel</simple>
  </setVariable>
  <to uri="mock:before"/>
  <to uri="direct:foo" variableSend="hello" variableReceive="bye"/>
  <to uri="mock:result"/>
</route>
<route>
  <from uri="direct:foo"/>
  <transform>
    <simple>Bye ${body}</simple>
  </transform>
</route>
----
YAML::
+
[source,yaml]
----
- route:
    from:
      uri: direct:sendAndReceive
      steps:
        - setVariable:
            name: hello
            simple:
              expression: Camel
        - to:
            uri: mock:before
        - to:
            uri: direct:foo
            variableReceive: bye
            variableSend: hello
        - to:
            uri: mock:result
- route:
    from:
      uri: direct:foo
      steps:
        - transform:
            simple:
              expression: "Bye ${body}"
----
====
