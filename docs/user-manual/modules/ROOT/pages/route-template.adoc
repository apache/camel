[[RouteTemplate]]
= Route Template

A Route template is as its name implies a template for a route, which are used
to create routes from a set of input parameters. Another way of think is that
route templates are parameterized routes.

_Route template_ + _input parameters_ => _route_

From a route template you can create one or more routes.

== Defining route templates in the DSL

Route templates are to be defined in the DSL (just like routes) as shown in the following:

[source,java]
----
public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        // create a route template with the given name
        routeTemplate("myTemplate")
            // here we define the required input parameters (can have default values)
            .templateParameter("name")
            .templateParameter("greeting")
            .templateParameter("myPeriod", "3s")
            // here comes the route in the template
            // notice how we use {{name}} to refer to the template parameters
            // we can also use {{propertyName}} to refer to property placeholders
            .from("timer:{{name}}?period={{myPeriod}}")
                .setBody(simple("{{greeting}} ${body}"))
                .log("${body}");
    }
}
----

And in XML DSL

[source,xml]
----
<camelContext>
  <routeTemplate id="myTemplate">
    <templateParameter name="name"/>
    <templateParameter name="greeting"/>
    <templateParameter name="myPeriod" defaultValue="3s"/>
    <route>
      <from uri="timer:{{name}}?period={{myPeriod}}"/>
      <setBody><simple>{{greeting}} ${body}</simple></setBody>
      <log message="${body}"/>
    </route>
  </routeTemplate>
</camelContext>
----

In the examples above there was one route template, but you can define as many as you want.
Each template must have an unique id. The template parameters are used for defining the parameters
the template accepts. As you can see there are 3 parameters: name, greeting, and myPeriod. The first two
parameters are mandatory, where as myPeriod is optional as it has a default value of 3s.

The template parameters are then used in the route as regular property placeholders with the `{{ }}` syntax.
Notice how we use `{\{name}}` and `{\{greeting}}` in the timer endpoint and the simple language.

The route can of course also use regular property placeholders as well.
Now imagine there was a property placeholder with the name greeting:

[source,properties]
----
greeting = Davs
----

Then Camel would normally have used this value `Davs` when creating the route. However as the route template
has defined a template parameter with the same name `greeting` then a value must be provided when
creating routes from the template.

Template parameters take precedence over regular property placeholders.

== Creating a route from a route template

To create routes from route templates, then you should use `org.apache.camel.builder.TemplatedRouteBuilder`.

In the following you can see how this is done with the builder as shown below:

[source,java]
----
// create two routes from the template
TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "one")
    .parameter("greeting", "Hello")
    .add();

TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "two")
    .parameter("greeting", "Bonjour")
    .parameter("myPeriod", "5s")
    .add();
----

The returned value from `add` is the route id of the new route that was added.
However `null` is returned if the route is not yet created and added, which can happen if `CamelContext` is
not started yet.

If no route id is provided, then Camel will auto assign a route id. In the example above then Camel would
assign route ids such as `route1`, `route2` to these routes.

If you want to specify a route id, then use `routeId` as follows, where the name is myCoolRoute:

[source,java]
----
TemplatedRouteBuilder.builder(context, "myTemplate")
    .routeId("myCoolRoute")
    .parameter("name", "one
    .parameter("greeting", "hello")
    .parameter("myPeriod", "5s")
    .add();
----


== Binding beans to route template

The route template allows to bind beans which is local scoped and only used as part of creating routes from the template.
This allows to use the same template to create multiple routes, where beans are local (private) for each created route.

For example given the following route template, then we can configure the bindings (and other things) as shown:

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .configure((RouteTemplateContext rtc) ->
        // name of local bean is myClient
        rtc.bind("myClient", S3Client.class,
                S3Client.builder()
                    .region(rtc.getProperty("region", Region.class))
                    .build();
        )
    )
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

The template has two parameters to specify the AWS region and the S3 bucket. To connect to S3
then a `software.amazon.awssdk.services.s3.S3Client` bean is needed.

To create this bean we can use bind a bean with the id `myClient` that is bound as `java.util.Supplier`.
The bind operation needs to know the class type that the supplier would return, and therefore you must
specify `S3Client.class` as parameter.

This ensures that the code creating the bean is executed later when Camel is creating a route from the template.
This makes the bean with id `myClient` a local bean that is only in the scope (namespace) in the route template.
*Important:* the local bean with id `myClient` *must* be referred to using Camel's property placeholder syntax, eg `{{myClient}}`
in the route template, as shown above with the _to_ endpoint. This is because the local
bean must be made unique and Camel will internally re-assign the bean id to use an unique id instead of `myClient`. And this is done with the help
of the property placeholder functionality.

If multiple routes is created from this template, then each of the created routes, have their own
S3Client bean created.

=== Binding beans to route templates from template builder

The `TemplatedRouteBuilder` also allows to bind local beans (which allows to specify those beans) when
creating routes from existing templates.

Suppose the route template below is defined in XML:
[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

The template has no bean bindings for `#{{myClient}}` which would be required for creating the template.

When creating routes form the template via `TemplatedRouteBuilder` then you can provide the bean binding
if you desire the bean to be local scoped (not shared with others):

[source,java]
----
TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", "US-EAST-1")
    .parameter("bucket", "myBucket")
    .bind("myClient", S3Client.class,
                S3Client.builder()
                    .region(rtc.getProperty("region", Region.class))
                    .build())
    .routeId("mys3route")
    .add();
----

As you can see the binding is similar to when binding directly in the route template.

Instead of binding the beans from the template builder, you could also create the bean outside the template,
and bind it by reference.

[source,java]
----

final S3Client myClient = S3Client.builder().region(Region.US_EAST_1).build();

TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", Region.US_EAST_1)
    .parameter("bucket", "myBucket")
    .bind("myClient", myClient)
    .routeId("mys3route")
    .add();
----

== JMX management

The route templates can be dumped as XML from the `ManagedCamelContextMBean` MBean via the `dumpRouteTemplatesAsXml` operation.

== Creating routes from properties file

When using `camel-main` you can specify the parameters for route templates in `application.properties` file.

For example given the route template below (from a `RouteBuilder` class):

[source,java]
----
routeTemplate("mytemplate")
    .templateParameter("input")
    .templateParameter("result")
    .from("direct:{{input}}")
        .to("mock:{{result}}");
----

Then we can create two routes from this template by configuring the values in the `application.properties` file:

[source,properties]
----
camel.route-template[0].template-id=mytemplate
camel.route-template[0].input=foo
camel.route-template[0].result=cheese

camel.route-template[1].template-id=mytemplate
camel.route-template[1].input=bar
camel.route-template[1].result=cheese
----

== Creating routes from custom sources of template parameters

The SPI interface `org.apache.camel.spi.RouteTemplateParameterSource` can be used to implement custom sources that
are used during startup of Camel to create routes via the templates with parameters from the custom source(s).

For example a custom source can be implemented that reads parameters from a shared database that Camel uses during staring
by creating routes. This allows to externalize these parameters and as well to easily add more routes with varying parameters.

To let Camel discover custom sources then register the source into the Camel registry.

== See Also

See the example https://github.com/apache/camel-examples/tree/master/examples/routetemplate[camel-example-routetemplate].
