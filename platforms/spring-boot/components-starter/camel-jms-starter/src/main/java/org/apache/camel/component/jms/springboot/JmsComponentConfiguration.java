/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.springboot;

import javax.annotation.Generated;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import org.apache.camel.LoggingLevel;
import org.apache.camel.component.jms.ConsumerType;
import org.apache.camel.component.jms.DefaultTaskExecutorType;
import org.apache.camel.component.jms.JmsComponent;
import org.apache.camel.component.jms.JmsKeyFormatStrategy;
import org.apache.camel.component.jms.JmsMessageType;
import org.apache.camel.component.jms.JmsProviderMetadata;
import org.apache.camel.component.jms.MessageCreatedStrategy;
import org.apache.camel.component.jms.MessageListenerContainerFactory;
import org.apache.camel.component.jms.QueueBrowseStrategy;
import org.apache.camel.component.jms.ReplyToType;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.spring.boot.ComponentConfigurationPropertiesCommon;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.DeprecatedConfigurationProperty;
import org.springframework.boot.context.properties.NestedConfigurationProperty;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.util.ErrorHandler;

/**
 * The jms component allows messages to be sent to (or consumed from) a JMS
 * Queue or Topic.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.SpringBootAutoConfigurationMojo")
@ConfigurationProperties(prefix = "camel.component.jms")
public class JmsComponentConfiguration
        extends
            ComponentConfigurationPropertiesCommon {

    /**
     * To use a shared JMS configuration
     */
    private JmsConfigurationNestedConfiguration configuration;
    /**
     * Specifies whether the consumer accept messages while it is stopping. You
     * may consider enabling this option if you start and stop JMS routes at
     * runtime while there are still messages enqueued on the queue. If this
     * option is false and you stop the JMS route then messages may be rejected
     * and the JMS broker would have to attempt redeliveries which yet again may
     * be rejected and eventually the message may be moved at a dead letter
     * queue on the JMS broker. To avoid this its recommended to enable this
     * option.
     */
    private Boolean acceptMessagesWhileStopping = false;
    /**
     * Whether the DefaultMessageListenerContainer used in the reply managers
     * for request-reply messaging allow the
     * DefaultMessageListenerContainer.runningAllowed flag to quick stop in case
     * JmsConfigurationisAcceptMessagesWhileStopping is enabled and
     * org.apache.camel.CamelContext is currently being stopped. This quick stop
     * ability is enabled by default in the regular JMS consumers but to enable
     * for reply managers you must enable this flag.
     */
    private Boolean allowReplyManagerQuickStop = false;
    /**
     * The JMS acknowledgement mode defined as an Integer. Allows you to set
     * vendor-specific extensions to the acknowledgment mode. For the regular
     * modes it is preferable to use the acknowledgementModeName instead.
     */
    private Integer acknowledgementMode;
    /**
     * Enables eager loading of JMS properties as soon as a message is loaded
     * which generally is inefficient as the JMS properties may not be required
     * but sometimes can catch early any issues with the underlying JMS provider
     * and the use of JMS properties
     */
    private Boolean eagerLoadingOfProperties = false;
    /**
     * The JMS acknowledgement name which is one of: SESSION_TRANSACTED
     * CLIENT_ACKNOWLEDGE AUTO_ACKNOWLEDGE DUPS_OK_ACKNOWLEDGE
     */
    private String acknowledgementModeName = "AUTO_ACKNOWLEDGE";
    /**
     * Specifies whether the consumer container should auto-startup.
     */
    private Boolean autoStartup = true;
    /**
     * Sets the cache level by ID for the underlying JMS resources. See
     * cacheLevelName option for more details.
     */
    private Integer cacheLevel;
    /**
     * Sets the cache level by name for the underlying JMS resources. Possible
     * values are: CACHE_AUTO CACHE_CONNECTION CACHE_CONSUMER CACHE_NONE and
     * CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring
     * documentation and Transactions Cache Levels for more information.
     */
    private String cacheLevelName = "CACHE_AUTO";
    /**
     * Sets the cache level by name for the reply consumer when doing
     * request/reply over JMS. This option only applies when using fixed reply
     * queues (not temporary). Camel will by default use: CACHE_CONSUMER for
     * exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared
     * without replyToSelectorName. Some JMS brokers such as IBM WebSphere may
     * require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If
     * using temporary queues then CACHE_NONE is not allowed and you must use a
     * higher value such as CACHE_CONSUMER or CACHE_SESSION.
     */
    private String replyToCacheLevelName;
    /**
     * Sets the JMS client ID to use. Note that this value if specified must be
     * unique and can only be used by a single JMS connection instance. It is
     * typically only required for durable topic subscriptions. If using Apache
     * ActiveMQ you may prefer to use Virtual Topics instead.
     */
    private String clientId;
    /**
     * Specifies the default number of concurrent consumers when consuming from
     * JMS (not for request/reply over JMS). See also the maxMessagesPerTask
     * option to control dynamic scaling up/down of threads. When doing
     * request/reply over JMS then the option replyToConcurrentConsumers is used
     * to control number of concurrent consumers on the reply message listener.
     */
    private Integer concurrentConsumers = 1;
    /**
     * Specifies the default number of concurrent consumers when doing
     * request/reply over JMS. See also the maxMessagesPerTask option to control
     * dynamic scaling up/down of threads.
     */
    private Integer replyToConcurrentConsumers = 1;
    /**
     * The connection factory to be use. A connection factory must be configured
     * either on the component or endpoint.
     */
    private ConnectionFactory connectionFactory;
    /**
     * Username to use with the ConnectionFactory. You can also configure
     * username/password directly on the ConnectionFactory.
     */
    private String username;
    /**
     * Password to use with the ConnectionFactory. You can also configure
     * username/password directly on the ConnectionFactory.
     */
    private String password;
    /**
     * Specifies whether persistent delivery is used by default.
     */
    private Boolean deliveryPersistent = true;
    /**
     * Specifies the delivery mode to be used. Possible values are Possibles
     * values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1
     * and PERSISTENT = 2.
     */
    private Integer deliveryMode;
    /**
     * The durable subscriber name for specifying durable topic subscriptions.
     * The clientId option must be configured as well.
     */
    private String durableSubscriptionName;
    /**
     * Specifies the JMS Exception Listener that is to be notified of any
     * underlying JMS exceptions.
     */
    private ExceptionListener exceptionListener;
    /**
     * Specifies a org.springframework.util.ErrorHandler to be invoked in case
     * of any uncaught exceptions thrown while processing a Message. By default
     * these exceptions will be logged at the WARN level if no errorHandler has
     * been configured. You can configure logging level and whether stack traces
     * should be logged using errorHandlerLoggingLevel and
     * errorHandlerLogStackTrace options. This makes it much easier to configure
     * than having to code a custom errorHandler.
     */
    @NestedConfigurationProperty
    private ErrorHandler errorHandler;
    /**
     * Allows to configure the default errorHandler logging level for logging
     * uncaught exceptions.
     */
    private LoggingLevel errorHandlerLoggingLevel = LoggingLevel.WARN;
    /**
     * Allows to control whether stacktraces should be logged or not by the
     * default errorHandler.
     */
    private Boolean errorHandlerLogStackTrace = true;
    /**
     * Set if the deliveryMode priority or timeToLive qualities of service
     * should be used when sending messages. This option is based on Spring's
     * JmsTemplate. The deliveryMode priority and timeToLive options are applied
     * to the current endpoint. This contrasts with the preserveMessageQos
     * option which operates at message granularity reading QoS properties
     * exclusively from the Camel In message headers.
     */
    private Boolean explicitQosEnabled = false;
    /**
     * Specifies whether the listener session should be exposed when consuming
     * messages.
     */
    private Boolean exposeListenerSession = false;
    /**
     * Specifies the limit for idle executions of a receive task not having
     * received any message within its execution. If this limit is reached the
     * task will shut down and leave receiving to other executing tasks (in the
     * case of dynamic scheduling; see the maxConcurrentConsumers setting).
     * There is additional doc available from Spring.
     */
    private Integer idleTaskExecutionLimit = 1;
    /**
     * Specify the limit for the number of consumers that are allowed to be idle
     * at any given time.
     */
    private Integer idleConsumerLimit = 1;
    /**
     * Specifies the maximum number of concurrent consumers when consuming from
     * JMS (not for request/reply over JMS). See also the maxMessagesPerTask
     * option to control dynamic scaling up/down of threads. When doing
     * request/reply over JMS then the option replyToMaxConcurrentConsumers is
     * used to control number of concurrent consumers on the reply message
     * listener.
     */
    private Integer maxConcurrentConsumers;
    /**
     * Specifies the maximum number of concurrent consumers when using
     * request/reply over JMS. See also the maxMessagesPerTask option to control
     * dynamic scaling up/down of threads.
     */
    private Integer replyToMaxConcurrentConsumers;
    /**
     * Specifies the maximum number of concurrent consumers for continue routing
     * when timeout occurred when using request/reply over JMS.
     */
    private Integer replyOnTimeoutToMaxConcurrentConsumers = 1;
    /**
     * The number of messages per task. -1 is unlimited. If you use a range for
     * concurrent consumers (eg min max) then this option can be used to set a
     * value to eg 100 to control how fast the consumers will shrink when less
     * work is required.
     */
    private Integer maxMessagesPerTask = -1;
    /**
     * To use a custom Spring
     * org.springframework.jms.support.converter.MessageConverter so you can be
     * in control how to map to/from a javax.jms.Message.
     */
    @NestedConfigurationProperty
    private MessageConverter messageConverter;
    /**
     * Specifies whether Camel should auto map the received JMS message to a
     * suited payload type such as javax.jms.TextMessage to a String etc. See
     * section about how mapping works below for more details.
     */
    private Boolean mapJmsMessage = true;
    /**
     * When sending specifies whether message IDs should be added. This is just
     * an hint to the JMS Broker. If the JMS provider accepts this hint these
     * messages must have the message ID set to null; if the provider ignores
     * the hint the message ID must be set to its normal unique value
     */
    private Boolean messageIdEnabled = true;
    /**
     * Specifies whether timestamps should be enabled by default on sending
     * messages.
     */
    private Boolean messageTimestampEnabled = true;
    /**
     * If true Camel will always make a JMS message copy of the message when it
     * is passed to the producer for sending. Copying the message is needed in
     * some situations such as when a replyToDestinationSelectorName is set
     * (incidentally Camel will set the alwaysCopyMessage option to true if a
     * replyToDestinationSelectorName is set)
     */
    private Boolean alwaysCopyMessage = false;
    /**
     * Specifies whether JMSMessageID should always be used as JMSCorrelationID
     * for InOut messages.
     */
    private Boolean useMessageIDAsCorrelationID = false;
    /**
     * Values greater than 1 specify the message priority when sending (where 0
     * is the lowest priority and 9 is the highest). The explicitQosEnabled
     * option must also be enabled in order for this option to have any effect.
     */
    private Integer priority = 4;
    /**
     * Specifies whether to inhibit the delivery of messages published by its
     * own connection.
     */
    private Boolean pubSubNoLocal = false;
    /**
     * The timeout for receiving messages (in milliseconds).
     */
    private Long receiveTimeout = 1000L;
    /**
     * Specifies the interval between recovery attempts i.e. when a connection
     * is being refreshed in milliseconds. The default is 5000 ms that is 5
     * seconds.
     */
    private Long recoveryInterval = 5000L;
    /**
     * Allows you to specify a custom task executor for consuming messages.
     */
    @NestedConfigurationProperty
    private TaskExecutor taskExecutor;
    /**
     * When sending messages specifies the time-to-live of the message (in
     * milliseconds).
     */
    private Long timeToLive = -1L;
    /**
     * Specifies whether to use transacted mode
     */
    private Boolean transacted = false;
    /**
     * If true Camel will create a JmsTransactionManager if there is no
     * transactionManager injected when option transacted=true.
     */
    private Boolean lazyCreateTransactionManager = true;
    /**
     * The Spring transaction manager to use.
     */
    @NestedConfigurationProperty
    private PlatformTransactionManager transactionManager;
    /**
     * The name of the transaction to use.
     */
    private String transactionName;
    /**
     * The timeout value of the transaction (in seconds) if using transacted
     * mode.
     */
    private Integer transactionTimeout = -1;
    /**
     * Specifies whether to test the connection on startup. This ensures that
     * when Camel starts that all the JMS consumers have a valid connection to
     * the JMS broker. If a connection cannot be granted then Camel throws an
     * exception on startup. This ensures that Camel is not started with failed
     * connections. The JMS producers is tested as well.
     */
    private Boolean testConnectionOnStartup = false;
    /**
     * Whether to startup the JmsConsumer message listener asynchronously when
     * starting a route. For example if a JmsConsumer cannot get a connection to
     * a remote JMS broker then it may block while retrying and/or failover.
     * This will cause Camel to block while starting routes. By setting this
     * option to true you will let routes startup while the JmsConsumer connects
     * to the JMS broker using a dedicated thread in asynchronous mode. If this
     * option is used then beware that if the connection could not be
     * established then an exception is logged at WARN level and the consumer
     * will not be able to receive messages; You can then restart the route to
     * retry.
     */
    private Boolean asyncStartListener = false;
    /**
     * Whether to stop the JmsConsumer message listener asynchronously when
     * stopping a route.
     */
    private Boolean asyncStopListener = false;
    /**
     * When using mapJmsMessage=false Camel will create a new JMS message to
     * send to a new JMS destination if you touch the headers (get or set)
     * during the route. Set this option to true to force Camel to send the
     * original JMS message that was received.
     */
    private Boolean forceSendOriginalMessage = false;
    /**
     * The timeout for waiting for a reply when using the InOut Exchange Pattern
     * (in milliseconds). The default is 20 seconds. You can include the header
     * CamelJmsRequestTimeout to override this endpoint configured timeout value
     * and thus have per message individual timeout values. See also the
     * requestTimeoutCheckerInterval option.
     */
    private Long requestTimeout = 20000L;
    /**
     * Configures how often Camel should check for timed out Exchanges when
     * doing request/reply over JMS. By default Camel checks once per second.
     * But if you must react faster when a timeout occurs then you can lower
     * this interval to check more frequently. The timeout is determined by the
     * option requestTimeout.
     */
    private Long requestTimeoutCheckerInterval = 1000L;
    /**
     * You can transfer the exchange over the wire instead of just the body and
     * headers. The following fields are transferred: In body Out body Fault
     * body In headers Out headers Fault headers exchange properties exchange
     * exception. This requires that the objects are serializable. Camel will
     * exclude any non-serializable objects and log it at WARN level. You must
     * enable this option on both the producer and consumer side so Camel knows
     * the payloads is an Exchange and not a regular payload.
     */
    private Boolean transferExchange = false;
    /**
     * If enabled and you are using Request Reply messaging (InOut) and an
     * Exchange failed on the consumer side then the caused Exception will be
     * send back in response as a javax.jms.ObjectMessage. If the client is
     * Camel the returned Exception is rethrown. This allows you to use Camel
     * JMS as a bridge in your routing - for example using persistent queues to
     * enable robust routing. Notice that if you also have transferExchange
     * enabled this option takes precedence. The caught exception is required to
     * be serializable. The original Exception on the consumer side can be
     * wrapped in an outer exception such as
     * org.apache.camel.RuntimeCamelException when returned to the producer.
     */
    private Boolean transferException = false;
    /**
     * If enabled and you are using Request Reply messaging (InOut) and an
     * Exchange failed with a SOAP fault (not exception) on the consumer side
     * then the fault flag on link org.apache.camel.MessageisFault() will be
     * send back in the response as a JMS header with the key link
     * JmsConstantsJMS_TRANSFER_FAULT. If the client is Camel the returned fault
     * flag will be set on the link org.apache.camel.MessagesetFault(boolean).
     * You may want to enable this when using Camel components that support
     * faults such as SOAP based such as cxf or spring-ws.
     */
    private Boolean transferFault = false;
    /**
     * Allows you to use your own implementation of the
     * org.springframework.jms.core.JmsOperations interface. Camel uses
     * JmsTemplate as default. Can be used for testing purpose but not used much
     * as stated in the spring API docs.
     */
    @NestedConfigurationProperty
    private JmsOperations jmsOperations;
    /**
     * A pluggable
     * org.springframework.jms.support.destination.DestinationResolver that
     * allows you to use your own resolver (for example to lookup the real
     * destination in a JNDI registry).
     */
    @NestedConfigurationProperty
    private DestinationResolver destinationResolver;
    /**
     * Allows for explicitly specifying which kind of strategy to use for
     * replyTo queues when doing request/reply over JMS. Possible values are:
     * Temporary Shared or Exclusive. By default Camel will use temporary
     * queues. However if replyTo has been configured then Shared is used by
     * default. This option allows you to use exclusive queues instead of shared
     * ones. See Camel JMS documentation for more details and especially the
     * notes about the implications if running in a clustered environment and
     * the fact that Shared reply queues has lower performance than its
     * alternatives Temporary and Exclusive.
     */
    private ReplyToType replyToType;
    /**
     * Set to true if you want to send message using the QoS settings specified
     * on the message instead of the QoS settings on the JMS endpoint. The
     * following three headers are considered JMSPriority JMSDeliveryMode and
     * JMSExpiration. You can provide all or only some of them. If not provided
     * Camel will fall back to use the values from the endpoint instead. So when
     * using this option the headers override the values from the endpoint. The
     * explicitQosEnabled option by contrast will only use options set on the
     * endpoint and not values from the message header.
     */
    private Boolean preserveMessageQos = false;
    /**
     * Whether the JmsConsumer processes the Exchange asynchronously. If enabled
     * then the JmsConsumer may pickup the next message from the JMS queue while
     * the previous message is being processed asynchronously (by the
     * Asynchronous Routing Engine). This means that messages may be processed
     * not 100 strictly in order. If disabled (as default) then the Exchange is
     * fully processed before the JmsConsumer will pickup the next message from
     * the JMS queue. Note if transacted has been enabled then
     * asyncConsumer=true does not run asynchronously as transaction must be
     * executed synchronously (Camel 3.0 may support async transactions).
     */
    private Boolean asyncConsumer = false;
    /**
     * Whether to allow sending messages with no body. If this option is false
     * and the message body is null then an JMSException is thrown.
     */
    private Boolean allowNullBody = true;
    /**
     * Only applicable when sending to JMS destination using InOnly (eg fire and
     * forget). Enabling this option will enrich the Camel Exchange with the
     * actual JMSMessageID that was used by the JMS client when the message was
     * sent to the JMS destination.
     */
    private Boolean includeSentJMSMessageID = false;
    /**
     * Whether to include all JMSXxxx properties when mapping from JMS to Camel
     * Message. Setting this to true will include properties such as JMSXAppID
     * and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy
     * then this option does not apply.
     */
    private Boolean includeAllJMSXProperties = false;
    /**
     * Specifies what default TaskExecutor type to use in the
     * DefaultMessageListenerContainer for both consumer endpoints and the
     * ReplyTo consumer of producer endpoints. Possible values: SimpleAsync
     * (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's
     * ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If
     * not set it defaults to the previous behaviour which uses a cached thread
     * pool for consumer endpoints and SimpleAsync for reply consumers. The use
     * of ThreadPool is recommended to reduce thread trash in elastic
     * configurations with dynamically increasing and decreasing concurrent
     * consumers.
     */
    private DefaultTaskExecutorType defaultTaskExecutorType;
    /**
     * Pluggable strategy for encoding and decoding JMS keys so they can be
     * compliant with the JMS specification. Camel provides two implementations
     * out of the box: default and passthrough. The default strategy will safely
     * marshal dots and hyphens (. and -). The passthrough strategy leaves the
     * key as is. Can be used for JMS brokers which do not care whether JMS
     * header keys contain illegal characters. You can provide your own
     * implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy
     * and refer to it using the notation.
     */
    @NestedConfigurationProperty
    private JmsKeyFormatStrategy jmsKeyFormatStrategy;
    /**
     * This option is used to allow additional headers which may have values
     * that are invalid according to JMS specification. For example some message
     * systems such as WMQ do this with header names using prefix JMS_IBM_MQMD_
     * containing values with byte array or other invalid types. You can specify
     * multiple header names separated by comma and use as suffix for wildcard
     * matching.
     */
    private String allowAdditionalHeaders;
    /**
     * To use a custom QueueBrowseStrategy when browsing queues
     */
    @NestedConfigurationProperty
    private QueueBrowseStrategy queueBrowseStrategy;
    /**
     * To use the given MessageCreatedStrategy which are invoked when Camel
     * creates new instances of javax.jms.Message objects when Camel is sending
     * a JMS message.
     */
    @NestedConfigurationProperty
    private MessageCreatedStrategy messageCreatedStrategy;
    /**
     * Number of times to wait for provisional correlation id to be updated to
     * the actual correlation id when doing request/reply over JMS and when the
     * option useMessageIDAsCorrelationID is enabled.
     */
    private Integer waitForProvisionCorrelationToBeUpdatedCounter = 50;
    /**
     * Interval in millis to sleep each time while waiting for provisional
     * correlation id to be updated.
     */
    private Long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime = 100L;
    /**
     * Use this JMS property to correlate messages in InOut exchange pattern
     * (request-reply) instead of JMSCorrelationID property. This allows you to
     * exchange messages with systems that do not correlate messages using
     * JMSCorrelationID JMS property. If used JMSCorrelationID will not be used
     * or set by Camel. The value of here named property will be generated if
     * not supplied in the header of the message under the same name.
     */
    private String correlationProperty;
    /**
     * Set whether to make the subscription durable. The durable subscription
     * name to be used can be specified through the subscriptionName property.
     * Default is false. Set this to true to register a durable subscription
     * typically in combination with a subscriptionName value (unless your
     * message listener class name is good enough as subscription name). Only
     * makes sense when listening to a topic (pub-sub domain) therefore this
     * method switches the pubSubDomain flag as well.
     */
    private Boolean subscriptionDurable = false;
    /**
     * Set whether to make the subscription shared. The shared subscription name
     * to be used can be specified through the subscriptionName property.
     * Default is false. Set this to true to register a shared subscription
     * typically in combination with a subscriptionName value (unless your
     * message listener class name is good enough as subscription name). Note
     * that shared subscriptions may also be durable so this flag can (and often
     * will) be combined with subscriptionDurable as well. Only makes sense when
     * listening to a topic (pub-sub domain) therefore this method switches the
     * pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.
     */
    private Boolean subscriptionShared = false;
    /**
     * Set the name of a subscription to create. To be applied in case of a
     * topic (pub-sub domain) with a shared or durable subscription. The
     * subscription name needs to be unique within this client's JMS client id.
     * Default is the class name of the specified message listener. Note: Only 1
     * concurrent consumer (which is the default of this message listener
     * container) is allowed for each subscription except for a shared
     * subscription (which requires JMS 2.0).
     */
    private String subscriptionName;
    /**
     * Sets whether StreamMessage type is enabled or not. Message payloads of
     * streaming kind such as files InputStream etc will either by sent as
     * BytesMessage or StreamMessage. This option controls which kind will be
     * used. By default BytesMessage is used which enforces the entire message
     * payload to be read into memory. By enabling this option the message
     * payload is read into memory in chunks and each chunk is then written to
     * the StreamMessage until no more data.
     */
    private Boolean streamMessageTypeEnabled = false;
    /**
     * To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter
     * header to and from Camel message.
     */
    @NestedConfigurationProperty
    private HeaderFilterStrategy headerFilterStrategy;
    /**
     * Whether the component should resolve property placeholders on itself when
     * starting. Only properties which are of String type can use property
     * placeholders.
     */
    private Boolean resolvePropertyPlaceholders = true;

    public JmsConfigurationNestedConfiguration getConfiguration() {
        return configuration;
    }

    public void setConfiguration(
            JmsConfigurationNestedConfiguration configuration) {
        this.configuration = configuration;
    }

    public Boolean getAcceptMessagesWhileStopping() {
        return acceptMessagesWhileStopping;
    }

    public void setAcceptMessagesWhileStopping(
            Boolean acceptMessagesWhileStopping) {
        this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;
    }

    public Boolean getAllowReplyManagerQuickStop() {
        return allowReplyManagerQuickStop;
    }

    public void setAllowReplyManagerQuickStop(Boolean allowReplyManagerQuickStop) {
        this.allowReplyManagerQuickStop = allowReplyManagerQuickStop;
    }

    public Integer getAcknowledgementMode() {
        return acknowledgementMode;
    }

    public void setAcknowledgementMode(Integer acknowledgementMode) {
        this.acknowledgementMode = acknowledgementMode;
    }

    public Boolean getEagerLoadingOfProperties() {
        return eagerLoadingOfProperties;
    }

    public void setEagerLoadingOfProperties(Boolean eagerLoadingOfProperties) {
        this.eagerLoadingOfProperties = eagerLoadingOfProperties;
    }

    public String getAcknowledgementModeName() {
        return acknowledgementModeName;
    }

    public void setAcknowledgementModeName(String acknowledgementModeName) {
        this.acknowledgementModeName = acknowledgementModeName;
    }

    public Boolean getAutoStartup() {
        return autoStartup;
    }

    public void setAutoStartup(Boolean autoStartup) {
        this.autoStartup = autoStartup;
    }

    public Integer getCacheLevel() {
        return cacheLevel;
    }

    public void setCacheLevel(Integer cacheLevel) {
        this.cacheLevel = cacheLevel;
    }

    public String getCacheLevelName() {
        return cacheLevelName;
    }

    public void setCacheLevelName(String cacheLevelName) {
        this.cacheLevelName = cacheLevelName;
    }

    public String getReplyToCacheLevelName() {
        return replyToCacheLevelName;
    }

    public void setReplyToCacheLevelName(String replyToCacheLevelName) {
        this.replyToCacheLevelName = replyToCacheLevelName;
    }

    public String getClientId() {
        return clientId;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public Integer getConcurrentConsumers() {
        return concurrentConsumers;
    }

    public void setConcurrentConsumers(Integer concurrentConsumers) {
        this.concurrentConsumers = concurrentConsumers;
    }

    public Integer getReplyToConcurrentConsumers() {
        return replyToConcurrentConsumers;
    }

    public void setReplyToConcurrentConsumers(Integer replyToConcurrentConsumers) {
        this.replyToConcurrentConsumers = replyToConcurrentConsumers;
    }

    public ConnectionFactory getConnectionFactory() {
        return connectionFactory;
    }

    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Boolean getDeliveryPersistent() {
        return deliveryPersistent;
    }

    public void setDeliveryPersistent(Boolean deliveryPersistent) {
        this.deliveryPersistent = deliveryPersistent;
    }

    public Integer getDeliveryMode() {
        return deliveryMode;
    }

    public void setDeliveryMode(Integer deliveryMode) {
        this.deliveryMode = deliveryMode;
    }

    public String getDurableSubscriptionName() {
        return durableSubscriptionName;
    }

    public void setDurableSubscriptionName(String durableSubscriptionName) {
        this.durableSubscriptionName = durableSubscriptionName;
    }

    public ExceptionListener getExceptionListener() {
        return exceptionListener;
    }

    public void setExceptionListener(ExceptionListener exceptionListener) {
        this.exceptionListener = exceptionListener;
    }

    public ErrorHandler getErrorHandler() {
        return errorHandler;
    }

    public void setErrorHandler(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }

    public LoggingLevel getErrorHandlerLoggingLevel() {
        return errorHandlerLoggingLevel;
    }

    public void setErrorHandlerLoggingLevel(
            LoggingLevel errorHandlerLoggingLevel) {
        this.errorHandlerLoggingLevel = errorHandlerLoggingLevel;
    }

    public Boolean getErrorHandlerLogStackTrace() {
        return errorHandlerLogStackTrace;
    }

    public void setErrorHandlerLogStackTrace(Boolean errorHandlerLogStackTrace) {
        this.errorHandlerLogStackTrace = errorHandlerLogStackTrace;
    }

    public Boolean getExplicitQosEnabled() {
        return explicitQosEnabled;
    }

    public void setExplicitQosEnabled(Boolean explicitQosEnabled) {
        this.explicitQosEnabled = explicitQosEnabled;
    }

    public Boolean getExposeListenerSession() {
        return exposeListenerSession;
    }

    public void setExposeListenerSession(Boolean exposeListenerSession) {
        this.exposeListenerSession = exposeListenerSession;
    }

    public Integer getIdleTaskExecutionLimit() {
        return idleTaskExecutionLimit;
    }

    public void setIdleTaskExecutionLimit(Integer idleTaskExecutionLimit) {
        this.idleTaskExecutionLimit = idleTaskExecutionLimit;
    }

    public Integer getIdleConsumerLimit() {
        return idleConsumerLimit;
    }

    public void setIdleConsumerLimit(Integer idleConsumerLimit) {
        this.idleConsumerLimit = idleConsumerLimit;
    }

    public Integer getMaxConcurrentConsumers() {
        return maxConcurrentConsumers;
    }

    public void setMaxConcurrentConsumers(Integer maxConcurrentConsumers) {
        this.maxConcurrentConsumers = maxConcurrentConsumers;
    }

    public Integer getReplyToMaxConcurrentConsumers() {
        return replyToMaxConcurrentConsumers;
    }

    public void setReplyToMaxConcurrentConsumers(
            Integer replyToMaxConcurrentConsumers) {
        this.replyToMaxConcurrentConsumers = replyToMaxConcurrentConsumers;
    }

    public Integer getReplyOnTimeoutToMaxConcurrentConsumers() {
        return replyOnTimeoutToMaxConcurrentConsumers;
    }

    public void setReplyOnTimeoutToMaxConcurrentConsumers(
            Integer replyOnTimeoutToMaxConcurrentConsumers) {
        this.replyOnTimeoutToMaxConcurrentConsumers = replyOnTimeoutToMaxConcurrentConsumers;
    }

    public Integer getMaxMessagesPerTask() {
        return maxMessagesPerTask;
    }

    public void setMaxMessagesPerTask(Integer maxMessagesPerTask) {
        this.maxMessagesPerTask = maxMessagesPerTask;
    }

    public MessageConverter getMessageConverter() {
        return messageConverter;
    }

    public void setMessageConverter(MessageConverter messageConverter) {
        this.messageConverter = messageConverter;
    }

    public Boolean getMapJmsMessage() {
        return mapJmsMessage;
    }

    public void setMapJmsMessage(Boolean mapJmsMessage) {
        this.mapJmsMessage = mapJmsMessage;
    }

    public Boolean getMessageIdEnabled() {
        return messageIdEnabled;
    }

    public void setMessageIdEnabled(Boolean messageIdEnabled) {
        this.messageIdEnabled = messageIdEnabled;
    }

    public Boolean getMessageTimestampEnabled() {
        return messageTimestampEnabled;
    }

    public void setMessageTimestampEnabled(Boolean messageTimestampEnabled) {
        this.messageTimestampEnabled = messageTimestampEnabled;
    }

    public Boolean getAlwaysCopyMessage() {
        return alwaysCopyMessage;
    }

    public void setAlwaysCopyMessage(Boolean alwaysCopyMessage) {
        this.alwaysCopyMessage = alwaysCopyMessage;
    }

    public Boolean getUseMessageIDAsCorrelationID() {
        return useMessageIDAsCorrelationID;
    }

    public void setUseMessageIDAsCorrelationID(
            Boolean useMessageIDAsCorrelationID) {
        this.useMessageIDAsCorrelationID = useMessageIDAsCorrelationID;
    }

    public Integer getPriority() {
        return priority;
    }

    public void setPriority(Integer priority) {
        this.priority = priority;
    }

    public Boolean getPubSubNoLocal() {
        return pubSubNoLocal;
    }

    public void setPubSubNoLocal(Boolean pubSubNoLocal) {
        this.pubSubNoLocal = pubSubNoLocal;
    }

    public Long getReceiveTimeout() {
        return receiveTimeout;
    }

    public void setReceiveTimeout(Long receiveTimeout) {
        this.receiveTimeout = receiveTimeout;
    }

    public Long getRecoveryInterval() {
        return recoveryInterval;
    }

    public void setRecoveryInterval(Long recoveryInterval) {
        this.recoveryInterval = recoveryInterval;
    }

    public TaskExecutor getTaskExecutor() {
        return taskExecutor;
    }

    public void setTaskExecutor(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }

    public Long getTimeToLive() {
        return timeToLive;
    }

    public void setTimeToLive(Long timeToLive) {
        this.timeToLive = timeToLive;
    }

    public Boolean getTransacted() {
        return transacted;
    }

    public void setTransacted(Boolean transacted) {
        this.transacted = transacted;
    }

    public Boolean getLazyCreateTransactionManager() {
        return lazyCreateTransactionManager;
    }

    public void setLazyCreateTransactionManager(
            Boolean lazyCreateTransactionManager) {
        this.lazyCreateTransactionManager = lazyCreateTransactionManager;
    }

    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }

    public void setTransactionManager(
            PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public String getTransactionName() {
        return transactionName;
    }

    public void setTransactionName(String transactionName) {
        this.transactionName = transactionName;
    }

    public Integer getTransactionTimeout() {
        return transactionTimeout;
    }

    public void setTransactionTimeout(Integer transactionTimeout) {
        this.transactionTimeout = transactionTimeout;
    }

    public Boolean getTestConnectionOnStartup() {
        return testConnectionOnStartup;
    }

    public void setTestConnectionOnStartup(Boolean testConnectionOnStartup) {
        this.testConnectionOnStartup = testConnectionOnStartup;
    }

    public Boolean getAsyncStartListener() {
        return asyncStartListener;
    }

    public void setAsyncStartListener(Boolean asyncStartListener) {
        this.asyncStartListener = asyncStartListener;
    }

    public Boolean getAsyncStopListener() {
        return asyncStopListener;
    }

    public void setAsyncStopListener(Boolean asyncStopListener) {
        this.asyncStopListener = asyncStopListener;
    }

    public Boolean getForceSendOriginalMessage() {
        return forceSendOriginalMessage;
    }

    public void setForceSendOriginalMessage(Boolean forceSendOriginalMessage) {
        this.forceSendOriginalMessage = forceSendOriginalMessage;
    }

    public Long getRequestTimeout() {
        return requestTimeout;
    }

    public void setRequestTimeout(Long requestTimeout) {
        this.requestTimeout = requestTimeout;
    }

    public Long getRequestTimeoutCheckerInterval() {
        return requestTimeoutCheckerInterval;
    }

    public void setRequestTimeoutCheckerInterval(
            Long requestTimeoutCheckerInterval) {
        this.requestTimeoutCheckerInterval = requestTimeoutCheckerInterval;
    }

    public Boolean getTransferExchange() {
        return transferExchange;
    }

    public void setTransferExchange(Boolean transferExchange) {
        this.transferExchange = transferExchange;
    }

    public Boolean getTransferException() {
        return transferException;
    }

    public void setTransferException(Boolean transferException) {
        this.transferException = transferException;
    }

    public Boolean getTransferFault() {
        return transferFault;
    }

    public void setTransferFault(Boolean transferFault) {
        this.transferFault = transferFault;
    }

    public JmsOperations getJmsOperations() {
        return jmsOperations;
    }

    public void setJmsOperations(JmsOperations jmsOperations) {
        this.jmsOperations = jmsOperations;
    }

    public DestinationResolver getDestinationResolver() {
        return destinationResolver;
    }

    public void setDestinationResolver(DestinationResolver destinationResolver) {
        this.destinationResolver = destinationResolver;
    }

    public ReplyToType getReplyToType() {
        return replyToType;
    }

    public void setReplyToType(ReplyToType replyToType) {
        this.replyToType = replyToType;
    }

    public Boolean getPreserveMessageQos() {
        return preserveMessageQos;
    }

    public void setPreserveMessageQos(Boolean preserveMessageQos) {
        this.preserveMessageQos = preserveMessageQos;
    }

    public Boolean getAsyncConsumer() {
        return asyncConsumer;
    }

    public void setAsyncConsumer(Boolean asyncConsumer) {
        this.asyncConsumer = asyncConsumer;
    }

    public Boolean getAllowNullBody() {
        return allowNullBody;
    }

    public void setAllowNullBody(Boolean allowNullBody) {
        this.allowNullBody = allowNullBody;
    }

    public Boolean getIncludeSentJMSMessageID() {
        return includeSentJMSMessageID;
    }

    public void setIncludeSentJMSMessageID(Boolean includeSentJMSMessageID) {
        this.includeSentJMSMessageID = includeSentJMSMessageID;
    }

    public Boolean getIncludeAllJMSXProperties() {
        return includeAllJMSXProperties;
    }

    public void setIncludeAllJMSXProperties(Boolean includeAllJMSXProperties) {
        this.includeAllJMSXProperties = includeAllJMSXProperties;
    }

    public DefaultTaskExecutorType getDefaultTaskExecutorType() {
        return defaultTaskExecutorType;
    }

    public void setDefaultTaskExecutorType(
            DefaultTaskExecutorType defaultTaskExecutorType) {
        this.defaultTaskExecutorType = defaultTaskExecutorType;
    }

    public JmsKeyFormatStrategy getJmsKeyFormatStrategy() {
        return jmsKeyFormatStrategy;
    }

    public void setJmsKeyFormatStrategy(
            JmsKeyFormatStrategy jmsKeyFormatStrategy) {
        this.jmsKeyFormatStrategy = jmsKeyFormatStrategy;
    }

    public String getAllowAdditionalHeaders() {
        return allowAdditionalHeaders;
    }

    public void setAllowAdditionalHeaders(String allowAdditionalHeaders) {
        this.allowAdditionalHeaders = allowAdditionalHeaders;
    }

    public QueueBrowseStrategy getQueueBrowseStrategy() {
        return queueBrowseStrategy;
    }

    public void setQueueBrowseStrategy(QueueBrowseStrategy queueBrowseStrategy) {
        this.queueBrowseStrategy = queueBrowseStrategy;
    }

    public MessageCreatedStrategy getMessageCreatedStrategy() {
        return messageCreatedStrategy;
    }

    public void setMessageCreatedStrategy(
            MessageCreatedStrategy messageCreatedStrategy) {
        this.messageCreatedStrategy = messageCreatedStrategy;
    }

    public Integer getWaitForProvisionCorrelationToBeUpdatedCounter() {
        return waitForProvisionCorrelationToBeUpdatedCounter;
    }

    public void setWaitForProvisionCorrelationToBeUpdatedCounter(
            Integer waitForProvisionCorrelationToBeUpdatedCounter) {
        this.waitForProvisionCorrelationToBeUpdatedCounter = waitForProvisionCorrelationToBeUpdatedCounter;
    }

    public Long getWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime() {
        return waitForProvisionCorrelationToBeUpdatedThreadSleepingTime;
    }

    public void setWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime(
            Long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime) {
        this.waitForProvisionCorrelationToBeUpdatedThreadSleepingTime = waitForProvisionCorrelationToBeUpdatedThreadSleepingTime;
    }

    public String getCorrelationProperty() {
        return correlationProperty;
    }

    public void setCorrelationProperty(String correlationProperty) {
        this.correlationProperty = correlationProperty;
    }

    public Boolean getSubscriptionDurable() {
        return subscriptionDurable;
    }

    public void setSubscriptionDurable(Boolean subscriptionDurable) {
        this.subscriptionDurable = subscriptionDurable;
    }

    public Boolean getSubscriptionShared() {
        return subscriptionShared;
    }

    public void setSubscriptionShared(Boolean subscriptionShared) {
        this.subscriptionShared = subscriptionShared;
    }

    public String getSubscriptionName() {
        return subscriptionName;
    }

    public void setSubscriptionName(String subscriptionName) {
        this.subscriptionName = subscriptionName;
    }

    public Boolean getStreamMessageTypeEnabled() {
        return streamMessageTypeEnabled;
    }

    public void setStreamMessageTypeEnabled(Boolean streamMessageTypeEnabled) {
        this.streamMessageTypeEnabled = streamMessageTypeEnabled;
    }

    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }

    public void setHeaderFilterStrategy(
            HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }

    public Boolean getResolvePropertyPlaceholders() {
        return resolvePropertyPlaceholders;
    }

    public void setResolvePropertyPlaceholders(
            Boolean resolvePropertyPlaceholders) {
        this.resolvePropertyPlaceholders = resolvePropertyPlaceholders;
    }

    public static class JmsConfigurationNestedConfiguration {
        public static final Class CAMEL_NESTED_CLASS = org.apache.camel.component.jms.JmsConfiguration.class;
        /**
         * The consumer type to use, which can be one of: Simple, Default, or
         * Custom. The consumer type determines which Spring JMS listener to
         * use. Default will use
         * org.springframework.jms.listener.DefaultMessageListenerContainer,
         * Simple will use
         * org.springframework.jms.listener.SimpleMessageListenerContainer. When
         * Custom is specified, the MessageListenerContainerFactory defined by
         * the messageListenerContainerFactory option will determine what
         * org.springframework.jms.listener.AbstractMessageListenerContainer to
         * use.
         */
        private ConsumerType consumerType = ConsumerType.Default;
        /**
         * Sets the default connection factory to be used if a connection
         * factory is not specified for either
         * {@link #setTemplateConnectionFactory(ConnectionFactory)} or
         * {@link #setListenerConnectionFactory(ConnectionFactory)}
         */
        private ConnectionFactory connectionFactory;
        /**
         * Username to use with the ConnectionFactory. You can also configure
         * username/password directly on the ConnectionFactory.
         */
        private String username;
        /**
         * Password to use with the ConnectionFactory. You can also configure
         * username/password directly on the ConnectionFactory.
         */
        private String password;
        /**
         * Sets the connection factory to be used for consuming messages
         */
        private ConnectionFactory listenerConnectionFactory;
        /**
         * Sets the connection factory to be used for sending messages via the
         * {@link JmsTemplate} via
         * {@link #createInOnlyTemplate(JmsEndpoint,boolean,String)}
         */
        private ConnectionFactory templateConnectionFactory;
        /**
         * Specifies whether the consumer container should auto-startup.
         */
        private Boolean autoStartup = true;
        /**
         * Specifies whether the consumer accept messages while it is stopping.
         * You may consider enabling this option, if you start and stop JMS
         * routes at runtime, while there are still messages enqueued on the
         * queue. If this option is false, and you stop the JMS route, then
         * messages may be rejected, and the JMS broker would have to attempt
         * redeliveries, which yet again may be rejected, and eventually the
         * message may be moved at a dead letter queue on the JMS broker. To
         * avoid this its recommended to enable this option.
         */
        private Boolean acceptMessagesWhileStopping = false;
        private Boolean allowReplyManagerQuickStop = false;
        /**
         * Sets the JMS client ID to use. Note that this value, if specified,
         * must be unique and can only be used by a single JMS connection
         * instance. It is typically only required for durable topic
         * subscriptions.
         * <p>
         * If using Apache ActiveMQ you may prefer to use Virtual Topics
         * instead.
         */
        private String clientId;
        /**
         * The durable subscriber name for specifying durable topic
         * subscriptions. The clientId option must be configured as well.
         */
        private String durableSubscriptionName;
        /**
         * Specifies the JMS Exception Listener that is to be notified of any
         * underlying JMS exceptions.
         */
        private ExceptionListener exceptionListener;
        /**
         * Specifies a org.springframework.util.ErrorHandler to be invoked in
         * case of any uncaught exceptions thrown while processing a Message. By
         * default these exceptions will be logged at the WARN level, if no
         * errorHandler has been configured. You can configure logging level and
         * whether stack traces should be logged using errorHandlerLoggingLevel
         * and errorHandlerLogStackTrace options. This makes it much easier to
         * configure, than having to code a custom errorHandler.
         */
        private ErrorHandler errorHandler;
        /**
         * Allows to configure the default errorHandler logging level for
         * logging uncaught exceptions.
         */
        private LoggingLevel errorHandlerLoggingLevel = LoggingLevel.WARN;
        /**
         * Allows to control whether stacktraces should be logged or not, by the
         * default errorHandler.
         */
        private Boolean errorHandlerLogStackTrace = true;
        /**
         * The JMS acknowledgement name, which is one of: SESSION_TRANSACTED,
         * CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE
         */
        private String acknowledgementModeName = "AUTO_ACKNOWLEDGE";
        /**
         * Specifies whether the listener session should be exposed when
         * consuming messages.
         */
        private Boolean exposeListenerSession = false;
        /**
         * Allows you to specify a custom task executor for consuming messages.
         */
        private TaskExecutor taskExecutor;
        /**
         * Specifies whether to inhibit the delivery of messages published by
         * its own connection.
         */
        private Boolean pubSubNoLocal = false;
        /**
         * Specifies the default number of concurrent consumers when consuming
         * from JMS (not for request/reply over JMS). See also the
         * maxMessagesPerTask option to control dynamic scaling up/down of
         * threads.
         * <p>
         * When doing request/reply over JMS then the option
         * replyToConcurrentConsumers is used to control number of concurrent
         * consumers on the reply message listener.
         */
        private Integer concurrentConsumers = 1;
        /**
         * Specifies the default number of concurrent consumers when doing
         * request/reply over JMS. See also the maxMessagesPerTask option to
         * control dynamic scaling up/down of threads.
         */
        private Integer replyToConcurrentConsumers = 1;
        /**
         * The number of messages per task. -1 is unlimited. If you use a range
         * for concurrent consumers (eg min < max), then this option can be used
         * to set a value to eg 100 to control how fast the consumers will
         * shrink when less work is required.
         */
        private Integer maxMessagesPerTask = -1;
        /**
         * Sets the cache level by ID for the underlying JMS resources. See
         * cacheLevelName option for more details.
         */
        private Integer cacheLevel;
        /**
         * Sets the cache level by name for the underlying JMS resources.
         * Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER,
         * CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See
         * the Spring documentation and Transactions Cache Levels for more
         * information.
         */
        private String cacheLevelName = "CACHE_AUTO";
        /**
         * Specifies the interval between recovery attempts, i.e. when a
         * connection is being refreshed, in milliseconds. The default is 5000
         * ms, that is, 5 seconds.
         */
        private Long recoveryInterval = 5000L;
        /**
         * The timeout for receiving messages (in milliseconds).
         */
        private Long receiveTimeout = 1000L;
        /**
         * The Spring transaction manager to use.
         */
        private PlatformTransactionManager transactionManager;
        /**
         * The name of the transaction to use.
         */
        private String transactionName;
        /**
         * The timeout value of the transaction (in seconds), if using
         * transacted mode.
         */
        private Integer transactionTimeout = -1;
        /**
         * Specifies the limit for idle executions of a receive task, not having
         * received any message within its execution. If this limit is reached,
         * the task will shut down and leave receiving to other executing tasks
         * (in the case of dynamic scheduling; see the maxConcurrentConsumers
         * setting). There is additional doc available from Spring.
         */
        private Integer idleTaskExecutionLimit = 1;
        /**
         * Specify the limit for the number of consumers that are allowed to be
         * idle at any given time.
         */
        private Integer idleConsumerLimit = 1;
        /**
         * Number of times to wait for provisional correlation id to be updated
         * to the actual correlation id when doing request/reply over JMS and
         * when the option useMessageIDAsCorrelationID is enabled.
         */
        private Integer waitForProvisionCorrelationToBeUpdatedCounter = 50;
        /**
         * Interval in millis to sleep each time while waiting for provisional
         * correlation id to be updated.
         */
        private Long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime = 100L;
        /**
         * Specifies the maximum number of concurrent consumers when consuming
         * from JMS (not for request/reply over JMS). See also the
         * maxMessagesPerTask option to control dynamic scaling up/down of
         * threads.
         * <p>
         * When doing request/reply over JMS then the option
         * replyToMaxConcurrentConsumers is used to control number of concurrent
         * consumers on the reply message listener.
         */
        private Integer maxConcurrentConsumers;
        /**
         * Specifies the maximum number of concurrent consumers when using
         * request/reply over JMS. See also the maxMessagesPerTask option to
         * control dynamic scaling up/down of threads.
         */
        private Integer replyToMaxConcurrentConsumers;
        /**
         * Specifies the maximum number of concurrent consumers for continue
         * routing when timeout occurred when using request/reply over JMS.
         */
        private Integer replyToOnTimeoutMaxConcurrentConsumers = 1;
        /**
         * Specifies whether persistent delivery is used by default.
         */
        private Boolean deliveryPersistent = true;
        /**
         * Specifies the delivery mode to be used. Possibles values are those
         * defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT
         * = 2.
         */
        private Integer deliveryMode;
        /**
         * Specifies whether to use persistent delivery by default for replies.
         */
        private Boolean replyToDeliveryPersistent = true;
        /**
         * When sending messages, specifies the time-to-live of the message (in
         * milliseconds).
         */
        private Long timeToLive = -1L;
        /**
         * To use a custom Spring
         * org.springframework.jms.support.converter.MessageConverter so you can
         * be in control how to map to/from a javax.jms.Message.
         */
        private MessageConverter messageConverter;
        /**
         * Specifies whether Camel should auto map the received JMS message to a
         * suited payload type, such as javax.jms.TextMessage to a String etc.
         */
        private Boolean mapJmsMessage = true;
        /**
         * When sending, specifies whether message IDs should be added. This is
         * just an hint to the JMS Broker. If the JMS provider accepts this
         * hint, these messages must have the message ID set to null; if the
         * provider ignores the hint, the message ID must be set to its normal
         * unique value
         */
        private Boolean messageIdEnabled = true;
        /**
         * Specifies whether timestamps should be enabled by default on sending
         * messages. This is just an hint to the JMS Broker. If the JMS provider
         * accepts this hint, these messages must have the timestamp set to
         * zero; if the provider ignores the hint, the timestamp must be set to
         * its normal value
         */
        private Boolean messageTimestampEnabled = true;
        /**
         * Values greater than 1 specify the message priority when sending
         * (where 0 is the lowest priority and 9 is the highest). The
         * explicitQosEnabled option must also be enabled in order for this
         * option to have any effect.
         */
        private Integer priority = 4;
        /**
         * The JMS acknowledgement mode defined as an Integer. Allows you to set
         * vendor-specific extensions to the acknowledgment mode. For the
         * regular modes, it is preferable to use the acknowledgementModeName
         * instead.
         */
        private Integer acknowledgementMode;
        /**
         * Specifies whether to use transacted mode
         */
        private Boolean transacted = false;
        @Deprecated
        private Boolean transactedInOut;
        /**
         * If true, Camel will create a JmsTransactionManager, if there is no
         * transactionManager injected when option transacted=true.
         */
        private Boolean lazyCreateTransactionManager = true;
        /**
         * Enables eager loading of JMS properties as soon as a message is
         * loaded which generally is inefficient as the JMS properties may not
         * be required but sometimes can catch early any issues with the
         * underlying JMS provider and the use of JMS properties
         */
        private Boolean eagerLoadingOfProperties = false;
        /**
         * Specifies whether Camel ignores the JMSReplyTo header in messages. If
         * true, Camel does not send a reply back to the destination specified
         * in the JMSReplyTo header. You can use this option if you want Camel
         * to consume from a route and you do not want Camel to automatically
         * send back a reply message because another component in your code
         * handles the reply message. You can also use this option if you want
         * to use Camel as a proxy between different message brokers and you
         * want to route message from one system to another.
         */
        private Boolean disableReplyTo = false;
        /**
         * Set to true, if you want to send message using the QoS settings
         * specified on the message, instead of the QoS settings on the JMS
         * endpoint. The following three headers are considered JMSPriority,
         * JMSDeliveryMode, and JMSExpiration. You can provide all or only some
         * of them. If not provided, Camel will fall back to use the values from
         * the endpoint instead. So, when using this option, the headers
         * override the values from the endpoint. The explicitQosEnabled option,
         * by contrast, will only use options set on the endpoint, and not
         * values from the message header.
         */
        private Boolean preserveMessageQos = false;
        /**
         * Allows you to use your own implementation of the
         * org.springframework.jms.core.JmsOperations interface. Camel uses
         * JmsTemplate as default. Can be used for testing purpose, but not used
         * much as stated in the spring API docs.
         */
        private JmsOperations jmsOperations;
        /**
         * A pluggable
         * org.springframework.jms.support.destination.DestinationResolver that
         * allows you to use your own resolver (for example, to lookup the real
         * destination in a JNDI registry).
         */
        private DestinationResolver destinationResolver;
        /**
         * Allows the provider metadata to be explicitly configured. Typically
         * this is not required and Camel will auto-detect the provider metadata
         * from the underlying provider.
         */
        @NestedConfigurationProperty
        private JmsProviderMetadata providerMetadata;
        /**
         * Sets the {@link JmsOperations} used to deduce the
         * {@link JmsProviderMetadata} details which if none is customized one
         * is lazily created on demand
         */
        private JmsOperations metadataJmsOperations;
        /**
         * If true, Camel will always make a JMS message copy of the message
         * when it is passed to the producer for sending. Copying the message is
         * needed in some situations, such as when a
         * replyToDestinationSelectorName is set (incidentally, Camel will set
         * the alwaysCopyMessage option to true, if a
         * replyToDestinationSelectorName is set)
         */
        private Boolean alwaysCopyMessage = false;
        /**
         * Specifies whether JMSMessageID should always be used as
         * JMSCorrelationID for InOut messages.
         */
        private Boolean useMessageIDAsCorrelationID = false;
        /**
         * The timeout for waiting for a reply when using the InOut Exchange
         * Pattern (in milliseconds). The default is 20 seconds. You can include
         * the header "CamelJmsRequestTimeout" to override this endpoint
         * configured timeout value, and thus have per message individual
         * timeout values. See also the requestTimeoutCheckerInterval option.
         */
        private Long requestTimeout = 20000L;
        /**
         * Configures how often Camel should check for timed out Exchanges when
         * doing request/reply over JMS. By default Camel checks once per
         * second. But if you must react faster when a timeout occurs, then you
         * can lower this interval, to check more frequently. The timeout is
         * determined by the option requestTimeout.
         */
        private Long requestTimeoutCheckerInterval = 1000L;
        /**
         * Provides an explicit ReplyTo destination, which overrides any
         * incoming value of Message.getJMSReplyTo().
         */
        private String replyTo;
        /**
         * Sets the JMS Selector using the fixed name to be used so you can
         * filter out your own replies from the others when using a shared queue
         * (that is, if you are not using a temporary reply queue).
         */
        private String replyToDestinationSelectorName;
        /**
         * Provides an explicit ReplyTo destination in the JMS message, which
         * overrides the setting of replyTo. It is useful if you want to forward
         * the message to a remote Queue and receive the reply message from the
         * ReplyTo destination.
         */
        private String replyToOverride;
        /**
         * Whether a JMS consumer is allowed to send a reply message to the same
         * destination that the consumer is using to consume from. This prevents
         * an endless loop by consuming and sending back the same message to
         * itself.
         */
        private Boolean replyToSameDestinationAllowed = false;
        /**
         * Allows you to force the use of a specific javax.jms.Message
         * implementation for sending JMS messages. Possible values are: Bytes,
         * Map, Object, Stream, Text. By default, Camel would determine which
         * JMS message type to use from the In body type. This option allows you
         * to specify it.
         */
        private JmsMessageType jmsMessageType;
        /**
         * Pluggable strategy for encoding and decoding JMS keys so they can be
         * compliant with the JMS specification. Camel provides two
         * implementations out of the box: default and passthrough. The default
         * strategy will safely marshal dots and hyphens (. and -). The
         * passthrough strategy leaves the key as is. Can be used for JMS
         * brokers which do not care whether JMS header keys contain illegal
         * characters. You can provide your own implementation of the
         * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it
         * using the # notation.
         */
        private JmsKeyFormatStrategy jmsKeyFormatStrategy;
        /**
         * You can transfer the exchange over the wire instead of just the body
         * and headers. The following fields are transferred: In body, Out body,
         * Fault body, In headers, Out headers, Fault headers, exchange
         * properties, exchange exception. This requires that the objects are
         * serializable. Camel will exclude any non-serializable objects and log
         * it at WARN level. You must enable this option on both the producer
         * and consumer side, so Camel knows the payloads is an Exchange and not
         * a regular payload.
         */
        private Boolean transferExchange = false;
        /**
         * Controls whether or not to include serialized headers. Applies only
         * when {@link #isTransferExchange()} is {@code true} . This requires
         * that the objects are serializable. Camel will exclude any
         * non-serializable objects and log it at WARN level.
         */
        private Boolean allowSerializedHeaders = false;
        /**
         * If enabled and you are using Request Reply messaging (InOut) and an
         * Exchange failed on the consumer side, then the caused Exception will
         * be send back in response as a javax.jms.ObjectMessage. If the client
         * is Camel, the returned Exception is rethrown. This allows you to use
         * Camel JMS as a bridge in your routing - for example, using persistent
         * queues to enable robust routing. Notice that if you also have
         * transferExchange enabled, this option takes precedence. The caught
         * exception is required to be serializable. The original Exception on
         * the consumer side can be wrapped in an outer exception such as
         * org.apache.camel.RuntimeCamelException when returned to the producer.
         */
        private Boolean transferException = false;
        /**
         * If enabled and you are using Request Reply messaging (InOut) and an
         * Exchange failed with a SOAP fault (not exception) on the consumer
         * side, then the fault flag on
         * {@link org.apache.camel.Message#isFault()} will be send back in the
         * response as a JMS header with the key
         * {@link JmsConstants#JMS_TRANSFER_FAULT} . If the client is Camel, the
         * returned fault flag will be set on the
         * {@link org.apache.camel.Message#setFault(boolean)} .
         * <p>
         * You may want to enable this when using Camel components that support
         * faults such as SOAP based such as cxf or spring-ws.
         */
        private Boolean transferFault = false;
        /**
         * Whether to startup the JmsConsumer message listener asynchronously,
         * when starting a route. For example if a JmsConsumer cannot get a
         * connection to a remote JMS broker, then it may block while retrying
         * and/or failover. This will cause Camel to block while starting
         * routes. By setting this option to true, you will let routes startup,
         * while the JmsConsumer connects to the JMS broker using a dedicated
         * thread in asynchronous mode. If this option is used, then beware that
         * if the connection could not be established, then an exception is
         * logged at WARN level, and the consumer will not be able to receive
         * messages; You can then restart the route to retry.
         */
        private Boolean asyncStartListener = false;
        /**
         * Whether to stop the JmsConsumer message listener asynchronously, when
         * stopping a route.
         */
        private Boolean asyncStopListener = false;
        /**
         * Specifies whether to test the connection on startup. This ensures
         * that when Camel starts that all the JMS consumers have a valid
         * connection to the JMS broker. If a connection cannot be granted then
         * Camel throws an exception on startup. This ensures that Camel is not
         * started with failed connections. The JMS producers is tested as well.
         */
        private Boolean testConnectionOnStartup = false;
        /**
         * When using mapJmsMessage=false Camel will create a new JMS message to
         * send to a new JMS destination if you touch the headers (get or set)
         * during the route. Set this option to true to force Camel to send the
         * original JMS message that was received.
         */
        private Boolean forceSendOriginalMessage = false;
        /**
         * Use this option to force disabling time to live. For example when you
         * do request/reply over JMS, then Camel will by default use the
         * requestTimeout value as time to live on the message being sent. The
         * problem is that the sender and receiver systems have to have their
         * clocks synchronized, so they are in sync. This is not always so easy
         * to archive. So you can use disableTimeToLive=true to not set a time
         * to live value on the sent message. Then the message will not expire
         * on the receiver system. See below in section About time to live for
         * more details.
         */
        private Boolean disableTimeToLive = false;
        /**
         * Allows for explicitly specifying which kind of strategy to use for
         * replyTo queues when doing request/reply over JMS. Possible values
         * are: Temporary, Shared, or Exclusive. By default Camel will use
         * temporary queues. However if replyTo has been configured, then Shared
         * is used by default. This option allows you to use exclusive queues
         * instead of shared ones. See Camel JMS documentation for more details,
         * and especially the notes about the implications if running in a
         * clustered environment, and the fact that Shared reply queues has
         * lower performance than its alternatives Temporary and Exclusive.
         */
        private ReplyToType replyToType;
        /**
         * Whether the JmsConsumer processes the Exchange asynchronously. If
         * enabled then the JmsConsumer may pickup the next message from the JMS
         * queue, while the previous message is being processed asynchronously
         * (by the Asynchronous Routing Engine). This means that messages may be
         * processed not 100% strictly in order. If disabled (as default) then
         * the Exchange is fully processed before the JmsConsumer will pickup
         * the next message from the JMS queue. Note if transacted has been
         * enabled, then asyncConsumer=true does not run asynchronously, as
         * transaction must be executed synchronously (Camel 3.0 may support
         * async transactions).
         */
        private Boolean asyncConsumer = false;
        /**
         * Sets the cache level by name for the reply consumer when doing
         * request/reply over JMS. This option only applies when using fixed
         * reply queues (not temporary). Camel will by default use:
         * CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And
         * CACHE_SESSION for shared without replyToSelectorName. Some JMS
         * brokers such as IBM WebSphere may require to set the
         * replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary
         * queues then CACHE_NONE is not allowed, and you must use a higher
         * value such as CACHE_CONSUMER or CACHE_SESSION.
         */
        private String replyToCacheLevelName;
        /**
         * Whether to allow sending messages with no body. If this option is
         * false and the message body is null, then an JMSException is thrown.
         */
        private Boolean allowNullBody = true;
        /**
         * Registry ID of the MessageListenerContainerFactory used to determine
         * what
         * org.springframework.jms.listener.AbstractMessageListenerContainer to
         * use to consume messages. Setting this will automatically set
         * consumerType to Custom.
         */
        private MessageListenerContainerFactory messageListenerContainerFactory;
        /**
         * Only applicable when sending to JMS destination using InOnly (eg fire
         * and forget). Enabling this option will enrich the Camel Exchange with
         * the actual JMSMessageID that was used by the JMS client when the
         * message was sent to the JMS destination.
         */
        private Boolean includeSentJMSMessageID = false;
        /**
         * Specifies what default TaskExecutor type to use in the
         * DefaultMessageListenerContainer, for both consumer endpoints and the
         * ReplyTo consumer of producer endpoints. Possible values: SimpleAsync
         * (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's
         * ThreadPoolTaskExecutor with optimal values - cached threadpool-like).
         * If not set, it defaults to the previous behaviour, which uses a
         * cached thread pool for consumer endpoints and SimpleAsync for reply
         * consumers. The use of ThreadPool is recommended to reduce
         * "thread trash" in elastic configurations with dynamically increasing
         * and decreasing concurrent consumers.
         */
        private DefaultTaskExecutorType defaultTaskExecutorType;
        /**
         * Whether to include all JMSXxxx properties when mapping from JMS to
         * Camel Message. Setting this to true will include properties such as
         * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom
         * headerFilterStrategy then this option does not apply.
         */
        private Boolean includeAllJMSXProperties = false;
        /**
         * To use the given MessageCreatedStrategy which are invoked when Camel
         * creates new instances of <tt>javax.jms.Message</tt> objects when
         * Camel is sending a JMS message.
         */
        private MessageCreatedStrategy messageCreatedStrategy;
        /**
         * Sets the JMS selector to use
         */
        private String selector;
        /**
         * Use this JMS property to correlate messages in InOut exchange pattern
         * (request-reply) instead of JMSCorrelationID property. This allows you
         * to exchange messages with systems that do not correlate messages
         * using JMSCorrelationID JMS property. If used JMSCorrelationID will
         * not be used or set by Camel. The value of here named property will be
         * generated if not supplied in the header of the message under the same
         * name.
         */
        private String correlationProperty;
        /**
         * This option is used to allow additional headers which may have values
         * that are invalid according to JMS specification. + For example some
         * message systems such as WMQ do this with header names using prefix
         * JMS_IBM_MQMD_ containing values with byte array or other invalid
         * types. + You can specify multiple header names separated by comma,
         * and use * as suffix for wildcard matching.
         */
        private String allowAdditionalHeaders;
        /**
         * Set whether to make the subscription durable. The durable
         * subscription name to be used can be specified through the
         * "subscriptionName" property.
         * <p>
         * Default is "false". Set this to "true" to register a durable
         * subscription, typically in combination with a "subscriptionName"
         * value (unless your message listener class name is good enough as
         * subscription name).
         * <p>
         * Only makes sense when listening to a topic (pub-sub domain),
         * therefore this method switches the "pubSubDomain" flag as well.
         */
        private Boolean subscriptionDurable = false;
        /**
         * Set whether to make the subscription shared. The shared subscription
         * name to be used can be specified through the "subscriptionName"
         * property.
         * <p>
         * Default is "false". Set this to "true" to register a shared
         * subscription, typically in combination with a "subscriptionName"
         * value (unless your message listener class name is good enough as
         * subscription name). Note that shared subscriptions may also be
         * durable, so this flag can (and often will) be combined with
         * "subscriptionDurable" as well.
         * <p>
         * Only makes sense when listening to a topic (pub-sub domain),
         * therefore this method switches the "pubSubDomain" flag as well.
         * <p>
         * <b>Requires a JMS 2.0 compatible message broker.</b>
         */
        private Boolean subscriptionShared = false;
        /**
         * Set the name of a subscription to create. To be applied in case of a
         * topic (pub-sub domain) with a shared or durable subscription.
         * <p>
         * The subscription name needs to be unique within this client's JMS
         * client id. Default is the class name of the specified message
         * listener.
         * <p>
         * Note: Only 1 concurrent consumer (which is the default of this
         * message listener container) is allowed for each subscription, except
         * for a shared subscription (which requires JMS 2.0).
         */
        private String subscriptionName;
        /**
         * Sets whether StreamMessage type is enabled or not. Message payloads
         * of streaming kind such as files, InputStream, etc will either by sent
         * as BytesMessage or StreamMessage. This option controls which kind
         * will be used. By default BytesMessage is used which enforces the
         * entire message payload to be read into memory. By enabling this
         * option the message payload is read into memory in chunks and each
         * chunk is then written to the StreamMessage until no more data.
         */
        private Boolean streamMessageTypeEnabled = false;

        public ConsumerType getConsumerType() {
            return consumerType;
        }

        public void setConsumerType(ConsumerType consumerType) {
            this.consumerType = consumerType;
        }

        public ConnectionFactory getConnectionFactory() {
            return connectionFactory;
        }

        public void setConnectionFactory(ConnectionFactory connectionFactory) {
            this.connectionFactory = connectionFactory;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public ConnectionFactory getListenerConnectionFactory() {
            return listenerConnectionFactory;
        }

        public void setListenerConnectionFactory(
                ConnectionFactory listenerConnectionFactory) {
            this.listenerConnectionFactory = listenerConnectionFactory;
        }

        public ConnectionFactory getTemplateConnectionFactory() {
            return templateConnectionFactory;
        }

        public void setTemplateConnectionFactory(
                ConnectionFactory templateConnectionFactory) {
            this.templateConnectionFactory = templateConnectionFactory;
        }

        public Boolean getAutoStartup() {
            return autoStartup;
        }

        public void setAutoStartup(Boolean autoStartup) {
            this.autoStartup = autoStartup;
        }

        public Boolean getAcceptMessagesWhileStopping() {
            return acceptMessagesWhileStopping;
        }

        public void setAcceptMessagesWhileStopping(
                Boolean acceptMessagesWhileStopping) {
            this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;
        }

        public Boolean getAllowReplyManagerQuickStop() {
            return allowReplyManagerQuickStop;
        }

        public void setAllowReplyManagerQuickStop(
                Boolean allowReplyManagerQuickStop) {
            this.allowReplyManagerQuickStop = allowReplyManagerQuickStop;
        }

        public String getClientId() {
            return clientId;
        }

        public void setClientId(String clientId) {
            this.clientId = clientId;
        }

        public String getDurableSubscriptionName() {
            return durableSubscriptionName;
        }

        public void setDurableSubscriptionName(String durableSubscriptionName) {
            this.durableSubscriptionName = durableSubscriptionName;
        }

        public ExceptionListener getExceptionListener() {
            return exceptionListener;
        }

        public void setExceptionListener(ExceptionListener exceptionListener) {
            this.exceptionListener = exceptionListener;
        }

        public ErrorHandler getErrorHandler() {
            return errorHandler;
        }

        public void setErrorHandler(ErrorHandler errorHandler) {
            this.errorHandler = errorHandler;
        }

        public LoggingLevel getErrorHandlerLoggingLevel() {
            return errorHandlerLoggingLevel;
        }

        public void setErrorHandlerLoggingLevel(
                LoggingLevel errorHandlerLoggingLevel) {
            this.errorHandlerLoggingLevel = errorHandlerLoggingLevel;
        }

        public Boolean getErrorHandlerLogStackTrace() {
            return errorHandlerLogStackTrace;
        }

        public void setErrorHandlerLogStackTrace(
                Boolean errorHandlerLogStackTrace) {
            this.errorHandlerLogStackTrace = errorHandlerLogStackTrace;
        }

        public String getAcknowledgementModeName() {
            return acknowledgementModeName;
        }

        public void setAcknowledgementModeName(String acknowledgementModeName) {
            this.acknowledgementModeName = acknowledgementModeName;
        }

        public Boolean getExposeListenerSession() {
            return exposeListenerSession;
        }

        public void setExposeListenerSession(Boolean exposeListenerSession) {
            this.exposeListenerSession = exposeListenerSession;
        }

        public TaskExecutor getTaskExecutor() {
            return taskExecutor;
        }

        public void setTaskExecutor(TaskExecutor taskExecutor) {
            this.taskExecutor = taskExecutor;
        }

        public Boolean getPubSubNoLocal() {
            return pubSubNoLocal;
        }

        public void setPubSubNoLocal(Boolean pubSubNoLocal) {
            this.pubSubNoLocal = pubSubNoLocal;
        }

        public Integer getConcurrentConsumers() {
            return concurrentConsumers;
        }

        public void setConcurrentConsumers(Integer concurrentConsumers) {
            this.concurrentConsumers = concurrentConsumers;
        }

        public Integer getReplyToConcurrentConsumers() {
            return replyToConcurrentConsumers;
        }

        public void setReplyToConcurrentConsumers(
                Integer replyToConcurrentConsumers) {
            this.replyToConcurrentConsumers = replyToConcurrentConsumers;
        }

        public Integer getMaxMessagesPerTask() {
            return maxMessagesPerTask;
        }

        public void setMaxMessagesPerTask(Integer maxMessagesPerTask) {
            this.maxMessagesPerTask = maxMessagesPerTask;
        }

        public Integer getCacheLevel() {
            return cacheLevel;
        }

        public void setCacheLevel(Integer cacheLevel) {
            this.cacheLevel = cacheLevel;
        }

        public String getCacheLevelName() {
            return cacheLevelName;
        }

        public void setCacheLevelName(String cacheLevelName) {
            this.cacheLevelName = cacheLevelName;
        }

        public Long getRecoveryInterval() {
            return recoveryInterval;
        }

        public void setRecoveryInterval(Long recoveryInterval) {
            this.recoveryInterval = recoveryInterval;
        }

        public Long getReceiveTimeout() {
            return receiveTimeout;
        }

        public void setReceiveTimeout(Long receiveTimeout) {
            this.receiveTimeout = receiveTimeout;
        }

        public PlatformTransactionManager getTransactionManager() {
            return transactionManager;
        }

        public void setTransactionManager(
                PlatformTransactionManager transactionManager) {
            this.transactionManager = transactionManager;
        }

        public String getTransactionName() {
            return transactionName;
        }

        public void setTransactionName(String transactionName) {
            this.transactionName = transactionName;
        }

        public Integer getTransactionTimeout() {
            return transactionTimeout;
        }

        public void setTransactionTimeout(Integer transactionTimeout) {
            this.transactionTimeout = transactionTimeout;
        }

        public Integer getIdleTaskExecutionLimit() {
            return idleTaskExecutionLimit;
        }

        public void setIdleTaskExecutionLimit(Integer idleTaskExecutionLimit) {
            this.idleTaskExecutionLimit = idleTaskExecutionLimit;
        }

        public Integer getIdleConsumerLimit() {
            return idleConsumerLimit;
        }

        public void setIdleConsumerLimit(Integer idleConsumerLimit) {
            this.idleConsumerLimit = idleConsumerLimit;
        }

        public Integer getWaitForProvisionCorrelationToBeUpdatedCounter() {
            return waitForProvisionCorrelationToBeUpdatedCounter;
        }

        public void setWaitForProvisionCorrelationToBeUpdatedCounter(
                Integer waitForProvisionCorrelationToBeUpdatedCounter) {
            this.waitForProvisionCorrelationToBeUpdatedCounter = waitForProvisionCorrelationToBeUpdatedCounter;
        }

        public Long getWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime() {
            return waitForProvisionCorrelationToBeUpdatedThreadSleepingTime;
        }

        public void setWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime(
                Long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime) {
            this.waitForProvisionCorrelationToBeUpdatedThreadSleepingTime = waitForProvisionCorrelationToBeUpdatedThreadSleepingTime;
        }

        public Integer getMaxConcurrentConsumers() {
            return maxConcurrentConsumers;
        }

        public void setMaxConcurrentConsumers(Integer maxConcurrentConsumers) {
            this.maxConcurrentConsumers = maxConcurrentConsumers;
        }

        public Integer getReplyToMaxConcurrentConsumers() {
            return replyToMaxConcurrentConsumers;
        }

        public void setReplyToMaxConcurrentConsumers(
                Integer replyToMaxConcurrentConsumers) {
            this.replyToMaxConcurrentConsumers = replyToMaxConcurrentConsumers;
        }

        public Integer getReplyToOnTimeoutMaxConcurrentConsumers() {
            return replyToOnTimeoutMaxConcurrentConsumers;
        }

        public void setReplyToOnTimeoutMaxConcurrentConsumers(
                Integer replyToOnTimeoutMaxConcurrentConsumers) {
            this.replyToOnTimeoutMaxConcurrentConsumers = replyToOnTimeoutMaxConcurrentConsumers;
        }

        public Boolean getDeliveryPersistent() {
            return deliveryPersistent;
        }

        public void setDeliveryPersistent(Boolean deliveryPersistent) {
            this.deliveryPersistent = deliveryPersistent;
        }

        public Integer getDeliveryMode() {
            return deliveryMode;
        }

        public void setDeliveryMode(Integer deliveryMode) {
            this.deliveryMode = deliveryMode;
        }

        public Boolean getReplyToDeliveryPersistent() {
            return replyToDeliveryPersistent;
        }

        public void setReplyToDeliveryPersistent(
                Boolean replyToDeliveryPersistent) {
            this.replyToDeliveryPersistent = replyToDeliveryPersistent;
        }

        public Long getTimeToLive() {
            return timeToLive;
        }

        public void setTimeToLive(Long timeToLive) {
            this.timeToLive = timeToLive;
        }

        public MessageConverter getMessageConverter() {
            return messageConverter;
        }

        public void setMessageConverter(MessageConverter messageConverter) {
            this.messageConverter = messageConverter;
        }

        public Boolean getMapJmsMessage() {
            return mapJmsMessage;
        }

        public void setMapJmsMessage(Boolean mapJmsMessage) {
            this.mapJmsMessage = mapJmsMessage;
        }

        public Boolean getMessageIdEnabled() {
            return messageIdEnabled;
        }

        public void setMessageIdEnabled(Boolean messageIdEnabled) {
            this.messageIdEnabled = messageIdEnabled;
        }

        public Boolean getMessageTimestampEnabled() {
            return messageTimestampEnabled;
        }

        public void setMessageTimestampEnabled(Boolean messageTimestampEnabled) {
            this.messageTimestampEnabled = messageTimestampEnabled;
        }

        public Integer getPriority() {
            return priority;
        }

        public void setPriority(Integer priority) {
            this.priority = priority;
        }

        public Integer getAcknowledgementMode() {
            return acknowledgementMode;
        }

        public void setAcknowledgementMode(Integer acknowledgementMode) {
            this.acknowledgementMode = acknowledgementMode;
        }

        public Boolean getTransacted() {
            return transacted;
        }

        public void setTransacted(Boolean transacted) {
            this.transacted = transacted;
        }

        @Deprecated
        @DeprecatedConfigurationProperty
        public Boolean getTransactedInOut() {
            return transactedInOut;
        }

        @Deprecated
        public void setTransactedInOut(Boolean transactedInOut) {
            this.transactedInOut = transactedInOut;
        }

        public Boolean getLazyCreateTransactionManager() {
            return lazyCreateTransactionManager;
        }

        public void setLazyCreateTransactionManager(
                Boolean lazyCreateTransactionManager) {
            this.lazyCreateTransactionManager = lazyCreateTransactionManager;
        }

        public Boolean getEagerLoadingOfProperties() {
            return eagerLoadingOfProperties;
        }

        public void setEagerLoadingOfProperties(Boolean eagerLoadingOfProperties) {
            this.eagerLoadingOfProperties = eagerLoadingOfProperties;
        }

        public Boolean getDisableReplyTo() {
            return disableReplyTo;
        }

        public void setDisableReplyTo(Boolean disableReplyTo) {
            this.disableReplyTo = disableReplyTo;
        }

        public Boolean getPreserveMessageQos() {
            return preserveMessageQos;
        }

        public void setPreserveMessageQos(Boolean preserveMessageQos) {
            this.preserveMessageQos = preserveMessageQos;
        }

        public JmsOperations getJmsOperations() {
            return jmsOperations;
        }

        public void setJmsOperations(JmsOperations jmsOperations) {
            this.jmsOperations = jmsOperations;
        }

        public DestinationResolver getDestinationResolver() {
            return destinationResolver;
        }

        public void setDestinationResolver(
                DestinationResolver destinationResolver) {
            this.destinationResolver = destinationResolver;
        }

        public JmsProviderMetadata getProviderMetadata() {
            return providerMetadata;
        }

        public void setProviderMetadata(JmsProviderMetadata providerMetadata) {
            this.providerMetadata = providerMetadata;
        }

        public JmsOperations getMetadataJmsOperations() {
            return metadataJmsOperations;
        }

        public void setMetadataJmsOperations(JmsOperations metadataJmsOperations) {
            this.metadataJmsOperations = metadataJmsOperations;
        }

        public Boolean getAlwaysCopyMessage() {
            return alwaysCopyMessage;
        }

        public void setAlwaysCopyMessage(Boolean alwaysCopyMessage) {
            this.alwaysCopyMessage = alwaysCopyMessage;
        }

        public Boolean getUseMessageIDAsCorrelationID() {
            return useMessageIDAsCorrelationID;
        }

        public void setUseMessageIDAsCorrelationID(
                Boolean useMessageIDAsCorrelationID) {
            this.useMessageIDAsCorrelationID = useMessageIDAsCorrelationID;
        }

        public Long getRequestTimeout() {
            return requestTimeout;
        }

        public void setRequestTimeout(Long requestTimeout) {
            this.requestTimeout = requestTimeout;
        }

        public Long getRequestTimeoutCheckerInterval() {
            return requestTimeoutCheckerInterval;
        }

        public void setRequestTimeoutCheckerInterval(
                Long requestTimeoutCheckerInterval) {
            this.requestTimeoutCheckerInterval = requestTimeoutCheckerInterval;
        }

        public String getReplyTo() {
            return replyTo;
        }

        public void setReplyTo(String replyTo) {
            this.replyTo = replyTo;
        }

        public String getReplyToDestinationSelectorName() {
            return replyToDestinationSelectorName;
        }

        public void setReplyToDestinationSelectorName(
                String replyToDestinationSelectorName) {
            this.replyToDestinationSelectorName = replyToDestinationSelectorName;
        }

        public String getReplyToOverride() {
            return replyToOverride;
        }

        public void setReplyToOverride(String replyToOverride) {
            this.replyToOverride = replyToOverride;
        }

        public Boolean getReplyToSameDestinationAllowed() {
            return replyToSameDestinationAllowed;
        }

        public void setReplyToSameDestinationAllowed(
                Boolean replyToSameDestinationAllowed) {
            this.replyToSameDestinationAllowed = replyToSameDestinationAllowed;
        }

        public JmsMessageType getJmsMessageType() {
            return jmsMessageType;
        }

        public void setJmsMessageType(JmsMessageType jmsMessageType) {
            this.jmsMessageType = jmsMessageType;
        }

        public JmsKeyFormatStrategy getJmsKeyFormatStrategy() {
            return jmsKeyFormatStrategy;
        }

        public void setJmsKeyFormatStrategy(
                JmsKeyFormatStrategy jmsKeyFormatStrategy) {
            this.jmsKeyFormatStrategy = jmsKeyFormatStrategy;
        }

        public Boolean getTransferExchange() {
            return transferExchange;
        }

        public void setTransferExchange(Boolean transferExchange) {
            this.transferExchange = transferExchange;
        }

        public Boolean getAllowSerializedHeaders() {
            return allowSerializedHeaders;
        }

        public void setAllowSerializedHeaders(Boolean allowSerializedHeaders) {
            this.allowSerializedHeaders = allowSerializedHeaders;
        }

        public Boolean getTransferException() {
            return transferException;
        }

        public void setTransferException(Boolean transferException) {
            this.transferException = transferException;
        }

        public Boolean getTransferFault() {
            return transferFault;
        }

        public void setTransferFault(Boolean transferFault) {
            this.transferFault = transferFault;
        }

        public Boolean getAsyncStartListener() {
            return asyncStartListener;
        }

        public void setAsyncStartListener(Boolean asyncStartListener) {
            this.asyncStartListener = asyncStartListener;
        }

        public Boolean getAsyncStopListener() {
            return asyncStopListener;
        }

        public void setAsyncStopListener(Boolean asyncStopListener) {
            this.asyncStopListener = asyncStopListener;
        }

        public Boolean getTestConnectionOnStartup() {
            return testConnectionOnStartup;
        }

        public void setTestConnectionOnStartup(Boolean testConnectionOnStartup) {
            this.testConnectionOnStartup = testConnectionOnStartup;
        }

        public Boolean getForceSendOriginalMessage() {
            return forceSendOriginalMessage;
        }

        public void setForceSendOriginalMessage(Boolean forceSendOriginalMessage) {
            this.forceSendOriginalMessage = forceSendOriginalMessage;
        }

        public Boolean getDisableTimeToLive() {
            return disableTimeToLive;
        }

        public void setDisableTimeToLive(Boolean disableTimeToLive) {
            this.disableTimeToLive = disableTimeToLive;
        }

        public ReplyToType getReplyToType() {
            return replyToType;
        }

        public void setReplyToType(ReplyToType replyToType) {
            this.replyToType = replyToType;
        }

        public Boolean getAsyncConsumer() {
            return asyncConsumer;
        }

        public void setAsyncConsumer(Boolean asyncConsumer) {
            this.asyncConsumer = asyncConsumer;
        }

        public String getReplyToCacheLevelName() {
            return replyToCacheLevelName;
        }

        public void setReplyToCacheLevelName(String replyToCacheLevelName) {
            this.replyToCacheLevelName = replyToCacheLevelName;
        }

        public Boolean getAllowNullBody() {
            return allowNullBody;
        }

        public void setAllowNullBody(Boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
        }

        public MessageListenerContainerFactory getMessageListenerContainerFactory() {
            return messageListenerContainerFactory;
        }

        public void setMessageListenerContainerFactory(
                MessageListenerContainerFactory messageListenerContainerFactory) {
            this.messageListenerContainerFactory = messageListenerContainerFactory;
        }

        public Boolean getIncludeSentJMSMessageID() {
            return includeSentJMSMessageID;
        }

        public void setIncludeSentJMSMessageID(Boolean includeSentJMSMessageID) {
            this.includeSentJMSMessageID = includeSentJMSMessageID;
        }

        public DefaultTaskExecutorType getDefaultTaskExecutorType() {
            return defaultTaskExecutorType;
        }

        public void setDefaultTaskExecutorType(
                DefaultTaskExecutorType defaultTaskExecutorType) {
            this.defaultTaskExecutorType = defaultTaskExecutorType;
        }

        public Boolean getIncludeAllJMSXProperties() {
            return includeAllJMSXProperties;
        }

        public void setIncludeAllJMSXProperties(Boolean includeAllJMSXProperties) {
            this.includeAllJMSXProperties = includeAllJMSXProperties;
        }

        public MessageCreatedStrategy getMessageCreatedStrategy() {
            return messageCreatedStrategy;
        }

        public void setMessageCreatedStrategy(
                MessageCreatedStrategy messageCreatedStrategy) {
            this.messageCreatedStrategy = messageCreatedStrategy;
        }

        public String getSelector() {
            return selector;
        }

        public void setSelector(String selector) {
            this.selector = selector;
        }

        public String getCorrelationProperty() {
            return correlationProperty;
        }

        public void setCorrelationProperty(String correlationProperty) {
            this.correlationProperty = correlationProperty;
        }

        public String getAllowAdditionalHeaders() {
            return allowAdditionalHeaders;
        }

        public void setAllowAdditionalHeaders(String allowAdditionalHeaders) {
            this.allowAdditionalHeaders = allowAdditionalHeaders;
        }

        public Boolean getSubscriptionDurable() {
            return subscriptionDurable;
        }

        public void setSubscriptionDurable(Boolean subscriptionDurable) {
            this.subscriptionDurable = subscriptionDurable;
        }

        public Boolean getSubscriptionShared() {
            return subscriptionShared;
        }

        public void setSubscriptionShared(Boolean subscriptionShared) {
            this.subscriptionShared = subscriptionShared;
        }

        public String getSubscriptionName() {
            return subscriptionName;
        }

        public void setSubscriptionName(String subscriptionName) {
            this.subscriptionName = subscriptionName;
        }

        public Boolean getStreamMessageTypeEnabled() {
            return streamMessageTypeEnabled;
        }

        public void setStreamMessageTypeEnabled(Boolean streamMessageTypeEnabled) {
            this.streamMessageTypeEnabled = streamMessageTypeEnabled;
        }
    }
}