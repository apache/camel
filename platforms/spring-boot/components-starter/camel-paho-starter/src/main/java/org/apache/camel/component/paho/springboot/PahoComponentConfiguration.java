/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.paho.springboot;

import java.util.Properties;
import javax.annotation.Generated;
import javax.net.SocketFactory;
import javax.net.ssl.HostnameVerifier;
import org.apache.camel.component.paho.PahoPersistence;
import org.apache.camel.spring.boot.ComponentConfigurationPropertiesCommon;
import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * Component for communicating with MQTT message brokers using Eclipse Paho MQTT
 * Client.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.SpringBootAutoConfigurationMojo")
@ConfigurationProperties(prefix = "camel.component.paho")
public class PahoComponentConfiguration
        extends
            ComponentConfigurationPropertiesCommon {

    /**
     * Whether to enable auto configuration of the paho component. This is
     * enabled by default.
     */
    private Boolean enabled;
    /**
     * To use the shared Paho configuration
     */
    private PahoConfigurationNestedConfiguration configuration;
    /**
     * To use a shared Paho client. The option is a
     * org.eclipse.paho.client.mqttv3.MqttClient type.
     */
    private String client;
    /**
     * The URL of the MQTT broker.
     */
    private String brokerUrl;
    /**
     * Whether the component should use basic property binding (Camel 2.x) or
     * the newer property binding with additional capabilities
     */
    private Boolean basicPropertyBinding = false;
    /**
     * Whether the producer should be started lazy (on the first message). By
     * starting lazy you can use this to allow CamelContext and routes to
     * startup in situations where a producer may otherwise fail during starting
     * and cause the route to fail being started. By deferring this startup to
     * be lazy then the startup failure can be handled during routing messages
     * via Camel's routing error handlers. Beware that when the first message is
     * processed then creating and starting the producer may take a little time
     * and prolong the total processing time of the processing.
     */
    private Boolean lazyStartProducer = false;
    /**
     * Allows for bridging the consumer to the Camel routing Error Handler,
     * which mean any exceptions occurred while the consumer is trying to pickup
     * incoming messages, or the likes, will now be processed as a message and
     * handled by the routing Error Handler. By default the consumer will use
     * the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that
     * will be logged at WARN or ERROR level and ignored.
     */
    private Boolean bridgeErrorHandler = false;

    public PahoConfigurationNestedConfiguration getConfiguration() {
        return configuration;
    }

    public void setConfiguration(
            PahoConfigurationNestedConfiguration configuration) {
        this.configuration = configuration;
    }

    public String getClient() {
        return client;
    }

    public void setClient(String client) {
        this.client = client;
    }

    public String getBrokerUrl() {
        return brokerUrl;
    }

    public void setBrokerUrl(String brokerUrl) {
        this.brokerUrl = brokerUrl;
    }

    public Boolean getBasicPropertyBinding() {
        return basicPropertyBinding;
    }

    public void setBasicPropertyBinding(Boolean basicPropertyBinding) {
        this.basicPropertyBinding = basicPropertyBinding;
    }

    public Boolean getLazyStartProducer() {
        return lazyStartProducer;
    }

    public void setLazyStartProducer(Boolean lazyStartProducer) {
        this.lazyStartProducer = lazyStartProducer;
    }

    public Boolean getBridgeErrorHandler() {
        return bridgeErrorHandler;
    }

    public void setBridgeErrorHandler(Boolean bridgeErrorHandler) {
        this.bridgeErrorHandler = bridgeErrorHandler;
    }

    public static class PahoConfigurationNestedConfiguration {
        public static final Class CAMEL_NESTED_CLASS = org.apache.camel.component.paho.PahoConfiguration.class;
        /**
         * MQTT client identifier. The identifier must be unique.
         */
        private String clientId;
        /**
         * The URL of the MQTT broker.
         */
        private String brokerUrl = "tcp://localhost:1883";
        /**
         * Client quality of service level (0-2).
         */
        private Integer qos = 2;
        /**
         * Retain option
         */
        private Boolean retained = false;
        /**
         * Client persistence to be used - memory or file.
         */
        private PahoPersistence persistence = PahoPersistence.MEMORY;
        /**
         * Base directory used by file persistence. Will by default use user
         * directory.
         */
        private String filePersistenceDirectory;
        /**
         * Username to be used for authentication against the MQTT broker
         */
        private String userName;
        /**
         * Password to be used for authentication against the MQTT broker
         */
        private String password;
        /**
         * Sets the keep alive interval. This value, measured in seconds,
         * defines the maximum time interval between messages sent or received.
         * It enables the client to detect if the server is no longer available,
         * without having to wait for the TCP/IP timeout. The client will ensure
         * that at least one message travels across the network within each keep
         * alive period. In the absence of a data-related message during the
         * time period, the client sends a very small ping message, which the
         * server will acknowledge. A value of 0 disables keepalive processing
         * in the client. <p> The default value is 60 seconds </p>
         */
        private Integer keepAliveInterval = 60;
        /**
         * Sets the max inflight. please increase this value in a high traffic
         * environment. <p> The default value is 10 </p>
         */
        private Integer maxInflight = 10;
        /**
         * Sets the "Last Will and Testament" (LWT) for the connection. In the
         * event that this client unexpectedly loses its connection to the
         * server, the server will publish a message to itself using the
         * supplied details. The topic to publish to The byte payload for the
         * message. The quality of service to publish the message at (0, 1 or
         * 2). Whether or not the message should be retained.
         */
        private String willTopic;
        /**
         * Sets the "Last Will and Testament" (LWT) for the connection. In the
         * event that this client unexpectedly loses its connection to the
         * server, the server will publish a message to itself using the
         * supplied details. The topic to publish to The byte payload for the
         * message. The quality of service to publish the message at (0, 1 or
         * 2). Whether or not the message should be retained.
         */
        private String willPayload;
        /**
         * Sets the "Last Will and Testament" (LWT) for the connection. In the
         * event that this client unexpectedly loses its connection to the
         * server, the server will publish a message to itself using the
         * supplied details. The topic to publish to The byte payload for the
         * message. The quality of service to publish the message at (0, 1 or
         * 2). Whether or not the message should be retained.
         */
        private Integer willQos;
        /**
         * Sets the "Last Will and Testament" (LWT) for the connection. In the
         * event that this client unexpectedly loses its connection to the
         * server, the server will publish a message to itself using the
         * supplied details. The topic to publish to The byte payload for the
         * message. The quality of service to publish the message at (0, 1 or
         * 2). Whether or not the message should be retained.
         */
        private Boolean willRetained = false;
        /**
         * Sets the SocketFactory to use. This allows an application to apply
         * its own policies around the creation of network sockets. If using an
         * SSL connection, an SSLSocketFactory can be used to supply
         * application-specific security settings.
         */
        private SocketFactory socketFactory;
        /**
         * Sets the SSL properties for the connection. <p> Note that these
         * properties are only valid if an implementation of the Java Secure
         * Socket Extensions (JSSE) is available. These properties are
         * <em>not</em> used if a custom SocketFactory has been set. The
         * following properties can be used: </p> <dl>
         * <dt>com.ibm.ssl.protocol</dt> <dd>One of: SSL, SSLv3, TLS, TLSv1,
         * SSL_TLS.</dd> <dt>com.ibm.ssl.contextProvider <dd>Underlying JSSE
         * provider. For example "IBMJSSE2" or "SunJSSE"</dd>
         * <dt>com.ibm.ssl.keyStore</dt> <dd>The name of the file that contains
         * the KeyStore object that you want the KeyManager to use. For example
         * /mydir/etc/key.p12</dd> <dt>com.ibm.ssl.keyStorePassword</dt> <dd>The
         * password for the KeyStore object that you want the KeyManager to use.
         * The password can either be in plain-text, or may be obfuscated using
         * the static method:
         * <code>com.ibm.micro.security.Password.obfuscate(char[]
         * password)</code>. This obfuscates the password using a simple and
         * insecure XOR and Base64 encoding mechanism. Note that this is only a
         * simple scrambler to obfuscate clear-text passwords.</dd>
         * <dt>com.ibm.ssl.keyStoreType</dt> <dd>Type of key store, for example
         * "PKCS12", "JKS", or "JCEKS".</dd>
         * <dt>com.ibm.ssl.keyStoreProvider</dt> <dd>Key store provider, for
         * example "IBMJCE" or "IBMJCEFIPS".</dd>
         * <dt>com.ibm.ssl.trustStore</dt> <dd>The name of the file that
         * contains the KeyStore object that you want the TrustManager to
         * use.</dd> <dt>com.ibm.ssl.trustStorePassword</dt> <dd>The password
         * for the TrustStore object that you want the TrustManager to use. The
         * password can either be in plain-text, or may be obfuscated using the
         * static method: <code>com.ibm.micro.security.Password.obfuscate(char[]
         * password)</code>. This obfuscates the password using a simple and
         * insecure XOR and Base64 encoding mechanism. Note that this is only a
         * simple scrambler to obfuscate clear-text passwords.</dd>
         * <dt>com.ibm.ssl.trustStoreType</dt> <dd>The type of KeyStore object
         * that you want the default TrustManager to use. Same possible values
         * as "keyStoreType".</dd> <dt>com.ibm.ssl.trustStoreProvider</dt>
         * <dd>Trust store provider, for example "IBMJCE" or "IBMJCEFIPS".</dd>
         * <dt>com.ibm.ssl.enabledCipherSuites</dt> <dd>A list of which ciphers
         * are enabled. Values are dependent on the provider, for example:
         * SSL_RSA_WITH_AES_128_CBC_SHA;SSL_RSA_WITH_3DES_EDE_CBC_SHA.</dd>
         * <dt>com.ibm.ssl.keyManager</dt> <dd>Sets the algorithm that will be
         * used to instantiate a KeyManagerFactory object instead of using the
         * default algorithm available in the platform. Example values:
         * "IbmX509" or "IBMJ9X509".</dd> <dt>com.ibm.ssl.trustManager</dt>
         * <dd>Sets the algorithm that will be used to instantiate a
         * TrustManagerFactory object instead of using the default algorithm
         * available in the platform. Example values: "PKIX" or
         * "IBMJ9X509".</dd> </dl>
         */
        private Properties sslClientProps;
        /**
         * Whether SSL HostnameVerifier is enabled or not. The default value is
         * true.
         */
        private Boolean httpsHostnameVerificationEnabled = true;
        /**
         * Sets the HostnameVerifier for the SSL connection. Note that it will
         * be used after handshake on a connection and you should do actions by
         * yourself when hostname is verified error. <p> There is no default
         * HostnameVerifier </p>
         */
        private HostnameVerifier sslHostnameVerifier;
        /**
         * Sets whether the client and server should remember state across
         * restarts and reconnects. <ul> <li>If set to false both the client and
         * server will maintain state across restarts of the client, the server
         * and the connection. As state is maintained: <ul> <li>Message delivery
         * will be reliable meeting the specified QOS even if the client, server
         * or connection are restarted. <li>The server will treat a subscription
         * as durable. </ul> <li>If set to true the client and server will not
         * maintain state across restarts of the client, the server or the
         * connection. This means <ul> <li>Message delivery to the specified QOS
         * cannot be maintained if the client, server or connection are
         * restarted <li>The server will treat a subscription as non-durable
         * </ul> </ul>
         */
        private Boolean cleanSession = true;
        /**
         * Sets the connection timeout value. This value, measured in seconds,
         * defines the maximum time interval the client will wait for the
         * network connection to the MQTT server to be established. The default
         * timeout is 30 seconds. A value of 0 disables timeout processing
         * meaning the client will wait until the network connection is made
         * successfully or fails.
         */
        private Integer connectionTimeout = 30;
        /**
         * Set a list of one or more serverURIs the client may connect to.
         * Multiple servers can be separated by comma. <p> Each
         * <code>serverURI</code> specifies the address of a server that the
         * client may connect to. Two types of connection are supported
         * <code>tcp://</code> for a TCP connection and <code>ssl://</code> for
         * a TCP connection secured by SSL/TLS. For example: <ul>
         * <li><code>tcp://localhost:1883</code></li>
         * <li><code>ssl://localhost:8883</code></li> </ul> If the port is not
         * specified, it will default to 1883 for <code>tcp://</code>" URIs, and
         * 8883 for <code>ssl://</code> URIs. <p> If serverURIs is set then it
         * overrides the serverURI parameter passed in on the constructor of the
         * MQTT client. <p> When an attempt to connect is initiated the client
         * will start with the first serverURI in the list and work through the
         * list until a connection is established with a server. If a connection
         * cannot be made to any of the servers then the connect attempt fails.
         * <p> Specifying a list of servers that a client may connect to has
         * several uses: <ol> <li>High Availability and reliable message
         * delivery <p> Some MQTT servers support a high availability feature
         * where two or more "equal" MQTT servers share state. An MQTT client
         * can connect to any of the "equal" servers and be assured that
         * messages are reliably delivered and durable subscriptions are
         * maintained no matter which server the client connects to. </p> <p>
         * The cleansession flag must be set to false if durable subscriptions
         * and/or reliable message delivery is required. </p> </li> <li>Hunt
         * List <p> A set of servers may be specified that are not "equal" (as
         * in the high availability option). As no state is shared across the
         * servers reliable message delivery and durable subscriptions are not
         * valid. The cleansession flag must be set to true if the hunt list
         * mode is used </p> </li> </ol>
         */
        private String serverURIs;
        /**
         * Sets the MQTT version. The default action is to connect with version
         * 3.1.1, and to fall back to 3.1 if that fails. Version 3.1.1 or 3.1
         * can be selected specifically, with no fall back, by using the
         * MQTT_VERSION_3_1_1 or MQTT_VERSION_3_1 options respectively.
         */
        private Integer mqttVersion;
        /**
         * Sets whether the client will automatically attempt to reconnect to
         * the server if the connection is lost. <ul> <li>If set to false, the
         * client will not attempt to automatically reconnect to the server in
         * the event that the connection is lost.</li> <li>If set to true, in
         * the event that the connection is lost, the client will attempt to
         * reconnect to the server. It will initially wait 1 second before it
         * attempts to reconnect, for every failed reconnect attempt, the delay
         * will double until it is at 2 minutes at which point the delay will
         * stay at 2 minutes.</li> </ul>
         */
        private Boolean automaticReconnect = true;
        /**
         * Get the maximum time (in millis) to wait between reconnects
         */
        private Integer maxReconnectDelay = 128000;
        /**
         * Sets the Custom WebSocket Headers for the WebSocket Connection.
         */
        private Properties customWebSocketHeaders;
        /**
         * Set the time in seconds that the executor service should wait when
         * terminating before forcefully terminating. It is not recommended to
         * change this value unless you are absolutely sure that you need to.
         */
        private Integer executorServiceTimeout = 1;

        public String getClientId() {
            return clientId;
        }

        public void setClientId(String clientId) {
            this.clientId = clientId;
        }

        public String getBrokerUrl() {
            return brokerUrl;
        }

        public void setBrokerUrl(String brokerUrl) {
            this.brokerUrl = brokerUrl;
        }

        public Integer getQos() {
            return qos;
        }

        public void setQos(Integer qos) {
            this.qos = qos;
        }

        public Boolean getRetained() {
            return retained;
        }

        public void setRetained(Boolean retained) {
            this.retained = retained;
        }

        public PahoPersistence getPersistence() {
            return persistence;
        }

        public void setPersistence(PahoPersistence persistence) {
            this.persistence = persistence;
        }

        public String getFilePersistenceDirectory() {
            return filePersistenceDirectory;
        }

        public void setFilePersistenceDirectory(String filePersistenceDirectory) {
            this.filePersistenceDirectory = filePersistenceDirectory;
        }

        public String getUserName() {
            return userName;
        }

        public void setUserName(String userName) {
            this.userName = userName;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public Integer getKeepAliveInterval() {
            return keepAliveInterval;
        }

        public void setKeepAliveInterval(Integer keepAliveInterval) {
            this.keepAliveInterval = keepAliveInterval;
        }

        public Integer getMaxInflight() {
            return maxInflight;
        }

        public void setMaxInflight(Integer maxInflight) {
            this.maxInflight = maxInflight;
        }

        public String getWillTopic() {
            return willTopic;
        }

        public void setWillTopic(String willTopic) {
            this.willTopic = willTopic;
        }

        public String getWillPayload() {
            return willPayload;
        }

        public void setWillPayload(String willPayload) {
            this.willPayload = willPayload;
        }

        public Integer getWillQos() {
            return willQos;
        }

        public void setWillQos(Integer willQos) {
            this.willQos = willQos;
        }

        public Boolean getWillRetained() {
            return willRetained;
        }

        public void setWillRetained(Boolean willRetained) {
            this.willRetained = willRetained;
        }

        public SocketFactory getSocketFactory() {
            return socketFactory;
        }

        public void setSocketFactory(SocketFactory socketFactory) {
            this.socketFactory = socketFactory;
        }

        public Properties getSslClientProps() {
            return sslClientProps;
        }

        public void setSslClientProps(Properties sslClientProps) {
            this.sslClientProps = sslClientProps;
        }

        public Boolean getHttpsHostnameVerificationEnabled() {
            return httpsHostnameVerificationEnabled;
        }

        public void setHttpsHostnameVerificationEnabled(
                Boolean httpsHostnameVerificationEnabled) {
            this.httpsHostnameVerificationEnabled = httpsHostnameVerificationEnabled;
        }

        public HostnameVerifier getSslHostnameVerifier() {
            return sslHostnameVerifier;
        }

        public void setSslHostnameVerifier(HostnameVerifier sslHostnameVerifier) {
            this.sslHostnameVerifier = sslHostnameVerifier;
        }

        public Boolean getCleanSession() {
            return cleanSession;
        }

        public void setCleanSession(Boolean cleanSession) {
            this.cleanSession = cleanSession;
        }

        public Integer getConnectionTimeout() {
            return connectionTimeout;
        }

        public void setConnectionTimeout(Integer connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
        }

        public String getServerURIs() {
            return serverURIs;
        }

        public void setServerURIs(String serverURIs) {
            this.serverURIs = serverURIs;
        }

        public Integer getMqttVersion() {
            return mqttVersion;
        }

        public void setMqttVersion(Integer mqttVersion) {
            this.mqttVersion = mqttVersion;
        }

        public Boolean getAutomaticReconnect() {
            return automaticReconnect;
        }

        public void setAutomaticReconnect(Boolean automaticReconnect) {
            this.automaticReconnect = automaticReconnect;
        }

        public Integer getMaxReconnectDelay() {
            return maxReconnectDelay;
        }

        public void setMaxReconnectDelay(Integer maxReconnectDelay) {
            this.maxReconnectDelay = maxReconnectDelay;
        }

        public Properties getCustomWebSocketHeaders() {
            return customWebSocketHeaders;
        }

        public void setCustomWebSocketHeaders(Properties customWebSocketHeaders) {
            this.customWebSocketHeaders = customWebSocketHeaders;
        }

        public Integer getExecutorServiceTimeout() {
            return executorServiceTimeout;
        }

        public void setExecutorServiceTimeout(Integer executorServiceTimeout) {
            this.executorServiceTimeout = executorServiceTimeout;
        }
    }
}