/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.netty4.http.springboot;

import java.util.List;
import java.util.Map;
import io.netty.channel.ChannelHandler;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.handler.ssl.SslHandler;
import io.netty.util.concurrent.EventExecutorGroup;
import org.apache.camel.LoggingLevel;
import org.apache.camel.component.netty4.ClientInitializerFactory;
import org.apache.camel.component.netty4.NettyConfiguration;
import org.apache.camel.component.netty4.NettyServerBootstrapFactory;
import org.apache.camel.component.netty4.ServerInitializerFactory;
import org.apache.camel.component.netty4.http.NettyHttpBinding;
import org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.apache.camel.util.jsse.SSLContextParameters;
import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * Netty HTTP server and client using the Netty 4.x library.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@ConfigurationProperties(prefix = "camel.component.netty4-http")
public class NettyHttpComponentConfiguration {

    /**
     * To use a custom org.apache.camel.component.netty4.http.NettyHttpBinding
     * for binding to/from Netty and Camel Message API.
     */
    private NettyHttpBinding nettyHttpBinding;
    /**
     * To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter
     * headers.
     */
    private HeaderFilterStrategy headerFilterStrategy;
    /**
     * Refers to a
     * org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration for
     * configuring secure web resources.
     */
    private NettyHttpSecurityConfiguration securityConfiguration;
    /**
     * The thread pool size for the EventExecutorGroup if its in use. The
     * default value is 16.
     */
    private Integer maximumPoolSize;
    /**
     * To use the NettyConfiguration as configuration when creating endpoints.
     * Properties of the shared configuration can also be set individually.
     */
    private NettyConfiguration configuration;
    /**
     * To use the given EventExecutorGroup
     */
    private EventExecutorGroup executorService;
    /**
     * The protocol to use which can be tcp or udp.
     */
    private String protocol;
    /**
     * The hostname. For the consumer the hostname is localhost or 0.0.0.0 For
     * the producer the hostname is the remote host to connect to
     */
    private String host;
    /**
     * The host port number
     */
    private Integer port;
    /**
     * The TCP/UDP buffer sizes to be used during outbound communication. Size
     * is bytes.
     */
    private Integer sendBufferSize;
    /**
     * The TCP/UDP buffer sizes to be used during inbound communication. Size is
     * bytes.
     */
    private Integer receiveBufferSize;
    /**
     * Configures the buffer size predictor. See details at Jetty documentation
     * and this mail thread.
     */
    private Integer receiveBufferSizePredictor;
    /**
     * When netty works on nio mode it uses default workerCount parameter from
     * Netty which is cpu_core_threads2. User can use this operation to override
     * the default workerCount from Netty
     */
    private Integer workerCount;
    /**
     * When netty works on nio mode it uses default bossCount parameter from
     * Netty which is 1. User can use this operation to override the default
     * bossCount from Netty
     */
    private Integer bossCount;
    /**
     * Setting to ensure socket is not closed due to inactivity
     */
    private Boolean keepAlive;
    /**
     * Setting to improve TCP protocol performance
     */
    private Boolean tcpNoDelay;
    /**
     * Setting to facilitate socket multiplexing
     */
    private Boolean reuseAddress;
    /**
     * Time to wait for a socket connection to be available. Value is in millis.
     */
    private Integer connectTimeout;
    /**
     * Allows to configure a backlog for netty consumer (server). Note the
     * backlog is just a best effort depending on the OS. Setting this option to
     * a value such as 200 500 or 1000 tells the TCP stack how long the accept
     * queue can be If this option is not configured then the backlog depends on
     * OS setting.
     */
    private Integer backlog;
    /**
     * Setting to specify whether SSL encryption is applied to this endpoint
     */
    private Boolean ssl;
    /**
     * When enabled and in SSL mode then the Netty consumer will enrich the
     * Camel Message with headers having information about the client
     * certificate such as subject name issuer name serial number and the valid
     * date range.
     */
    private Boolean sslClientCertHeaders;
    /**
     * Reference to a class that could be used to return an SSL Handler
     */
    private SslHandler sslHandler;
    /**
     * To configure security using SSLContextParameters
     */
    private SSLContextParameters sslContextParameters;
    /**
     * Configures whether the server needs client authentication when using SSL.
     */
    private Boolean needClientAuth;
    /**
     * Client side certificate keystore to be used for encryption. Is loaded by
     * default from classpath but you can prefix with classpath: file: or http:
     * to load the resource from different systems.
     */
    private String keyStoreResource;
    /**
     * Server side certificate keystore to be used for encryption. Is loaded by
     * default from classpath but you can prefix with classpath: file: or http:
     * to load the resource from different systems.
     */
    private String trustStoreResource;
    /**
     * Keystore format to be used for payload encryption. Defaults to JKS if not
     * set
     */
    private String keyStoreFormat;
    /**
     * Security provider to be used for payload encryption. Defaults to SunX509
     * if not set.
     */
    private String securityProvider;
    /**
     * Password setting to use in order to encrypt/decrypt payloads sent using
     * SSH
     */
    private String passphrase;
    /**
     * To use a custom ServerInitializerFactory
     */
    private ServerInitializerFactory serverInitializerFactory;
    /**
     * To use a custom NettyServerBootstrapFactory
     */
    private NettyServerBootstrapFactory nettyServerBootstrapFactory;
    /**
     * Allows to use a timeout for the Netty producer when calling a remote
     * server. By default no timeout is in use. The value is in milli seconds so
     * eg 30000 is 30 seconds. The requestTimeout is using Netty's
     * ReadTimeoutHandler to trigger the timeout.
     */
    private long requestTimeout;
    /**
     * Setting to set endpoint as one-way or request-response
     */
    private Boolean sync;
    /**
     * Allows to configure additional netty options using option. as prefix. For
     * example option.child.keepAlive=false to set the netty option
     * child.keepAlive=false. See the Netty documentation for possible options
     * that can be used.
     */
    private Map<String, Object> options;
    /**
     * Whether to use native transport instead of NIO. Native transport takes
     * advantage of the host operating system and is only supported on some
     * platforms. You need to add the netty JAR for the host operating system
     * you are using. See more details at:
     * http://netty.io/wiki/native-transports.html
     */
    private Boolean nativeTransport;
    /**
     * Set the BossGroup which could be used for handling the new connection of
     * the server side across the NettyEndpoint
     */
    private EventLoopGroup bossGroup;
    /**
     * To use a explicit EventLoopGroup as the boss thread pool. For example to
     * share a thread pool with multiple consumers. By default each consumer has
     * their own boss pool with 1 core thread.
     */
    private EventLoopGroup workerGroup;
    /**
     * To use a explicit ChannelGroup.
     */
    private ChannelGroup channelGroup;
    /**
     * A list of decoders to be used. You can use a String which have values
     * separated by comma and have the values be looked up in the Registry. Just
     * remember to prefix the value with so Camel knows it should lookup.
     */
    private List<ChannelHandler> decoders;
    /**
     * Which protocols to enable when using SSL
     */
    private String enabledProtocols;
    /**
     * A list of encoders to be used. You can use a String which have values
     * separated by comma and have the values be looked up in the Registry. Just
     * remember to prefix the value with so Camel knows it should lookup.
     */
    private List<ChannelHandler> encoders;
    /**
     * A custom ChannelHandler class that can be used to perform special
     * marshalling of outbound payloads.
     */
    private ChannelHandler encoder;
    /**
     * A custom ChannelHandler class that can be used to perform special
     * marshalling of inbound payloads.
     */
    private ChannelHandler decoder;
    /**
     * Whether or not to disconnect(close) from Netty Channel right after use.
     * Can be used for both consumer and producer.
     */
    private Boolean disconnect;
    /**
     * Channels can be lazily created to avoid exceptions if the remote server
     * is not up and running when the Camel producer is started.
     */
    private Boolean lazyChannelCreation;
    /**
     * Only used for TCP. You can transfer the exchange over the wire instead of
     * just the body. The following fields are transferred: In body Out body
     * fault body In headers Out headers fault headers exchange properties
     * exchange exception. This requires that the objects are serializable.
     * Camel will exclude any non-serializable objects and log it at WARN level.
     */
    private Boolean transferExchange;
    /**
     * If sync is enabled then this option dictates NettyConsumer if it should
     * disconnect where there is no reply to send back.
     */
    private Boolean disconnectOnNoReply;
    /**
     * If sync is enabled this option dictates NettyConsumer which logging level
     * to use when logging a there is no reply to send back.
     */
    private LoggingLevel noReplyLogLevel;
    /**
     * If the server (NettyConsumer) catches an exception then its logged using
     * this logging level.
     */
    private LoggingLevel serverExceptionCaughtLogLevel;
    /**
     * If the server (NettyConsumer) catches an
     * java.nio.channels.ClosedChannelException then its logged using this
     * logging level. This is used to avoid logging the closed channel
     * exceptions as clients can disconnect abruptly and then cause a flood of
     * closed exceptions in the Netty server.
     */
    private LoggingLevel serverClosedChannelExceptionCaughtLogLevel;
    /**
     * To use a custom ClientInitializerFactory
     */
    private ClientInitializerFactory clientInitializerFactory;
    /**
     * Whether to use ordered thread pool to ensure events are processed orderly
     * on the same channel.
     */
    private Boolean usingExecutorService;
    /**
     * Sets the cap on the number of objects that can be allocated by the pool
     * (checked out to clients or idle awaiting checkout) at a given time. Use a
     * negative value for no limit.
     */
    private Integer producerPoolMaxActive;
    /**
     * Sets the minimum number of instances allowed in the producer pool before
     * the evictor thread (if active) spawns new objects.
     */
    private Integer producerPoolMinIdle;
    /**
     * Sets the cap on the number of idle instances in the pool.
     */
    private Integer producerPoolMaxIdle;
    /**
     * Sets the minimum amount of time (value in millis) an object may sit idle
     * in the pool before it is eligible for eviction by the idle object
     * evictor.
     */
    private long producerPoolMinEvictableIdle;
    /**
     * Whether producer pool is enabled or not. Important: Do not turn this off
     * as the pooling is needed for handling concurrency and reliable
     * request/reply.
     */
    private Boolean producerPoolEnabled;
    /**
     * This option allows producers to reuse the same Netty Channel for the
     * lifecycle of processing the Exchange. This is useable if you need to call
     * a server multiple times in a Camel route and want to use the same network
     * connection. When using this the channel is not returned to the connection
     * pool until the Exchange is done; or disconnected if the disconnect option
     * is set to true. The reused Channel is stored on the Exchange as an
     * exchange property with the key link NettyConstantsNETTY_CHANNEL which
     * allows you to obtain the channel during routing and use it as well.
     */
    private Boolean reuseChannel;

    public NettyHttpBinding getNettyHttpBinding() {
        return nettyHttpBinding;
    }

    public void setNettyHttpBinding(NettyHttpBinding nettyHttpBinding) {
        this.nettyHttpBinding = nettyHttpBinding;
    }

    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }

    public void setHeaderFilterStrategy(
            HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }

    public NettyHttpSecurityConfiguration getSecurityConfiguration() {
        return securityConfiguration;
    }

    public void setSecurityConfiguration(
            NettyHttpSecurityConfiguration securityConfiguration) {
        this.securityConfiguration = securityConfiguration;
    }

    public Integer getMaximumPoolSize() {
        return maximumPoolSize;
    }

    public void setMaximumPoolSize(Integer maximumPoolSize) {
        this.maximumPoolSize = maximumPoolSize;
    }

    public NettyConfiguration getConfiguration() {
        return configuration;
    }

    public void setConfiguration(NettyConfiguration configuration) {
        this.configuration = configuration;
    }

    public EventExecutorGroup getExecutorService() {
        return executorService;
    }

    public void setExecutorService(EventExecutorGroup executorService) {
        this.executorService = executorService;
    }

    public String getProtocol() {
        return protocol;
    }

    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }

    public String getHost() {
        return host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public Integer getPort() {
        return port;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getSendBufferSize() {
        return sendBufferSize;
    }

    public void setSendBufferSize(Integer sendBufferSize) {
        this.sendBufferSize = sendBufferSize;
    }

    public Integer getReceiveBufferSize() {
        return receiveBufferSize;
    }

    public void setReceiveBufferSize(Integer receiveBufferSize) {
        this.receiveBufferSize = receiveBufferSize;
    }

    public Integer getReceiveBufferSizePredictor() {
        return receiveBufferSizePredictor;
    }

    public void setReceiveBufferSizePredictor(Integer receiveBufferSizePredictor) {
        this.receiveBufferSizePredictor = receiveBufferSizePredictor;
    }

    public Integer getWorkerCount() {
        return workerCount;
    }

    public void setWorkerCount(Integer workerCount) {
        this.workerCount = workerCount;
    }

    public Integer getBossCount() {
        return bossCount;
    }

    public void setBossCount(Integer bossCount) {
        this.bossCount = bossCount;
    }

    public Boolean getKeepAlive() {
        return keepAlive;
    }

    public void setKeepAlive(Boolean keepAlive) {
        this.keepAlive = keepAlive;
    }

    public Boolean getTcpNoDelay() {
        return tcpNoDelay;
    }

    public void setTcpNoDelay(Boolean tcpNoDelay) {
        this.tcpNoDelay = tcpNoDelay;
    }

    public Boolean getReuseAddress() {
        return reuseAddress;
    }

    public void setReuseAddress(Boolean reuseAddress) {
        this.reuseAddress = reuseAddress;
    }

    public Integer getConnectTimeout() {
        return connectTimeout;
    }

    public void setConnectTimeout(Integer connectTimeout) {
        this.connectTimeout = connectTimeout;
    }

    public Integer getBacklog() {
        return backlog;
    }

    public void setBacklog(Integer backlog) {
        this.backlog = backlog;
    }

    public Boolean getSsl() {
        return ssl;
    }

    public void setSsl(Boolean ssl) {
        this.ssl = ssl;
    }

    public Boolean getSslClientCertHeaders() {
        return sslClientCertHeaders;
    }

    public void setSslClientCertHeaders(Boolean sslClientCertHeaders) {
        this.sslClientCertHeaders = sslClientCertHeaders;
    }

    public SslHandler getSslHandler() {
        return sslHandler;
    }

    public void setSslHandler(SslHandler sslHandler) {
        this.sslHandler = sslHandler;
    }

    public SSLContextParameters getSslContextParameters() {
        return sslContextParameters;
    }

    public void setSslContextParameters(
            SSLContextParameters sslContextParameters) {
        this.sslContextParameters = sslContextParameters;
    }

    public Boolean getNeedClientAuth() {
        return needClientAuth;
    }

    public void setNeedClientAuth(Boolean needClientAuth) {
        this.needClientAuth = needClientAuth;
    }

    public String getKeyStoreResource() {
        return keyStoreResource;
    }

    public void setKeyStoreResource(String keyStoreResource) {
        this.keyStoreResource = keyStoreResource;
    }

    public String getTrustStoreResource() {
        return trustStoreResource;
    }

    public void setTrustStoreResource(String trustStoreResource) {
        this.trustStoreResource = trustStoreResource;
    }

    public String getKeyStoreFormat() {
        return keyStoreFormat;
    }

    public void setKeyStoreFormat(String keyStoreFormat) {
        this.keyStoreFormat = keyStoreFormat;
    }

    public String getSecurityProvider() {
        return securityProvider;
    }

    public void setSecurityProvider(String securityProvider) {
        this.securityProvider = securityProvider;
    }

    public String getPassphrase() {
        return passphrase;
    }

    public void setPassphrase(String passphrase) {
        this.passphrase = passphrase;
    }

    public ServerInitializerFactory getServerInitializerFactory() {
        return serverInitializerFactory;
    }

    public void setServerInitializerFactory(
            ServerInitializerFactory serverInitializerFactory) {
        this.serverInitializerFactory = serverInitializerFactory;
    }

    public NettyServerBootstrapFactory getNettyServerBootstrapFactory() {
        return nettyServerBootstrapFactory;
    }

    public void setNettyServerBootstrapFactory(
            NettyServerBootstrapFactory nettyServerBootstrapFactory) {
        this.nettyServerBootstrapFactory = nettyServerBootstrapFactory;
    }

    public long getRequestTimeout() {
        return requestTimeout;
    }

    public void setRequestTimeout(long requestTimeout) {
        this.requestTimeout = requestTimeout;
    }

    public Boolean getSync() {
        return sync;
    }

    public void setSync(Boolean sync) {
        this.sync = sync;
    }

    public Map<String, Object> getOptions() {
        return options;
    }

    public void setOptions(Map<String, Object> options) {
        this.options = options;
    }

    public Boolean getNativeTransport() {
        return nativeTransport;
    }

    public void setNativeTransport(Boolean nativeTransport) {
        this.nativeTransport = nativeTransport;
    }

    public EventLoopGroup getBossGroup() {
        return bossGroup;
    }

    public void setBossGroup(EventLoopGroup bossGroup) {
        this.bossGroup = bossGroup;
    }

    public EventLoopGroup getWorkerGroup() {
        return workerGroup;
    }

    public void setWorkerGroup(EventLoopGroup workerGroup) {
        this.workerGroup = workerGroup;
    }

    public ChannelGroup getChannelGroup() {
        return channelGroup;
    }

    public void setChannelGroup(ChannelGroup channelGroup) {
        this.channelGroup = channelGroup;
    }

    public List<ChannelHandler> getDecoders() {
        return decoders;
    }

    public void setDecoders(List<ChannelHandler> decoders) {
        this.decoders = decoders;
    }

    public String getEnabledProtocols() {
        return enabledProtocols;
    }

    public void setEnabledProtocols(String enabledProtocols) {
        this.enabledProtocols = enabledProtocols;
    }

    public List<ChannelHandler> getEncoders() {
        return encoders;
    }

    public void setEncoders(List<ChannelHandler> encoders) {
        this.encoders = encoders;
    }

    public ChannelHandler getEncoder() {
        return encoder;
    }

    public void setEncoder(ChannelHandler encoder) {
        this.encoder = encoder;
    }

    public ChannelHandler getDecoder() {
        return decoder;
    }

    public void setDecoder(ChannelHandler decoder) {
        this.decoder = decoder;
    }

    public Boolean getDisconnect() {
        return disconnect;
    }

    public void setDisconnect(Boolean disconnect) {
        this.disconnect = disconnect;
    }

    public Boolean getLazyChannelCreation() {
        return lazyChannelCreation;
    }

    public void setLazyChannelCreation(Boolean lazyChannelCreation) {
        this.lazyChannelCreation = lazyChannelCreation;
    }

    public Boolean getTransferExchange() {
        return transferExchange;
    }

    public void setTransferExchange(Boolean transferExchange) {
        this.transferExchange = transferExchange;
    }

    public Boolean getDisconnectOnNoReply() {
        return disconnectOnNoReply;
    }

    public void setDisconnectOnNoReply(Boolean disconnectOnNoReply) {
        this.disconnectOnNoReply = disconnectOnNoReply;
    }

    public LoggingLevel getNoReplyLogLevel() {
        return noReplyLogLevel;
    }

    public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {
        this.noReplyLogLevel = noReplyLogLevel;
    }

    public LoggingLevel getServerExceptionCaughtLogLevel() {
        return serverExceptionCaughtLogLevel;
    }

    public void setServerExceptionCaughtLogLevel(
            LoggingLevel serverExceptionCaughtLogLevel) {
        this.serverExceptionCaughtLogLevel = serverExceptionCaughtLogLevel;
    }

    public LoggingLevel getServerClosedChannelExceptionCaughtLogLevel() {
        return serverClosedChannelExceptionCaughtLogLevel;
    }

    public void setServerClosedChannelExceptionCaughtLogLevel(
            LoggingLevel serverClosedChannelExceptionCaughtLogLevel) {
        this.serverClosedChannelExceptionCaughtLogLevel = serverClosedChannelExceptionCaughtLogLevel;
    }

    public ClientInitializerFactory getClientInitializerFactory() {
        return clientInitializerFactory;
    }

    public void setClientInitializerFactory(
            ClientInitializerFactory clientInitializerFactory) {
        this.clientInitializerFactory = clientInitializerFactory;
    }

    public Boolean getUsingExecutorService() {
        return usingExecutorService;
    }

    public void setUsingExecutorService(Boolean usingExecutorService) {
        this.usingExecutorService = usingExecutorService;
    }

    public Integer getProducerPoolMaxActive() {
        return producerPoolMaxActive;
    }

    public void setProducerPoolMaxActive(Integer producerPoolMaxActive) {
        this.producerPoolMaxActive = producerPoolMaxActive;
    }

    public Integer getProducerPoolMinIdle() {
        return producerPoolMinIdle;
    }

    public void setProducerPoolMinIdle(Integer producerPoolMinIdle) {
        this.producerPoolMinIdle = producerPoolMinIdle;
    }

    public Integer getProducerPoolMaxIdle() {
        return producerPoolMaxIdle;
    }

    public void setProducerPoolMaxIdle(Integer producerPoolMaxIdle) {
        this.producerPoolMaxIdle = producerPoolMaxIdle;
    }

    public long getProducerPoolMinEvictableIdle() {
        return producerPoolMinEvictableIdle;
    }

    public void setProducerPoolMinEvictableIdle(
            long producerPoolMinEvictableIdle) {
        this.producerPoolMinEvictableIdle = producerPoolMinEvictableIdle;
    }

    public Boolean getProducerPoolEnabled() {
        return producerPoolEnabled;
    }

    public void setProducerPoolEnabled(Boolean producerPoolEnabled) {
        this.producerPoolEnabled = producerPoolEnabled;
    }

    public Boolean getReuseChannel() {
        return reuseChannel;
    }

    public void setReuseChannel(Boolean reuseChannel) {
        this.reuseChannel = reuseChannel;
    }
}