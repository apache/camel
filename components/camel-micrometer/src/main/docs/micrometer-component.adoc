[[micrometer-component]]
== Micrometer Component
ifdef::env-github[]
*Available as of Camel version 2.22.0*

:caution-caption: :boom:
:important-caption: :exclamation:
:note-caption: :information_source:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

### Micrometer Component

The **micrometer:** component allows to collect various metrics directly
from Camel routes. Supported metric types
are link:#MicrometerComponent-counter[counter], link:#MicrometerComponent-distributionSummary[summary],
and link:#MicrometerComponent-timer[timer]. http://micrometer.io/[Micrometer] provides
simple way to measure behaviour of application. Configurable
reporting backends (via Micrometer registries) is enabling different integration options for
collecting and visualizing statistics. The component also provides
a `MicrometerRoutePolicyFactory` which allows to expose route statistics
using Micrometer, see bottom of page for details.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-micrometer</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

### URI format

[source]
----
micrometer:[ counter | summary | timer ]:metricname[?options]
----

### Options

// component options: START
The Micrometer component supports the following options:



[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *metricRegistry* (advanced) | To use a custom configured MetricRegistry. |  | MeterRegistry
| *resolveProperty Placeholders* (advanced) | Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders. | true | boolean
|===
// component options: END


// endpoint options: START
The Metrics endpoint is configured using URI syntax:

----
micrometer:metricsType:meterName
----

with the following path and query parameters:

==== Path Parameters:


[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *metricsType* | *Required* Type of metrics |  | MetricsType
| *meterName* | *Required* Name of metrics |  | String
|===


==== Query Parameters:


[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *tags* (producer) | Tags that accompany the metric. Comma-separated list of key=value pairs |  | String
| *action* (producer) | Action when using timer type |  | MetricsTimerAction
| *decrement* (producer) | Decrement value when using counter type |  | Long
| *increment* (producer) | Increment value when using counter type |  | Long
| *value* (producer) | Value value when using histogram type |  | Long
| *synchronous* (advanced) | Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported). | false | boolean
|===
// endpoint options: END



### [[MicrometerComponent-registry]]Meter Registry

The Camel Micrometer component uses by default a `SimpleMeterRegistry` instance.
This default registry should be replaced with a custom one by providing
a `MeterRegistry` bean. MeterRegistries primarily determine the backend monitoring system
in use. A CompositeMeterRegistry can be used to address more than one monitoring target.

For example using Spring Java Configuration:

[source,java]
----
@Configuration
public static class MyConfig extends SingleRouteCamelConfiguration {

    @Bean
    @Override
    public RouteBuilder route() {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                // define Camel routes here
            }
        };
    }

    @Bean(name = MicrometerComponent.METRICS_REGISTRY_NAME)
    public MeterRegistry getMeterRegistry() {
        MeterRegistry registry = ...;
        return registry;
    }
}
----

Or using CDI:
[source,java]
----
class MyBean extends RouteBuilder {

    @Override
    public void configure() {
      from("...")
          // Register the 'my-meter' meter in the MetricRegistry below
          .to("metrics:meter:my-meter");
    }

    @Produces
    // If multiple MetricRegistry beans
    // @Named(MicrometerComponent.METRIC_REGISTRY_NAME)
    MetricRegistry registry() {
        MeterRegistry registry = ...;
        // ...
        return registry;
    }
}
----


### Usage

Each metric has type and name. Supported types are
link:#MicrometerComponent-counter[counter],
link:#MicrometerComponent-summary[histogram] and
link:#MetricsComponent-timer[timer].
Metric name is simple string. If metric type is not provided then a counter is used by default.

#### Headers

The Metric name defined in URI can be overridden by using header with name
`CamelMetricsName`.
The Metric tags defined as URI parameters can be overridden by using header with name `CamelMetricsTags`.

For example

[source,java]
----
from("direct:in")
    .setHeader(MicrometerConstants.HEADER_METRIC_NAME, constant("new.name"))
    .setHeader(MicrometerConstants.HEADER_METRIC_TAGS, constant(Tags.of("otherKey", "otherValue")))
    .to("metrics:counter:name.not.used?tags=key=value")
    .to("direct:out");
----

will update a counter with name `new.name` instead of `name.not.used` using the
tag `otherKey` with value `otherValue` instead of the tag `key` with value `value`.

All Metrics specific headers are removed from the message once the Micrometer
endpoint finishes processing of exchange. While processing exchange
Micrometer endpoint will catch all exceptions and write log entry using
level `warn`.

### [[MicrometerComponent-counter]]Counter

[source]
----
micrometer:counter:name[?options]
----

#### Options

[width="100%",cols="10%,10%,80%",options="header",]
|=====================================================
|Name |Default |Description
|increment  |- |Double value to add to the counter
|decrement |- |Double value to subtract from the counter
|=====================================================

If neither `increment` or `decrement` is defined then counter value will
be incremented by one. If `increment` and `decrement` are both defined
only increment operation is called. 

[source,java]
----
// update counter simple.counter by 7
from("direct:in")
    .to("micrometer:counter:simple.counter?increment=7")
    .to("direct:out");
----

[source,java]
----
// increment counter simple.counter by 1
from("direct:in")
    .to("micrometer:counter:simple.counter")
    .to("direct:out");
----

[source,java]
----
// decrement counter simple.counter by 3
from("direct:in")
    .to("micrometer:counter:simple.counter?decrement=3")
    .to("direct:out");
----

#### Headers

Message headers can be used to override `increment` and `decrement`
values specified in Metrics component URI.

[width="100%",cols="10%,80%,10%",options="header",]
|====================================================================
|Name |Description |Expected type
|CamelMetricsCounterIncrement  |Override increment value in URI |Double
|CamelMetricsCounterDecrement  |Override decrement value in URI |Double
|====================================================================

[source,java]
----
// update counter simple.counter by 417
from("direct:in")
    .setHeader(MicrometerConstants.HEADER_COUNTER_INCREMENT, constant(417.0D))
    .to("micrometer:counter:simple.counter?increment=7")
    .to("direct:out");
----

[source,java]
----
// updates counter using simple language to evaluate body.length
from("direct:in")
    .setHeader(MicrometerConstants.HEADER_COUNTER_INCREMENT, simple("${body.length}"))
    .to("micrometer:counter:body.length")
    .to("direct:out");

----

### [[MicrometerComponent-summary]]Histogram

[source]
----
micrometer:summary:metricname[?options]
----

#### Options

[width="100%",cols="10%,10%,80%",options="header",]
|===================================
|Name |Default |Description
|value |- |Value to use in histogram
|===================================

If no `value` is not set nothing is added to histogram and warning is
logged.

[source,java]
----
// adds value 9923 to simple.histogram
from("direct:in")
    .to("micrometer:summary:simple.histogram?value=9923")
    .to("direct:out");
----

[source,java]
----
// nothing is added to simple.histogram; warning is logged
from("direct:in")
    .to("micrometer:summary:simple.histogram")
    .to("direct:out");

----

#### Headers

Message header can be used to override value specified in Metrics
component URI.

[width="100%",cols="10%,80%,10%",options="header",]
|=================================================================
|Name |Description |Expected type
|CamelMetricsHistogramValue |Override histogram value in URI |Long
|=================================================================

[source,java]
----
// adds value 992 to simple.histogram
from("direct:in")
    .setHeader(MicrometerConstants.HEADER_HISTOGRAM_VALUE, constant(992L))
    .to("micrometer:summary:simple.histogram?value=700")
    .to("direct:out")

----


### [[MicrometerComponent-timer]]Timer

[source]
----
micrometer:timer:metricname[?options]
----

#### Options

[width="100%",cols="10%,10%,80%",options="header",]
|==========================
|Name |Default |Description
|action |- |start or stop
|==========================

If no `action` or invalid value is provided then warning is logged
without any timer update. If action `start` is called on already running
timer or `stop` is called on not running timer then nothing is updated
and warning is logged.

[source,java]
----
// measure time taken by route "calculate"
from("direct:in")
    .to("micrometer:timer:simple.timer?action=start")
    .to("direct:calculate")
    .to("micrometer:timer:simple.timer?action=stop");
----

`Timer.Sample` objects are stored as Exchange properties between
different Metrics component calls.

#### Headers

Message header can be used to override action value specified in Metrics
component URI.

[width="100%",cols="10%,80%,10%",options="header",]
|=======================================================================
|Name |Description |Expected type
|CamelMetricsTimerAction |Override timer action in URI
|`org.apache.camel.component.micrometer.timer.TimerEndpoint.TimerAction`
|=======================================================================

[source,java]
----
// sets timer action using header
from("direct:in")
    .setHeader(MicrometerConstants.HEADER_TIMER_ACTION, TimerAction.start)
    .to("micrometer:timer:simple.timer")
    .to("direct:out");
----


### MicrometerRoutePolicyFactory

This factory allows to add a RoutePolicy for each
route which exposes route utilization statistics using Micrometer.
This factory can be used in Java and XML as the examples below
demonstrates. 

NOTE: Instead of using the MicrometerRoutePolicyFactory you can define a
MicrometerRoutePolicy per route you want to instrument, in case you only
want to instrument a few selected routes.

From Java you just add the factory to the `CamelContext` as shown below:

[source,java]
----
context.addRoutePolicyFactory(new MicrometerRoutePolicyFactory());
----

And from XML DSL you define a <bean> as follows:

[source,xml]
----
  <!-- use camel-metrics route policy to gather metrics for all routes -->
  <bean id="metricsRoutePolicyFactory" class="org.apache.camel.component.micrometer.routepolicy.MicrometerRoutePolicyFactory"/>
----

The `MicrometerRoutePolicyFactory` and `MicrometerRoutePolicy` supports the
following options:

[width="100%",cols="10%,10%,80%",options="header",]
|=======================================================================
|Name |Default |Description
|prettyPrint |false |Whether to use pretty print when outputting
statistics in json format
|meterRegistry |  |Allow to use a shared `MeterRegistry`. If none is provided then Camel
will create a shared instance used by the this CamelContext.
|durationUnit |TimeUnit.MILLISECONDS |The unit to use for duration in when dumping the statistics as json.
|prefix|CamelMetrics|Common prefix for metric names
|namePattern |`##prefix##.##name##.##routeId##.##type##` |The name
pattern to use. Uses dot as separators, but you can change that. The
values `##prefix##`, `##name##`, `##routeId##`, and `##type##` will be replaced with actual
value, where `##prefix##` is a common metrics name prefix,`###name###` is the name of the
CamelContext. `###routeId###` is the name of the route and `###type###` is the value of responses.
|=======================================================================


### MicrometerMessageHistoryFactory


This factory allows to use metrics to
capture Message History performance
statistics while routing messages. It works by using a metrics Timer for
each node in all the routes. This factory can be used in Java and XML as
the examples below demonstrates. 

From Java you just set the factory to the `CamelContext` as shown below:

[source,java]
----
context.setMessageHistoryFactory(new MicrometerMessageHistoryFactory());
----

And from XML DSL you define a <bean> as follows:

[source,xml]
----
  <!-- use camel-metrics message history to gather metrics for all messages being routed -->
  <bean id="metricsMessageHistoryFactory" class="org.apache.camel.component.micrometer.messagehistory.MicrometerMessageHistoryFactory"/>
----

The following options is supported on the factory:

[width="100%",cols="10%,10%,80%",options="header",]
|=======================================================================
|Name |Default |Description
|prettyPrint |false |Whether to use pretty print when outputting
statistics in json format
|meterRegistry |  |Allow to use a shared
`MeterRegistry`. If none is provided then Camel
will create a shared instance used by the this CamelContext.
|durationUnit |TimeUnit.MILLISECONDS |The unit to use for duration when dumping the statistics as json.
|prefix|CamelMetrics|Common prefix for metric names
|namePattern |`##prefix##.##name##.##routeId##.##id##.##type##` |The name pattern
to use. Uses dot as separators, but you can change that. The values
`##name##`, `##routeId##`, `##type##`, and `###id###` will be replaced with
actual value, where `###name###` is the name of the CamelContext,
`###routeId###` is the name of the route, the `###id###` pattern represents
the node id and `###type###` is the value of history.
|=======================================================================

At runtime the metrics can be accessed from Java API or JMX which allows
to gather the data as json output.

From Java code you can do get the service from the CamelContext as
shown:

[source,java]
----
MicrometerMessageHistoryService service = context.hasService(MicrometerMessageHistoryService.class);
String json = service.dumpStatisticsAsJson();
----

And the JMX API the MBean is registered in the `type=services` tree
with `name=MicrometerMessageHistoryService`.

### InstrumentedThreadPoolFactory

This factory allows you to gather performance information about Camel Thread Pools by injecting a InstrumentedThreadPoolFactory
which collects information from inside of Camel.
See more details at Advanced configuration of CamelContext using Spring


### See Also

* The `camel-example-cdi-metrics` example that illustrates the integration
  between Camel, Metrics and CDI.
