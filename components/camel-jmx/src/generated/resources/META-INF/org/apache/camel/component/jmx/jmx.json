{
  "component": {
    "kind": "component",
    "name": "jmx",
    "title": "JMX",
    "description": "Receive JMX notifications.",
    "deprecated": false,
    "firstVersion": "2.6.0",
    "label": "monitoring",
    "javaType": "org.apache.camel.component.jmx.JMXComponent",
    "supportLevel": "Stable",
    "groupId": "org.apache.camel",
    "artifactId": "camel-jmx",
    "version": "4.5.0-SNAPSHOT",
    "scheme": "jmx",
    "extendsScheme": "",
    "syntax": "jmx:serverURL",
    "async": false,
    "api": false,
    "consumerOnly": true,
    "producerOnly": false,
    "lenientProperties": false,
    "remote": false
  },
  "componentProperties": {
    "bridgeErrorHandler": { "index": 0, "kind": "property", "displayName": "Bridge Error Handler", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
    "autowiredEnabled": { "index": 1, "kind": "property", "displayName": "Autowired Enabled", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc." }
  },
  "headers": {
    "jmx.handback": { "index": 0, "kind": "header", "displayName": "", "group": "consumer", "label": "consumer", "required": false, "javaType": "Object", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The handback.", "constantName": "org.apache.camel.component.jmx.JMXConstants#JMX_HANDBACK" }
  },
  "properties": {
    "serverURL": { "index": 0, "kind": "path", "displayName": "Server URL", "group": "consumer", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Server url comes from the remaining endpoint. Use platform to connect to local JVM." },
    "format": { "index": 1, "kind": "parameter", "displayName": "Format", "group": "consumer", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "enum": [ "xml", "raw" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "xml", "description": "Format for the message body. Either xml or raw. If xml, the notification is serialized to xml. If raw, then the raw java object is set as the body." },
    "granularityPeriod": { "index": 2, "kind": "parameter", "displayName": "Granularity Period", "group": "consumer", "label": "", "required": false, "type": "duration", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "10000", "description": "The frequency to poll the bean to check the monitor (monitor types only)." },
    "monitorType": { "index": 3, "kind": "parameter", "displayName": "Monitor Type", "group": "consumer", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "enum": [ "counter", "gauge", "string" ], "deprecated": false, "autowired": false, "secret": false, "description": "The type of monitor to create. One of string, gauge, counter (monitor types only)." },
    "objectDomain": { "index": 4, "kind": "parameter", "displayName": "Object Domain", "group": "consumer", "label": "", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The domain for the mbean you're connecting to" },
    "objectName": { "index": 5, "kind": "parameter", "displayName": "Object Name", "group": "consumer", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The name key for the mbean you're connecting to. This value is mutually exclusive with the object properties that get passed." },
    "observedAttribute": { "index": 6, "kind": "parameter", "displayName": "Observed Attribute", "group": "consumer", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The attribute to observe for the monitor bean or consumer." },
    "bridgeErrorHandler": { "index": 7, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
    "exceptionHandler": { "index": 8, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
    "exchangePattern": { "index": 9, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
    "executorService": { "index": 10, "kind": "parameter", "displayName": "Executor Service", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.concurrent.ExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom shared thread pool for the consumers. By default each consume has their own thread-pool to process and route notifications." },
    "handback": { "index": 11, "kind": "parameter", "displayName": "Handback", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "description": "Value to handback to the listener when a notification is received. This value will be put in the message header with the key JMXConstants#JMX_HANDBACK." },
    "notificationFilter": { "index": 12, "kind": "parameter", "displayName": "Notification Filter", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "javax.management.NotificationFilter", "deprecated": false, "autowired": false, "secret": false, "description": "Reference to a bean that implements the NotificationFilter." },
    "objectProperties": { "index": 13, "kind": "parameter", "displayName": "Object Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.String>", "prefix": "key.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "Properties for the object name. These values will be used if the objectName param is not set" },
    "reconnectDelay": { "index": 14, "kind": "parameter", "displayName": "Reconnect Delay", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 10, "description": "The number of seconds to wait before attempting to retry establishment of the initial connection or attempt to reconnect a lost connection" },
    "reconnectOnConnectionFailure": { "index": 15, "kind": "parameter", "displayName": "Reconnect On Connection Failure", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true the consumer will attempt to reconnect to the JMX server when any connection failure occurs. The consumer will attempt to re-establish the JMX connection every 'x' seconds until the connection is made-- where 'x' is the configured reconnectionDelay" },
    "testConnectionOnStartup": { "index": 16, "kind": "parameter", "displayName": "Test Connection On Startup", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If true the consumer will throw an exception if unable to establish the JMX connection upon startup. If false, the consumer will attempt to establish the JMX connection every 'x' seconds until the connection is made -- where 'x' is the configured reconnectionDelay" },
    "initThreshold": { "index": 17, "kind": "parameter", "displayName": "Init Threshold", "group": "counter", "label": "counter", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "Initial threshold for the monitor. The value must exceed this before notifications are fired (counter monitor only)." },
    "modulus": { "index": 18, "kind": "parameter", "displayName": "Modulus", "group": "counter", "label": "counter", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The value at which the counter is reset to zero (counter monitor only)." },
    "offset": { "index": 19, "kind": "parameter", "displayName": "Offset", "group": "counter", "label": "counter", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The amount to increment the threshold after it's been exceeded (counter monitor only)." },
    "differenceMode": { "index": 20, "kind": "parameter", "displayName": "Difference Mode", "group": "gauge", "label": "counter,gauge", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true, then the value reported in the notification is the difference from the threshold as opposed to the value itself (counter and gauge monitor only)." },
    "notifyHigh": { "index": 21, "kind": "parameter", "displayName": "Notify High", "group": "gauge", "label": "gauge", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true, the gauge will fire a notification when the high threshold is exceeded (gauge monitor only)." },
    "notifyLow": { "index": 22, "kind": "parameter", "displayName": "Notify Low", "group": "gauge", "label": "gauge", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true, the gauge will fire a notification when the low threshold is exceeded (gauge monitor only)." },
    "thresholdHigh": { "index": 23, "kind": "parameter", "displayName": "Threshold High", "group": "gauge", "label": "gauge", "required": false, "type": "number", "javaType": "java.lang.Double", "deprecated": false, "autowired": false, "secret": false, "description": "Value for the gauge's high threshold (gauge monitor only)." },
    "thresholdLow": { "index": 24, "kind": "parameter", "displayName": "Threshold Low", "group": "gauge", "label": "gauge", "required": false, "type": "number", "javaType": "java.lang.Double", "deprecated": false, "autowired": false, "secret": false, "description": "Value for the gauge's low threshold (gauge monitor only)." },
    "password": { "index": 25, "kind": "parameter", "displayName": "Password", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "description": "Credentials for making a remote connection" },
    "user": { "index": 26, "kind": "parameter", "displayName": "User", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "description": "Credentials for making a remote connection" },
    "notifyDiffer": { "index": 27, "kind": "parameter", "displayName": "Notify Differ", "group": "string", "label": "consumer,string", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true, will fire a notification when the string attribute differs from the string to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured." },
    "notifyMatch": { "index": 28, "kind": "parameter", "displayName": "Notify Match", "group": "string", "label": "consumer,string", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true, will fire a notification when the string attribute matches the string to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured." },
    "stringToCompare": { "index": 29, "kind": "parameter", "displayName": "String To Compare", "group": "string", "label": "consumer,string", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Value for attribute to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured." }
  }
}
