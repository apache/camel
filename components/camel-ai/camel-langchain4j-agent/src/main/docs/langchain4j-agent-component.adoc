= LangChain4j Agent Component
:doctitle: LangChain4j Agent
:shortname: langchain4j-agent
:artifactid: camel-langchain4j-agent
:description: LangChain4j Agent component
:since: 4.14
:supportlevel: Preview
:tabs-sync-option:
:component-header: Only producer is supported
//Manually maintained attributes
:group: AI
:camel-spring-boot-name: langchain4j-agent

*Since Camel {since}*

*{component-header}*

The LangChain4j Agent component provides comprehensive AI agent capabilities by integrating with the https://github.com/langchain4j/langchain4j[LangChain4j library]. This component supports advanced AI agent patterns including tool calling, MCP (Model Context Protocol) integration, conversation memory, retrieval-augmented generation (RAG), and input/output guardrails.

== Features

The LangChain4j Agent component offers the following key features:

* **Agent-Based Architecture**: Flexible agent creation using the `Agent` API interface
* **Tool Integration**: Seamless integration with Camel routes via the `langchain4j-tools` component
* **MCP Tools**: Integration with Model Context Protocol (MCP) tools for external system access
* **Conversation Memory**: Persistent chat memory for maintaining conversation context
* **RAG Support**: Integration with retrieval systems for naive and advanced RAG
* **Guardrails**: Input and output validation and transformation
* **Configuration Flexibility**: Centralized agent configuration using `AgentConfiguration`
* **Multimodal Content**: Support for images, PDFs, audio, video, and text files from file-based Camel components

== Component Options

The component has been simplified to use only two main options:

* **agent**: Reference to an `Agent` implementation registered in the Camel registry
* **tags**: Tags for discovering and calling Camel route tools (optional)

All other configuration (chat models, memory, RAG, guardrails, custom tools, MCP clients) is now handled through the `AgentConfiguration` when creating agents.

== URI format

[source]
----
langchain4j-agent:agentId[?options]
----

Where *agentId* is a unique identifier for the agent instance.


// component options: START
include::partial$component-configure-options.adoc[]
include::partial$component-endpoint-options.adoc[]
include::partial$component-endpoint-headers.adoc[]
// component options: END

include::spring-boot:partial$starter.adoc[]


== Usage

=== Creating Custom Agents

Starting from Camel 4.14, the LangChain4j Agent component uses an agent-based architecture where agents are created by implementing the `org.apache.camel.component.langchain4j.agent.api.Agent` interface. The component provides two built-in agent implementations:

* `AgentWithMemory` - For chat interactions with conversation history
* `AgentWithoutMemory` - For stateless chat interactions

==== Agent Configuration

Agents are configured using the `AgentConfiguration` class which provides a fluent API for setting up:

* Chat Model
* Chat Memory Provider (for memory-enabled agents)
* Retrieval Augmentor (for RAG functionality)
* Input and Output Guardrails

==== Creating an Agent without Memory

[source, java]
----
// Create and configure the chat model
ChatModel chatModel = OpenAiChatModel.builder()
    .apiKey(openApiKey)
    .modelName(GPT_3_5_TURBO)
    .temperature(0.3)
    .timeout(ofSeconds(3000))
    .build();

// Create agent configuration
AgentConfiguration configuration = new AgentConfiguration()
    .withChatModel(chatModel)
    .withInputGuardrailClasses(List.of())
    .withOutputGuardrailClasses(List.of());

// Create the agent
Agent simpleAgent = new AgentWithoutMemory(configuration);

// Register the agent in the Camel context
context.getRegistry().bind("simpleAgent", simpleAgent);
----

Use the agent in your Camel route:

[source, java]
----
from("direct:chat")
    .to("langchain4j-agent:test?agent=#simpleAgent")
----

==== Creating an Agent with Memory

[source, java]
----
// Create chat model (same as above)
ChatModel chatModel = OpenAiChatModel.builder()...

// Create memory provider
ChatMemoryProvider memoryProvider = memoryId -> MessageWindowChatMemory.builder()
    .id(memoryId)
    .maxMessages(10)
    .chatMemoryStore(persistentStore) // Your persistent store implementation
    .build();

// Create agent configuration with memory
AgentConfiguration configuration = new AgentConfiguration()
    .withChatModel(chatModel)
    .withChatMemoryProvider(memoryProvider)
    .withInputGuardrailClasses(List.of())
    .withOutputGuardrailClasses(List.of());

// Create the agent
Agent memoryAgent = new AgentWithMemory(configuration);

// Register the agent
context.getRegistry().bind("memoryAgent", memoryAgent);
----

[NOTE]
====
Add the `camel-langchain4j-agent-api` dependency to access the Agent API classes in your application:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-langchain4j-agent-api</artifactId>
    <version>x.x.x</version>
</dependency>
----
====

=== Basic Chat with only a userMessage

For simple chat interactions, you can use an agent without memory.

[source,java]
----
from("direct:chat")
    .to("langchain4j-agent:simple?agent=#simpleAgent")
----

The body can either contain the prompt as a String, or you can create an object of type *org.apache.camel.component.langchain4j.agent.api.AiAgentBody* containing the userMessage.

.Usage example with a body as String:
[source, java]
----
var prompt = "What is Apache Camel";

String response = template.requestBody("direct:chat", prompt, String.class);
----

.Usage example with a body as AiAgentBody:
[source, java]
----
var prompt = "What is Apache Camel";
AiAgentBody body = new AiAgentBody(prompt);

String response = template.requestBody("direct:chat", body, String.class);
----

=== Basic Chat with user and system messages

For chat interactions with system prompts, you can use an agent without memory.

[source,java]
----
from("direct:chat")
    .to("langchain4j-agent:simple?agent=#simpleAgent")
----

The body can either contain the user prompt as a String and specifying the *CamelLangChain4jAgentSystemMessage* header for the system prompt, or you can create an object of type *org.apache.camel.component.langchain4j.agent.api.AiAgentBody* containing both *userMessage* and *systemMessage*.

.Usage example with a body as String:
[source, java]
----
var userPrompt = "Write a short story about a lost cat.";
var systemPrompt = "You are a whimsical storyteller. Your responses should be imaginative, descriptive, and always include a touch of magic. Start every story with 'Once upon a starlit night...";

String response = template.requestBodyAndHeader("direct:chat",
                userPrompt, "CamelLangChain4jAgentSystemMessage", systemPrompt , String.class);
----

.Usage example with a body as AiAgentBody:
[source, java]
----
var userPrompt = "Write a short story about a lost cat.";
var systemPrompt = "You are a whimsical storyteller. Your responses should be imaginative, descriptive, and always include a touch of magic. Start every story with 'Once upon a starlit night...";

AiAgentBody body = new AiAgentBody()
                .withUserMessage(userPrompt)
                .withSystemMessage(systemPrompt);

String response = template.requestBody("direct:chat", body, String.class);
----

=== Chat with Tools

Integrate with Camel routes as tools. The LangChain4j Agent component integrates with Camel Routes defined using the Camel LangChain4j Tools component via the `tags` parameter.

[source,java]
----
// Define tool routes
from("langchain4j-tools:userDb?tags=users&description=Query user database&parameter.userId=string")
    .setBody(constant("{\"name\": \"John Doe\", \"id\": \"123\"}"));

from("langchain4j-tools:weather?tags=weather&description=Get weather information&parameter.city=string")
    .setBody(constant("{\"weather\": \"sunny\", \"temperature\": \"22Â°C\"}"));

// Agent with tools (using the created agent)
from("direct:chat")
    .to("langchain4j-agent:tools?agent=#simpleAgent&tags=users,weather");
----

.Usage example :
[source, java]
----
var userPrompt = "Can you tell me the name of user 123 and the weather in New York?";
var systemPrompt = "You are a helpful assistant that can access user database and weather information. Use the available tools to provide accurate information.";

String response = template.requestBodyAndHeader("direct:chat",
                userPrompt, "CamelLangChain4jAgentSystemMessage", systemPrompt , String.class);
----

[NOTE]
====
There's no need to add Camel LangChain4j Tools component as a dependency when using the tools with LangChain4j Agent component.
====

=== Custom LangChain4j Tools

You can also add custom LangChain4j tools using the `@Tool` annotation. These tools are passed directly to the agent via the `customTools` configuration parameter.

==== Creating Custom LangChain4j Tools

Create a class with methods annotated with `@Tool`:

[source,java]
----
import dev.langchain4j.agent.tool.P;
import dev.langchain4j.agent.tool.Tool;

public class CalculatorTool {
    
    @Tool("Adds two numbers")
    public int add(@P("First number") int a, @P("Second number") int b) {
        return a + b;
    }
    
    @Tool("Multiplies two numbers")
    public int multiply(@P("First number") int a, @P("Second number") int b) {
        return a * b;
    }
    
    @Tool("Gets the square root of a number")
    public double sqrt(@P("Number") double x) {
        return Math.sqrt(x);
    }
}
----

==== Using Custom LangChain4j Tools with Agent

Pass your custom tool instances to the agent configuration:

[source,java]
----
// Create tool instances
CalculatorTool calculator = new CalculatorTool();
WeatherTool weather = new WeatherTool();

// Create agent configuration with custom tools
AgentConfiguration config = new AgentConfiguration()
    .withChatModel(chatModel)
    .withCustomTools(Arrays.asList(calculator, weather));

// Create agent
Agent agent = new AgentWithoutMemory(config);

// Register agent in Camel context
context.getRegistry().bind("customToolsAgent", agent);
----

==== Route Configuration

Use the agent with custom tools in your routes:

[source,java]
----
from("direct:chat")
    .to("langchain4j-agent:assistant?agent=#customToolsAgent")
    .to("mock:agent-response");
----

==== Usage Example

[source,java]
----
String response = template.requestBody("direct:chat", 
    "Calculate 10 * 5 and tell me the weather in Paris", String.class);
----

[NOTE]
====
Custom LangChain4j tools are executed directly by the LangChain4j framework. No additional configuration or tool Executor is needed for tool execution.
====

=== Mixed Tools (Camel Routes + Custom LangChain4j Tools)

You can combine both Camel route tools (via `tags`) and custom LangChain4j tools (via `customTools`) in the same agent:

[source,java]
----
// Define Camel route tools
from("langchain4j-tools:weatherService?tags=weather&description=Get current weather information&parameter.location=string")
    .setBody(constant("{\"weather\": \"sunny\", \"location\": \"Current Location\"}"));

// Create custom tool instances
CalculatorTool calculator = new CalculatorTool();
StringTool stringTool = new StringTool();

// Create agent configuration with both types of tools
AgentConfiguration config = new AgentConfiguration()
    .withChatModel(chatModel)
    .withCustomTools(Arrays.asList(calculator, stringTool));

// Create agent
Agent agent = new AgentWithMemory(config);

// Register agent in Camel context
context.getRegistry().bind("mixedToolsAgent", agent);
----

==== Route Configuration with Mixed Tools

[source,java]
----
from("direct:chat")
    .to("langchain4j-agent:assistant?agent=#mixedToolsAgent&tags=weather")
    .to("mock:agent-response");
----

==== Usage Example

[source,java]
----
String response = template.requestBody("direct:chat", 
    "Calculate 10 * 5 and tell me the weather in London", String.class);
----

[NOTE]
====
When using mixed tools, Camel route tools are discovered dynamically via the `tags` parameter, while custom LangChain4j tools are provided statically via the `customTools` configuration.
====

=== MCP (Model Context Protocol) Tools

The LangChain4j Agent component supports integration with MCP (Model Context Protocol) tools, allowing agents to interact with external systems and services through standardized protocols.

==== Configuring MCP Clients

To use MCP tools with your agent, you need to configure MCP clients in your `AgentConfiguration`:

[source,java]
----
// Create MCP transport for filesystem server
McpTransport filesystemTransport = new StdioMcpTransport.Builder()
    .command(Arrays.asList("npx", "-y", "@modelcontextprotocol/server-filesystem", "/path/to/directory"))
    .logEvents(true)
    .build();

// Create MCP client
McpClient filesystemClient = new DefaultMcpClient.Builder()
    .transport(filesystemTransport)
    .build();

// Create agent configuration with MCP clients
AgentConfiguration config = new AgentConfiguration()
    .withChatModel(chatModel)
    .withMcpClients(Arrays.asList(filesystemClient));

// Create agent
Agent agent = new AgentWithoutMemory(config);
----

==== MCP Tool Filtering

You can apply filters to control which MCP tools are available to your agent:

[source,java]
----
// Create security filter to only allow read operations
BiPredicate<McpClient, ToolSpecification> securityFilter = (client, toolSpec) -> {
    String toolName = toolSpec.name().toLowerCase();
    // Only allow read operations for safety
    return toolName.contains("read") || toolName.contains("list") || toolName.contains("get");
};

AgentConfiguration config = new AgentConfiguration()
    .withChatModel(chatModel)
    .withMcpClients(Arrays.asList(filesystemClient))
    .withMcpToolProviderFilter(securityFilter);
----

==== Complete MCP Example

Here's a complete example showing how to use MCP tools with an agent:

[source,java]
----
// Create MCP client for filesystem access
McpTransport transport = new StdioMcpTransport.Builder()
    .command(Arrays.asList("npx", "-y", "@modelcontextprotocol/server-filesystem", "/tmp"))
    .logEvents(true)
    .build();

McpClient mcpClient = new DefaultMcpClient.Builder()
    .transport(transport)
    .build();

// Create agent with MCP tools
AgentConfiguration config = new AgentConfiguration()
    .withChatModel(chatModel)
    .withMcpClient(mcpClient);

Agent agent = new AgentWithoutMemory(config);

// Register agent in Camel context
context.getRegistry().bind("mcpAgent", agent);
----

==== Route Configuration with MCP Tools

[source,java]
----
from("direct:chat")
    .to("langchain4j-agent:assistant?agent=#mcpAgent")
    .to("mock:agent-response");
----

==== Usage Example with MCP Tools

[source,java]
----
String response = template.requestBody("direct:chat", 
    "Can you list the files in the current directory and read the content of file.txt?", String.class);
----

=== RAG Integration

RAG (Retrieval-Augmented Generation) is supported by configuring a `RetrievalAugmentor` in the `AgentConfiguration`. Create an agent with RAG capabilities:

[source,java]
----
// Create the retrieval augmentor (shown below)
RetrievalAugmentor retrievalAugmentor = createRetrievalAugmentor();

// Create agent configuration with RAG
AgentConfiguration configuration = new AgentConfiguration()
    .withChatModel(chatModel)
    .withRetrievalAugmentor(retrievalAugmentor)
    .withInputGuardrailClasses(List.of())
    .withOutputGuardrailClasses(List.of());

Agent ragAgent = new AgentWithoutMemory(configuration);
context.getRegistry().bind("ragAgent", ragAgent);

// Use the RAG agent
from("direct:chat")
    .to("langchain4j-agent:rag?agent=#ragAgent")
----

.Usage example with Retrieval Augmentor serving as naive RAG :
[source, java]
----
// creating the retrieval Augmentor
EmbeddingStoreContentRetriever contentRetriever = EmbeddingStoreContentRetriever.builder()
                .embeddingStore(embeddingStore) // the embedding store should be defined
                .embeddingModel(embeddingModel) // the embedding model should be defined
                .maxResults(3)
                .minScore(0.6)
                .build();

RetrievalAugmentor retrievalAugmentor = DefaultRetrievalAugmentor.builder()
                .contentRetriever(contentRetriever)
                // other options or steps can be included for Advanced RAG
                .build();

// bind the retrievalAugmentor in the context
context.getRegistry().bind("retrievalAugmentor", retrievalAugmentor);

// using the producer
String response = template.requestBody("direct:chat", body, String.class);
----

=== Chat with Memory

Memory functionality is supported by using `AgentWithMemory` and configuring a `ChatMemoryProvider` in the `AgentConfiguration`. The memory works for multiple users/sessions.

[NOTE]
====
The component requires using a Chat Memory Provider that uses a https://docs.langchain4j.dev/tutorials/chat-memory#persistence[persistent memory store].
====

The memory works for multiple users/sessions. For each context window, the users needs to set the memory ID:
- By setting the Header CamelLangChain4jAgentMemoryId. This supposes that user is using a body as String.
- By setting the AiAgentBody.memoryId field. This supposes that that user is using a body as AiAgentBody.

.Example of Route with Memory Agent
[source,java]
----
from("direct:chat")
    .to("langchain4j-agent:memory?agent=#memoryAgent")
----

.Example of usage with AiAgentBody
[source,java]
----
// Example of creating a Chat Memory Provider : Create a message window memory that keeps the last 10 messages
        ChatMemoryProvider chatMemoryProvider = memoryId -> MessageWindowChatMemory.builder()
                .id(memoryId)
                .maxMessages(10)
                .chatMemoryStore(store) // the Chat Memory store is previously created
                .build();

// bind the chat memory provider in the context
context.getRegistry().bind("chatMemoryProvider", chatMemoryProvider);


AiAgentBody request = new AiAgentBody("Hello!", null, "session-123");
String response = template.requestBody("direct:chat", request, String.class);
----


=== Input and Output Guardrails

Guardrails are configured in the `AgentConfiguration` using the fluent API methods. Create classes defining InputGuardrails and OutputGuardrails as defined in the https://docs.langchain4j.dev/tutorials/guardrails[LangChain4j Guardrails documentation] page.

[source,java]
----
// Create agent configuration with guardrails
AgentConfiguration configuration = new AgentConfiguration()
    .withChatModel(chatModel)
    .withInputGuardrailClassesList("com.example.MyInputGuardrail")
    .withOutputGuardrailClassesList("com.example.MyOutputGuardrail1,com.example.MyOutputGuardrail2");

Agent safeAgent = new AgentWithoutMemory(configuration);
context.getRegistry().bind("safeAgent", safeAgent);

// Use the agent with guardrails
from("direct:agent-with-guardrails")
    .to("langchain4j-agent:safe?agent=#safeAgent")
----

[NOTE]
====
The current version of the component returns a String as response. If the outputGuardrails extends JsonExtractorOutputGuardrail class, make sure to return a Json in String format.
====

=== Multimodal Content Support

The LangChain4j Agent component supports multimodal content, allowing you to send images, PDFs, audio, video, and text files to AI models that support vision and document understanding capabilities.

==== Sending Multimodal Content via AiAgentBody

You can explicitly create an `AiAgentBody` with multimodal content:

[source,java]
----
// Load an image and create ImageContent
byte[] imageBytes = Files.readAllBytes(Path.of("image.png"));
String base64Image = Base64.getEncoder().encodeToString(imageBytes);
Image image = Image.builder()
    .base64Data(base64Image)
    .mimeType("image/png")
    .build();
ImageContent imageContent = ImageContent.from(image);

// Create request body with image content
AiAgentBody<ImageContent> body = new AiAgentBody<ImageContent>()
    .withUserMessage("What do you see in this image?")
    .withContent(imageContent);

String response = template.requestBody("direct:chat", body, String.class);
----

==== Automatic File Conversion from Camel Components

The agent component automatically converts files from various Camel components to multimodal content. This enables seamless integration with file-based sources.

===== Supported Input Types

[cols="1,2,2"]
|===
|Input Type |Source Components |MIME Type Detection

|`WrappedFile`
|`file:`, `ftp:`, `sftp:`, `smb:`
|From file extension or headers

|`byte[]`
|`aws2-s3:`, `azure-storage-blob:`, `google-storage:`
|From content type headers (required)

|`InputStream`
|Various streaming components
|From content type headers (required)
|===

===== Example: Processing Images from File Component

[source,java]
----
from("file:inbox/images?noop=true&include=.*\\.png")
    .setHeader("CamelLangChain4jAgentUserMessage", constant("Describe this image"))
    .to("langchain4j-agent:vision?agent=#visionAgent")
    .to("log:response");
----

===== Example: Processing Files from AWS S3

[source,java]
----
from("aws2-s3://my-bucket?prefix=images/&includeBody=true")
    .setHeader("CamelLangChain4jAgentUserMessage", constant("What do you see in this image?"))
    .to("langchain4j-agent:vision?agent=#visionAgent")
    .to("log:response");
----

[NOTE]
====
When using `byte[]` or `InputStream` inputs, a MIME type header is required since the type cannot be auto-detected from the content. The component checks for MIME type in this priority order:

1. `CamelLangChain4jAgentMediaType` header (highest priority - explicit override)
2. `CamelAwsS3ContentType` header (from AWS S3)
3. `Content-Type` header
4. `CamelFileContentType` header (from file components)
====

===== Example: Overriding MIME Type

[source,java]
----
from("direct:process-file")
    .setHeader("CamelLangChain4jAgentUserMessage", constant("Analyze this document"))
    .setHeader("CamelLangChain4jAgentMediaType", constant("application/pdf"))
    .to("langchain4j-agent:analyzer?agent=#analyzerAgent");
----

==== Complete Multimodal Route Example

Here's a complete example showing how to process images from a file system and send them to an AI agent for analysis:

[source,java]
----
// Create a vision-capable chat model
ChatModel chatModel = OpenAiChatModel.builder()
    .apiKey(apiKey)
    .modelName("gpt-4o")  // Vision-capable model
    .build();

// Create agent configuration
AgentConfiguration configuration = new AgentConfiguration()
    .withChatModel(chatModel);

Agent visionAgent = new AgentWithoutMemory(configuration);
context.getRegistry().bind("visionAgent", visionAgent);

// Route to process images
from("file:inbox/images?noop=true&include=.*\\.(png|jpg|jpeg)")
    .setHeader("CamelLangChain4jAgentUserMessage",
        constant("Describe what you see in this image. Be detailed but concise."))
    .to("langchain4j-agent:vision?agent=#visionAgent")
    .log("AI Response: ${body}")
    .to("file:outbox/descriptions");
----
