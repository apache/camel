= Docling Component
:doctitle: Docling
:shortname: docling
:artifactid: camel-docling
:description: Process documents using Docling library for parsing and conversion.
:since: 4.15
:supportlevel: Preview
:tabs-sync-option:
:component-header: Only producer is supported
//Manually maintained attributes
:group: AI
:camel-spring-boot-name: docling

*Since Camel {since}*

*{component-header}*

The Docling component allows you to convert and process documents using https://github.com/DS4SD/docling[IBM's Docling AI document parser].
Docling is a powerful Python library that can parse and convert various document formats including PDF, Word documents, PowerPoint presentations, and more into structured formats like Markdown, HTML, JSON, or plain text.

Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-docling</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

== Prerequisites

This component supports two modes of operation:

1. **CLI Mode (default)**: Requires Docling to be installed on your system via pip:
+
[source,bash]
----
pip install docling
----

2. **API Mode**: Requires a running docling-serve instance. You can run it using:
+
[source,bash]
----
# Install docling-serve
pip install docling-serve

# Run docling-serve
docling-serve --host 0.0.0.0 --port 5001
----
+
Or using Docker:
+
[source,bash]
----
docker run -p 5001:5001 ghcr.io/docling-project/docling-serve:latest
----

== URI format

----
docling:operation[?options]
----

Where `operation` represents the document processing operation to perform.

=== Supported Operations

The component supports the following operations:

[width="100%",cols="2,4",options="header"]
|===
| Operation | Description

| `CONVERT_TO_MARKDOWN`
| Convert document to Markdown format (default)

| `CONVERT_TO_HTML`
| Convert document to HTML format

| `CONVERT_TO_JSON`
| Convert document to JSON format with structure information

| `EXTRACT_TEXT`
| Extract plain text content from document

| `EXTRACT_STRUCTURED_DATA`
| Extract structured data including tables and layout information

| `SUBMIT_ASYNC_CONVERSION`
| Submit an async conversion and return task ID (docling-serve only)

| `CHECK_CONVERSION_STATUS`
| Check the status of an async conversion task (docling-serve only)

|===

// component-configure options: START

// component-configure options: END

// component options: START
include::partial$component-configure-options.adoc[]
include::partial$component-endpoint-options.adoc[]
// component options: END

// endpoint options: START

// endpoint options: END

// component headers: START
include::partial$component-endpoint-headers.adoc[]
// component headers: END

== Usage

=== Input Types

The component accepts the following input types in the message body:

- `String` - File path or document content
- `byte[]` - Binary document content
- `File` - File object
- `InputStream` - Input stream containing document data

=== Output Behavior

The component behavior depends on the `contentInBody` configuration option:

- When `contentInBody=true` (default: false): The converted content is placed in the exchange body and the output file is automatically deleted
- When `contentInBody=false`: The file path to the generated output file is returned in the exchange body

== Examples

=== Basic document conversion to Markdown

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
      - to:
          uri: "file:///data/output"
----
====

=== Convert to HTML with content in body

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_HTML?contentInBody=true")
    .process(exchange -> {
        String htmlContent = exchange.getIn().getBody(String.class);
        // Process the HTML content
    });
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_HTML"
          parameters:
            contentInBody: true
      - process:
          ref: "htmlProcessor"
----
====

=== Extract structured data from documents

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:EXTRACT_STRUCTURED_DATA?outputFormat=json&contentInBody=true")
    .process(exchange -> {
        String jsonData = exchange.getIn().getBody(String.class);
        // Process the structured JSON data
    });
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:EXTRACT_STRUCTURED_DATA"
          parameters:
            outputFormat: "json"
            contentInBody: true
      - process:
          ref: "jsonDataProcessor"
----
====

=== Convert with OCR disabled

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?enableOCR=false")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            enableOCR: false
      - to:
          uri: "file:///data/output"
----
====

=== Using headers to control processing

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .setHeader("CamelDoclingOperation", constant(DoclingOperations.CONVERT_TO_HTML))
    .setHeader("CamelDoclingEnableOCR", constant(true))
    .setHeader("CamelDoclingOCRLanguage", constant("es"))
    .to("docling:CONVERT_TO_MARKDOWN")  // Operation will be overridden by header
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - setHeader:
          name: "CamelDoclingOperation"
          constant: "CONVERT_TO_HTML"
      - setHeader:
          name: "CamelDoclingEnableOCR"
          constant: true
      - setHeader:
          name: "CamelDoclingOCRLanguage"
          constant: "es"
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"  # Operation will be overridden by header
      - to:
          uri: "file:///data/output"
----
====

=== Processing with custom arguments

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .process(exchange -> {
        List<String> customArgs = Arrays.asList("--verbose", "--preserve-tables");
        exchange.getIn().setHeader("CamelDoclingCustomArguments", customArgs);
    })
    .to("docling:CONVERT_TO_MARKDOWN")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - setHeader:
          name: "CamelDoclingCustomArguments"
          expression:
            method:
              ref: "customArgsBean"
              method: "createCustomArgs"
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
      - to:
          uri: "file:///data/output"
----
====

=== Content in body vs file path output

[tabs]
====
Java::
+
[source,java]
----
// Get content directly in body (file is automatically deleted)
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?contentInBody=true")
    .process(exchange -> {
        String markdownContent = exchange.getIn().getBody(String.class);
        log.info("Converted content: {}", markdownContent);
    });

// Get file path (file is preserved)
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?contentInBody=false")
    .process(exchange -> {
        String outputFilePath = exchange.getIn().getBody(String.class);
        log.info("Output file saved at: {}", outputFilePath);
    });
----

YAML::
+
[source,yaml]
----
# Get content directly in body (file is automatically deleted)
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            contentInBody: true
      - process:
          ref: "contentProcessor"

# Get file path (file is preserved)
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            contentInBody: false
      - process:
          ref: "filePathProcessor"
----
====

=== Processor Bean Examples

When using YAML DSL, the processor references used in the examples above would be implemented as Spring beans:

[source,java]
----
@Component("htmlProcessor")
public class HtmlProcessor implements Processor {
    @Override
    public void process(Exchange exchange) throws Exception {
        String htmlContent = exchange.getIn().getBody(String.class);
        // Process the HTML content
        log.info("Processing HTML content of length: {}", htmlContent.length());
    }
}

@Component("jsonDataProcessor")
public class JsonDataProcessor implements Processor {
    @Override
    public void process(Exchange exchange) throws Exception {
        String jsonData = exchange.getIn().getBody(String.class);
        // Process the structured JSON data
        log.info("Processing JSON data: {}", jsonData);
    }
}

@Component("contentProcessor")
public class ContentProcessor implements Processor {
    private static final Logger log = LoggerFactory.getLogger(ContentProcessor.class);

    @Override
    public void process(Exchange exchange) throws Exception {
        String markdownContent = exchange.getIn().getBody(String.class);
        log.info("Converted content: {}", markdownContent);
    }
}

@Component("filePathProcessor")
public class FilePathProcessor implements Processor {
    private static final Logger log = LoggerFactory.getLogger(FilePathProcessor.class);

    @Override
    public void process(Exchange exchange) throws Exception {
        String outputFilePath = exchange.getIn().getBody(String.class);
        log.info("Output file saved at: {}", outputFilePath);
    }
}

@Component("customArgsBean")
public class CustomArgsBean {
    public List<String> createCustomArgs() {
        return Arrays.asList("--verbose", "--preserve-tables");
    }
}
----

== Asynchronous Processing

The component supports asynchronous document conversion when using docling-serve API mode. This is particularly useful for:
- Large documents that take a long time to process
- High-volume batch processing scenarios
- Better resource utilization on the server side

=== Enabling Async Mode

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "useAsyncMode=true&" +
        "asyncPollInterval=2000&" +
        "asyncTimeout=300000&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            useAsyncMode: true
            asyncPollInterval: 2000
            asyncTimeout: 300000
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

=== Async Processing with Custom Timeout

For very large documents, you may need to increase the timeout:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/large-documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "useAsyncMode=true&" +
        "asyncPollInterval=5000&" +
        "asyncTimeout=600000&" +  // 10 minutes
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/large-documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            useAsyncMode: true
            asyncPollInterval: 5000
            asyncTimeout: 600000
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

=== Using Headers to Control Async Behavior

You can override async settings per-message using headers:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .process(exchange -> {
        File file = exchange.getIn().getBody(File.class);
        // Use async mode only for large files
        if (file.length() > 10 * 1024 * 1024) { // > 10MB
            exchange.getIn().setHeader("CamelDoclingUseAsyncMode", true);
            exchange.getIn().setHeader("CamelDoclingAsyncTimeout", 600000L);
        }
    })
    .to("docling:CONVERT_TO_MARKDOWN?useDoclingServe=true&contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - process:
          ref: "asyncDecisionProcessor"
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

=== Custom Async Workflows

For advanced use cases, you can use the `SUBMIT_ASYNC_CONVERSION` and `CHECK_CONVERSION_STATUS` operations to build custom async workflows with full control over task submission and status polling.

**When to use custom workflows:**

- You need custom polling intervals that vary per task
- You want to implement custom retry or backoff strategies
- You need to coordinate multiple async tasks
- You want to store task IDs in a database for later retrieval
- You need fine-grained control over timeout and error handling

**When to use built-in async mode (useAsyncMode=true):**

- Standard use cases where automatic polling is sufficient
- You want the simplest configuration
- Default polling intervals and timeouts work for your needs

NOTE: Custom polling workflows require Java processors and are more complex. The built-in async mode (`useAsyncMode=true`) is recommended for most use cases.

==== Simple Manual Polling (Java)

The simplest custom workflow uses a Java loop to poll for status:

[source,java]
----
// Submit conversion
String taskId = template.requestBody(
    "docling:convert?operation=SUBMIT_ASYNC_CONVERSION&useDoclingServe=true",
    "/path/to/document.pdf", String.class);

// Poll for completion
ConversionStatus status;
int attempts = 0;
do {
    Thread.sleep(1000);
    status = template.requestBody(
        "docling:convert?operation=CHECK_CONVERSION_STATUS&useDoclingServe=true",
        taskId, ConversionStatus.class);
    attempts++;
} while (status.isInProgress() && attempts < 60);

// Get result
if (status.isCompleted()) {
    String result = status.getResult();
    // Process result...
}
----

==== Submit and Poll Pattern (Camel Route)

[tabs]
====
Java::
+
[source,java]
----
// Submit async conversion and poll until complete
from("file:///data/documents?include=.*\\.pdf")
    .log("Starting async conversion for: ${header.CamelFileName}")
    // Step 1: Submit conversion
    .to("docling:convert?operation=SUBMIT_ASYNC_CONVERSION&useDoclingServe=true")
    .log("Submitted conversion with task ID: ${body}")
    .setHeader("taskId", body())
    .setProperty("maxAttempts", constant(60))
    .setProperty("attempt", constant(0))
    // Step 2: Poll for completion
    .loopDoWhile(method(MyPollingHelper.class, "shouldContinuePolling"))
        .process(exchange -> {
            // Increment attempt counter
            Integer attempt = exchange.getProperty("attempt", Integer.class);
            exchange.setProperty("attempt", attempt != null ? attempt + 1 : 1);
        })
        .log("Polling attempt ${exchangeProperty.attempt} of ${exchangeProperty.maxAttempts}")
        .setBody(header("taskId"))
        .to("docling:convert?operation=CHECK_CONVERSION_STATUS&useDoclingServe=true")
        .setProperty("conversionStatus", body())
        .process(exchange -> {
            ConversionStatus status = exchange.getProperty("conversionStatus", ConversionStatus.class);
            if (status.isCompleted()) {
                exchange.setProperty("isCompleted", true);
            } else if (status.isFailed()) {
                exchange.setProperty("isFailed", true);
                exchange.setProperty("errorMessage", status.getErrorMessage());
            }
        })
        .choice()
            .when(exchangeProperty("isCompleted").isEqualTo(true))
                .stop()
            .when(exchangeProperty("isFailed").isEqualTo(true))
                .throwException(new RuntimeException("Conversion failed"))
        .end()
        .delay(1000)
    .end()
    // Step 3: Extract result
    .process(exchange -> {
        ConversionStatus status = exchange.getProperty("conversionStatus", ConversionStatus.class);
        if (status != null && status.isCompleted() && status.getResult() != null) {
            exchange.getIn().setBody(status.getResult());
        } else {
            throw new RuntimeException("Conversion did not complete");
        }
    })
    .to("file:///data/output");

// Helper class for loop condition
public class MyPollingHelper {
    public static boolean shouldContinuePolling(Exchange exchange) {
        Integer attempt = exchange.getProperty("attempt", Integer.class);
        Integer maxAttempts = exchange.getProperty("maxAttempts", Integer.class);
        Boolean isCompleted = exchange.getProperty("isCompleted", Boolean.class);
        Boolean isFailed = exchange.getProperty("isFailed", Boolean.class);

        if (Boolean.TRUE.equals(isCompleted) || Boolean.TRUE.equals(isFailed)) {
            return false;
        }
        if (attempt != null && maxAttempts != null && attempt >= maxAttempts) {
            return false;
        }
        return true;
    }
}
----

YAML::
+
[source,yaml]
----
# Note: For YAML, consider using the built-in async mode (useAsyncMode=true)
# which handles polling automatically. Custom polling is easier in Java DSL.

- route:
    id: async-with-custom-polling
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - log: "Starting async conversion for: ${header.CamelFileName}"
      - to:
          uri: "docling:convert"
          parameters:
            operation: "SUBMIT_ASYNC_CONVERSION"
            useDoclingServe: true
      - log: "Submitted conversion with task ID: ${body}"
      - setHeader:
          name: "taskId"
          simple: "${body}"
      # For YAML, simpler to use Java processor bean or built-in async mode
      - to:
          uri: "bean:asyncPollingProcessor"
      - to: "file:///data/output"
----
====

==== ConversionStatus Object

The `CHECK_CONVERSION_STATUS` operation returns a `ConversionStatus` object with the following properties:

- **taskId** (String) - The task identifier
- **status** (enum) - PENDING, IN_PROGRESS, COMPLETED, FAILED, or UNKNOWN
- **result** (String) - Converted document content (available when status is COMPLETED)
- **errorMessage** (String) - Error details (available when status is FAILED)
- **progress** (Integer) - Task queue position

Helper methods:
- `isCompleted()` - Returns true if conversion completed successfully
- `isFailed()` - Returns true if conversion failed
- `isInProgress()` - Returns true if conversion is still processing

==== Parallel Processing with Custom Workflow

[tabs]
====
Java::
+
[source,java]
----
// Submit multiple conversions
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:convert?operation=SUBMIT_ASYNC_CONVERSION&useDoclingServe=true")
    .to("seda:task-queue");

// Process task queue with multiple threads
from("seda:task-queue?concurrentConsumers=5")
    .log("Processing task: ${body}")
    .setHeader("taskId", body())
    .setProperty("maxAttempts", constant(60))
    .setProperty("attempt", constant(0))
    .loopDoWhile(method(MyPollingHelper.class, "shouldContinuePolling"))
        .process(exchange -> {
            Integer attempt = exchange.getProperty("attempt", Integer.class);
            exchange.setProperty("attempt", attempt != null ? attempt + 1 : 1);
        })
        .setBody(header("taskId"))
        .to("docling:convert?operation=CHECK_CONVERSION_STATUS&useDoclingServe=true")
        .setProperty("conversionStatus", body())
        .process(exchange -> {
            ConversionStatus status = exchange.getProperty("conversionStatus", ConversionStatus.class);
            if (status.isCompleted()) {
                exchange.setProperty("isCompleted", true);
            } else if (status.isFailed()) {
                exchange.setProperty("isFailed", true);
            }
        })
        .choice()
            .when(exchangeProperty("isCompleted").isEqualTo(true))
                .stop()
            .when(exchangeProperty("isFailed").isEqualTo(true))
                .stop()
        .end()
        .delay(1000)
    .end()
    .process(exchange -> {
        ConversionStatus status = exchange.getProperty("conversionStatus", ConversionStatus.class);
        if (status != null && status.isCompleted()) {
            exchange.getIn().setBody(status.getResult());
        }
    })
    .choice()
        .when(body().isNotNull())
            .to("file:///data/output?fileName=${header.CamelFileName}")
    .end();
----

YAML::
+
[source,yaml]
----
# For parallel processing in YAML, recommend using built-in async mode
# which is simpler and handles concurrency automatically

- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:convert"
          parameters:
            operation: "CONVERT_TO_MARKDOWN"
            useDoclingServe: true
            useAsyncMode: true
            asyncPollInterval: 1000
            asyncTimeout: 120000
            contentInBody: true
      - to:
          uri: "file:///data/output"
          parameters:
            fileName: "${header.CamelFileName}"
----
====

TIP: For a complete working example of custom polling workflow, see the `testCustomPollingWorkflowWithRoute()` test in `DoclingServeProducerIT.java` in the camel-docling test sources.

== Using Docling-Serve API

=== Basic usage with docling-serve

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?useDoclingServe=true&doclingServeUrl=http://localhost:5001&contentInBody=true")
    .process(exchange -> {
        String markdown = exchange.getIn().getBody(String.class);
        log.info("Converted content: {}", markdown);
    });
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            contentInBody: true
      - process:
          ref: "markdownProcessor"
----
====

=== Converting documents from URLs using docling-serve

When using docling-serve API mode, you can also process documents from URLs:

[tabs]
====
Java::
+
[source,java]
----
from("timer:convert?repeatCount=1")
    .setBody(constant("https://arxiv.org/pdf/2501.17887"))
    .to("docling:CONVERT_TO_MARKDOWN?useDoclingServe=true&contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "timer:convert"
      parameters:
        repeatCount: 1
    steps:
      - setBody:
          constant: "https://arxiv.org/pdf/2501.17887"
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

=== Batch processing with docling-serve

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.(pdf|docx)")
    .to("docling:CONVERT_TO_HTML?useDoclingServe=true&doclingServeUrl=http://localhost:5001&contentInBody=true")
    .to("file:///data/converted?fileName=${file:name.noext}.html");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.(pdf|docx)"
    steps:
      - to:
          uri: "docling:CONVERT_TO_HTML"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            contentInBody: true
      - to:
          uri: "file:///data/converted"
          parameters:
            fileName: "${file:name.noext}.html"
----
====

=== Authentication with docling-serve

The component supports multiple authentication mechanisms for secured docling-serve instances.

==== Bearer Token Authentication

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl=http://localhost:5001&" +
        "authenticationScheme=BEARER&" +
        "authenticationToken=your-bearer-token-here&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            authenticationScheme: "BEARER"
            authenticationToken: "your-bearer-token-here"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== API Key Authentication

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl=http://localhost:5001&" +
        "authenticationScheme=API_KEY&" +
        "authenticationToken=your-api-key-here&" +
        "apiKeyHeader=X-API-Key&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            authenticationScheme: "API_KEY"
            authenticationToken: "your-api-key-here"
            apiKeyHeader: "X-API-Key"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== Using Custom API Key Header

If your docling-serve instance uses a custom header name for API keys:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl=http://localhost:5001&" +
        "authenticationScheme=API_KEY&" +
        "authenticationToken=your-api-key-here&" +
        "apiKeyHeader=X-Custom-API-Key&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            authenticationScheme: "API_KEY"
            authenticationToken: "your-api-key-here"
            apiKeyHeader: "X-Custom-API-Key"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== Using Authentication Token from Properties

For better security, store authentication tokens in properties or environment variables:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl={{docling.serve.url}}&" +
        "authenticationScheme=BEARER&" +
        "authenticationToken={{docling.serve.token}}&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "{{docling.serve.url}}"
            authenticationScheme: "BEARER"
            authenticationToken: "{{docling.serve.token}}"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

Then define in `application.properties`:
[source,properties]
----
docling.serve.url=http://localhost:5001
docling.serve.token=your-bearer-token-here
----

== Error Handling

The component handles various error scenarios:

- **File size limit exceeded**: Files larger than `maxFileSize` are rejected
- **Process timeout**: Long-running conversions are terminated after `processTimeout` milliseconds
- **Invalid file formats**: Unsupported file formats result in processing errors
- **Docling not found**: Missing Docling installation causes startup failures (CLI mode)
- **Connection errors**: When using docling-serve API mode, connection failures to the API endpoint will result in errors
- **Authentication errors**: Invalid or missing authentication credentials will result in 401 Unauthorized errors from the docling-serve API

== Performance Considerations

- Large documents may require increased `processTimeout` values (CLI mode)
- OCR processing significantly increases processing time for scanned documents
- Consider using `contentInBody=true` when using docling-serve API mode to get results directly in the body
- The `maxFileSize` setting helps prevent resource exhaustion
- **API Mode vs CLI Mode**: The docling-serve API mode typically offers better performance and resource utilization for high-volume document processing, as it maintains a persistent server instance
- **Async Mode**: For large documents or high-volume processing, enable `useAsyncMode=true` to prevent blocking the Camel thread pool. The component will poll the docling-serve API for completion status while freeing up processing threads
- **Async Configuration**: Adjust `asyncPollInterval` (default 2000ms) and `asyncTimeout` (default 300000ms/5 minutes) based on your document size and processing requirements
- **Batch Processing**: When processing multiple documents, async mode allows better parallelization as the docling-serve instance can process multiple documents concurrently while Camel polls for results

== Connection Pool Configuration

When using docling-serve API mode, the component uses an HTTP connection pool for efficient connection management and reuse. The connection pool can be configured using the following advanced parameters:

=== Connection Pool Parameters

[width="100%",cols="2,1,4",options="header"]
|===
| Parameter | Default | Description

| `maxTotalConnections`
| 20
| Maximum total connections in the connection pool

| `maxConnectionsPerRoute`
| 10
| Maximum connections per route (per target host)

| `connectionTimeout`
| 30000
| Connection timeout in milliseconds (time to establish connection)

| `socketTimeout`
| 60000
| Socket timeout in milliseconds (time waiting for data)

| `connectionRequestTimeout`
| 30000
| Connection request timeout in milliseconds (time to get connection from pool)

| `connectionTimeToLive`
| -1
| Time to live for connections in milliseconds (-1 for infinite)

| `validateAfterInactivity`
| 2000
| Validate connections after inactivity in milliseconds

| `evictIdleConnections`
| true
| Enable eviction of idle connections from the pool

| `maxIdleTime`
| 60000
| Maximum idle time for connections in milliseconds before eviction

|===

=== Connection Pool Tuning Examples

==== High-Volume Processing

For high-volume document processing with concurrent requests:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "maxTotalConnections=50&" +
        "maxConnectionsPerRoute=25&" +
        "connectionTimeout=10000&" +
        "socketTimeout=120000&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            maxTotalConnections: 50
            maxConnectionsPerRoute: 25
            connectionTimeout: 10000
            socketTimeout: 120000
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== Long-Running Document Processing

For large documents that take a long time to process:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/large-documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "socketTimeout=300000&" +        // 5 minutes
        "connectionTimeout=60000&" +     // 1 minute
        "validateAfterInactivity=5000&" +
        "maxIdleTime=120000&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/large-documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            socketTimeout: 300000
            connectionTimeout: 60000
            validateAfterInactivity: 5000
            maxIdleTime: 120000
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== Resource-Constrained Environment

For environments with limited resources:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "maxTotalConnections=5&" +
        "maxConnectionsPerRoute=2&" +
        "connectionTimeToLive=30000&" +  // Recycle connections every 30 seconds
        "evictIdleConnections=true&" +
        "maxIdleTime=10000&" +           // Evict after 10 seconds idle
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            maxTotalConnections: 5
            maxConnectionsPerRoute: 2
            connectionTimeToLive: 30000
            evictIdleConnections: true
            maxIdleTime: 10000
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

=== Connection Pool Best Practices

1. **Size the pool appropriately**: Set `maxTotalConnections` based on expected concurrent requests. A good starting point is 2-3 times the number of concurrent threads.

2. **Configure per-route limits**: Set `maxConnectionsPerRoute` to prevent a single host from consuming all connections. Typically 50-70% of `maxTotalConnections`.

3. **Set appropriate timeouts**: Adjust `socketTimeout` based on average document processing time. Add a safety margin for larger documents.

4. **Enable connection validation**: Use `validateAfterInactivity` to ensure connections are healthy before use, especially in unreliable network environments.

5. **Clean up idle connections**: Enable `evictIdleConnections` to free resources when the pool is underutilized.

6. **Monitor pool statistics**: Use logging at DEBUG level to monitor connection pool usage and adjust parameters accordingly.

include::spring-boot:partial$starter.adoc[]
