= Docling Component
:doctitle: Docling
:shortname: docling
:artifactid: camel-docling
:description: Process documents using Docling library for parsing and conversion.
:since: 4.15
:supportlevel: Preview
:tabs-sync-option:
:component-header: Only producer is supported
//Manually maintained attributes
:group: AI
:camel-spring-boot-name: docling

*Since Camel {since}*

*{component-header}*

The Docling component allows you to convert and process documents using https://github.com/DS4SD/docling[IBM's Docling AI document parser].
Docling is a powerful Python library that can parse and convert various document formats including PDF, Word documents, PowerPoint presentations, and more into structured formats like Markdown, HTML, JSON, or plain text.

Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-docling</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

== Prerequisites

This component supports two modes of operation:

1. **CLI Mode (default)**: Requires Docling to be installed on your system via pip:
+
[source,bash]
----
pip install docling
----

2. **API Mode**: Requires a running docling-serve instance. You can run it using:
+
[source,bash]
----
# Install docling-serve
pip install docling-serve

# Run docling-serve
docling-serve --host 0.0.0.0 --port 5001
----
+
Or using Docker:
+
[source,bash]
----
docker run -p 5001:5001 ghcr.io/docling-project/docling-serve:latest
----

== URI format

----
docling:operation[?options]
----

Where `operation` represents the document processing operation to perform.

=== Supported Operations

The component supports the following operations:

[width="100%",cols="2,4",options="header"]
|===
| Operation | Description

| `CONVERT_TO_MARKDOWN`
| Convert document to Markdown format (default)

| `CONVERT_TO_HTML`
| Convert document to HTML format

| `CONVERT_TO_JSON`
| Convert document to JSON format with structure information

| `EXTRACT_TEXT`
| Extract plain text content from document

| `EXTRACT_STRUCTURED_DATA`
| Extract structured data including tables and layout information

|===

// component-configure options: START

// component-configure options: END

// component options: START
include::partial$component-configure-options.adoc[]
include::partial$component-endpoint-options.adoc[]
// component options: END

// endpoint options: START

// endpoint options: END

// component headers: START
include::partial$component-endpoint-headers.adoc[]
// component headers: END

== Usage

=== Input Types

The component accepts the following input types in the message body:

- `String` - File path or document content
- `byte[]` - Binary document content
- `File` - File object
- `InputStream` - Input stream containing document data

=== Output Behavior

The component behavior depends on the `contentInBody` configuration option:

- When `contentInBody=true` (default: false): The converted content is placed in the exchange body and the output file is automatically deleted
- When `contentInBody=false`: The file path to the generated output file is returned in the exchange body

== Examples

=== Basic document conversion to Markdown

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
      - to:
          uri: "file:///data/output"
----
====

=== Convert to HTML with content in body

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_HTML?contentInBody=true")
    .process(exchange -> {
        String htmlContent = exchange.getIn().getBody(String.class);
        // Process the HTML content
    });
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_HTML"
          parameters:
            contentInBody: true
      - process:
          ref: "htmlProcessor"
----
====

=== Extract structured data from documents

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:EXTRACT_STRUCTURED_DATA?outputFormat=json&contentInBody=true")
    .process(exchange -> {
        String jsonData = exchange.getIn().getBody(String.class);
        // Process the structured JSON data
    });
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:EXTRACT_STRUCTURED_DATA"
          parameters:
            outputFormat: "json"
            contentInBody: true
      - process:
          ref: "jsonDataProcessor"
----
====

=== Convert with OCR disabled

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?enableOCR=false")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            enableOCR: false
      - to:
          uri: "file:///data/output"
----
====

=== Using headers to control processing

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .setHeader("CamelDoclingOperation", constant(DoclingOperations.CONVERT_TO_HTML))
    .setHeader("CamelDoclingEnableOCR", constant(true))
    .setHeader("CamelDoclingOCRLanguage", constant("es"))
    .to("docling:CONVERT_TO_MARKDOWN")  // Operation will be overridden by header
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - setHeader:
          name: "CamelDoclingOperation"
          constant: "CONVERT_TO_HTML"
      - setHeader:
          name: "CamelDoclingEnableOCR"
          constant: true
      - setHeader:
          name: "CamelDoclingOCRLanguage"
          constant: "es"
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"  # Operation will be overridden by header
      - to:
          uri: "file:///data/output"
----
====

=== Processing with custom arguments

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .process(exchange -> {
        List<String> customArgs = Arrays.asList("--verbose", "--preserve-tables");
        exchange.getIn().setHeader("CamelDoclingCustomArguments", customArgs);
    })
    .to("docling:CONVERT_TO_MARKDOWN")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - setHeader:
          name: "CamelDoclingCustomArguments"
          expression:
            method:
              ref: "customArgsBean"
              method: "createCustomArgs"
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
      - to:
          uri: "file:///data/output"
----
====

=== Content in body vs file path output

[tabs]
====
Java::
+
[source,java]
----
// Get content directly in body (file is automatically deleted)
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?contentInBody=true")
    .process(exchange -> {
        String markdownContent = exchange.getIn().getBody(String.class);
        log.info("Converted content: {}", markdownContent);
    });

// Get file path (file is preserved)
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?contentInBody=false")
    .process(exchange -> {
        String outputFilePath = exchange.getIn().getBody(String.class);
        log.info("Output file saved at: {}", outputFilePath);
    });
----

YAML::
+
[source,yaml]
----
# Get content directly in body (file is automatically deleted)
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            contentInBody: true
      - process:
          ref: "contentProcessor"

# Get file path (file is preserved)
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            contentInBody: false
      - process:
          ref: "filePathProcessor"
----
====

=== Processor Bean Examples

When using YAML DSL, the processor references used in the examples above would be implemented as Spring beans:

[source,java]
----
@Component("htmlProcessor")
public class HtmlProcessor implements Processor {
    @Override
    public void process(Exchange exchange) throws Exception {
        String htmlContent = exchange.getIn().getBody(String.class);
        // Process the HTML content
        log.info("Processing HTML content of length: {}", htmlContent.length());
    }
}

@Component("jsonDataProcessor")
public class JsonDataProcessor implements Processor {
    @Override
    public void process(Exchange exchange) throws Exception {
        String jsonData = exchange.getIn().getBody(String.class);
        // Process the structured JSON data
        log.info("Processing JSON data: {}", jsonData);
    }
}

@Component("contentProcessor")
public class ContentProcessor implements Processor {
    private static final Logger log = LoggerFactory.getLogger(ContentProcessor.class);

    @Override
    public void process(Exchange exchange) throws Exception {
        String markdownContent = exchange.getIn().getBody(String.class);
        log.info("Converted content: {}", markdownContent);
    }
}

@Component("filePathProcessor")
public class FilePathProcessor implements Processor {
    private static final Logger log = LoggerFactory.getLogger(FilePathProcessor.class);

    @Override
    public void process(Exchange exchange) throws Exception {
        String outputFilePath = exchange.getIn().getBody(String.class);
        log.info("Output file saved at: {}", outputFilePath);
    }
}

@Component("customArgsBean")
public class CustomArgsBean {
    public List<String> createCustomArgs() {
        return Arrays.asList("--verbose", "--preserve-tables");
    }
}
----

== Using Docling-Serve API

=== Basic usage with docling-serve

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?useDoclingServe=true&doclingServeUrl=http://localhost:5001&contentInBody=true")
    .process(exchange -> {
        String markdown = exchange.getIn().getBody(String.class);
        log.info("Converted content: {}", markdown);
    });
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            contentInBody: true
      - process:
          ref: "markdownProcessor"
----
====

=== Converting documents from URLs using docling-serve

When using docling-serve API mode, you can also process documents from URLs:

[tabs]
====
Java::
+
[source,java]
----
from("timer:convert?repeatCount=1")
    .setBody(constant("https://arxiv.org/pdf/2501.17887"))
    .to("docling:CONVERT_TO_MARKDOWN?useDoclingServe=true&contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "timer:convert"
      parameters:
        repeatCount: 1
    steps:
      - setBody:
          constant: "https://arxiv.org/pdf/2501.17887"
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

=== Batch processing with docling-serve

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.(pdf|docx)")
    .to("docling:CONVERT_TO_HTML?useDoclingServe=true&doclingServeUrl=http://localhost:5001&contentInBody=true")
    .to("file:///data/converted?fileName=${file:name.noext}.html");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.(pdf|docx)"
    steps:
      - to:
          uri: "docling:CONVERT_TO_HTML"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            contentInBody: true
      - to:
          uri: "file:///data/converted"
          parameters:
            fileName: "${file:name.noext}.html"
----
====

=== Authentication with docling-serve

The component supports multiple authentication mechanisms for secured docling-serve instances.

==== Bearer Token Authentication

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl=http://localhost:5001&" +
        "authenticationScheme=BEARER&" +
        "authenticationToken=your-bearer-token-here&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            authenticationScheme: "BEARER"
            authenticationToken: "your-bearer-token-here"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== API Key Authentication

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl=http://localhost:5001&" +
        "authenticationScheme=API_KEY&" +
        "authenticationToken=your-api-key-here&" +
        "apiKeyHeader=X-API-Key&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            authenticationScheme: "API_KEY"
            authenticationToken: "your-api-key-here"
            apiKeyHeader: "X-API-Key"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== Using Custom API Key Header

If your docling-serve instance uses a custom header name for API keys:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl=http://localhost:5001&" +
        "authenticationScheme=API_KEY&" +
        "authenticationToken=your-api-key-here&" +
        "apiKeyHeader=X-Custom-API-Key&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "http://localhost:5001"
            authenticationScheme: "API_KEY"
            authenticationToken: "your-api-key-here"
            apiKeyHeader: "X-Custom-API-Key"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

==== Using Authentication Token from Properties

For better security, store authentication tokens in properties or environment variables:

[tabs]
====
Java::
+
[source,java]
----
from("file:///data/documents?include=.*\\.pdf")
    .to("docling:CONVERT_TO_MARKDOWN?" +
        "useDoclingServe=true&" +
        "doclingServeUrl={{docling.serve.url}}&" +
        "authenticationScheme=BEARER&" +
        "authenticationToken={{docling.serve.token}}&" +
        "contentInBody=true")
    .to("file:///data/output");
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: "file:///data/documents"
      parameters:
        include: ".*\\.pdf"
    steps:
      - to:
          uri: "docling:CONVERT_TO_MARKDOWN"
          parameters:
            useDoclingServe: true
            doclingServeUrl: "{{docling.serve.url}}"
            authenticationScheme: "BEARER"
            authenticationToken: "{{docling.serve.token}}"
            contentInBody: true
      - to:
          uri: "file:///data/output"
----
====

Then define in `application.properties`:
[source,properties]
----
docling.serve.url=http://localhost:5001
docling.serve.token=your-bearer-token-here
----

== Error Handling

The component handles various error scenarios:

- **File size limit exceeded**: Files larger than `maxFileSize` are rejected
- **Process timeout**: Long-running conversions are terminated after `processTimeout` milliseconds
- **Invalid file formats**: Unsupported file formats result in processing errors
- **Docling not found**: Missing Docling installation causes startup failures (CLI mode)
- **Connection errors**: When using docling-serve API mode, connection failures to the API endpoint will result in errors
- **Authentication errors**: Invalid or missing authentication credentials will result in 401 Unauthorized errors from the docling-serve API

== Performance Considerations

- Large documents may require increased `processTimeout` values (CLI mode)
- OCR processing significantly increases processing time for scanned documents
- Consider using `contentInBody=true` when using docling-serve API mode to get results directly in the body
- The `maxFileSize` setting helps prevent resource exhaustion
- **API Mode vs CLI Mode**: The docling-serve API mode typically offers better performance and resource utilization for high-volume document processing, as it maintains a persistent server instance

include::spring-boot:partial$starter.adoc[]
