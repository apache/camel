// Generated by camel-yaml-dsl-maven-plugin - do NOT edit this file!
package org.apache.camel.dsl.yaml.deserializers;

import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.dsl.yaml.common.YamlDeserializerBase;
import org.apache.camel.dsl.yaml.common.YamlDeserializerEndpointAwareBase;
import org.apache.camel.dsl.yaml.common.YamlDeserializerSupport;
import org.apache.camel.model.AggregateDefinition;
import org.apache.camel.model.BeanDefinition;
import org.apache.camel.model.CatchDefinition;
import org.apache.camel.model.ChoiceDefinition;
import org.apache.camel.model.CircuitBreakerDefinition;
import org.apache.camel.model.ClaimCheckDefinition;
import org.apache.camel.model.ContextScanDefinition;
import org.apache.camel.model.ConvertBodyDefinition;
import org.apache.camel.model.DataFormatDefinition;
import org.apache.camel.model.DelayDefinition;
import org.apache.camel.model.DynamicRouterDefinition;
import org.apache.camel.model.EnrichDefinition;
import org.apache.camel.model.ErrorHandlerDefinition;
import org.apache.camel.model.FaultToleranceConfigurationDefinition;
import org.apache.camel.model.FilterDefinition;
import org.apache.camel.model.FinallyDefinition;
import org.apache.camel.model.GlobalOptionDefinition;
import org.apache.camel.model.GlobalOptionsDefinition;
import org.apache.camel.model.IdempotentConsumerDefinition;
import org.apache.camel.model.InputTypeDefinition;
import org.apache.camel.model.InterceptDefinition;
import org.apache.camel.model.InterceptFromDefinition;
import org.apache.camel.model.InterceptSendToEndpointDefinition;
import org.apache.camel.model.LoadBalanceDefinition;
import org.apache.camel.model.LogDefinition;
import org.apache.camel.model.LoopDefinition;
import org.apache.camel.model.MarshalDefinition;
import org.apache.camel.model.MulticastDefinition;
import org.apache.camel.model.OnCompletionDefinition;
import org.apache.camel.model.OnExceptionDefinition;
import org.apache.camel.model.OnFallbackDefinition;
import org.apache.camel.model.OptimisticLockRetryPolicyDefinition;
import org.apache.camel.model.OtherwiseDefinition;
import org.apache.camel.model.OutputDefinition;
import org.apache.camel.model.OutputTypeDefinition;
import org.apache.camel.model.PackageScanDefinition;
import org.apache.camel.model.PausableDefinition;
import org.apache.camel.model.PipelineDefinition;
import org.apache.camel.model.PolicyDefinition;
import org.apache.camel.model.PollEnrichDefinition;
import org.apache.camel.model.ProcessDefinition;
import org.apache.camel.model.PropertyDefinition;
import org.apache.camel.model.PropertyExpressionDefinition;
import org.apache.camel.model.RecipientListDefinition;
import org.apache.camel.model.RedeliveryPolicyDefinition;
import org.apache.camel.model.RemoveHeaderDefinition;
import org.apache.camel.model.RemoveHeadersDefinition;
import org.apache.camel.model.RemovePropertiesDefinition;
import org.apache.camel.model.RemovePropertyDefinition;
import org.apache.camel.model.ResequenceDefinition;
import org.apache.camel.model.Resilience4jConfigurationDefinition;
import org.apache.camel.model.RestContextRefDefinition;
import org.apache.camel.model.ResumableDefinition;
import org.apache.camel.model.RollbackDefinition;
import org.apache.camel.model.RouteBuilderDefinition;
import org.apache.camel.model.RouteConfigurationContextRefDefinition;
import org.apache.camel.model.RouteContextRefDefinition;
import org.apache.camel.model.RouteDefinition;
import org.apache.camel.model.RouteTemplateParameterDefinition;
import org.apache.camel.model.RoutingSlipDefinition;
import org.apache.camel.model.SagaActionUriDefinition;
import org.apache.camel.model.SagaDefinition;
import org.apache.camel.model.SamplingDefinition;
import org.apache.camel.model.ScriptDefinition;
import org.apache.camel.model.SetBodyDefinition;
import org.apache.camel.model.SetExchangePatternDefinition;
import org.apache.camel.model.SetHeaderDefinition;
import org.apache.camel.model.SetPropertyDefinition;
import org.apache.camel.model.SortDefinition;
import org.apache.camel.model.SplitDefinition;
import org.apache.camel.model.StepDefinition;
import org.apache.camel.model.StopDefinition;
import org.apache.camel.model.TemplatedRouteParameterDefinition;
import org.apache.camel.model.ThreadPoolProfileDefinition;
import org.apache.camel.model.ThreadsDefinition;
import org.apache.camel.model.ThrottleDefinition;
import org.apache.camel.model.ThrowExceptionDefinition;
import org.apache.camel.model.ToDefinition;
import org.apache.camel.model.ToDynamicDefinition;
import org.apache.camel.model.TransactedDefinition;
import org.apache.camel.model.TransformDefinition;
import org.apache.camel.model.TryDefinition;
import org.apache.camel.model.UnmarshalDefinition;
import org.apache.camel.model.ValidateDefinition;
import org.apache.camel.model.ValueDefinition;
import org.apache.camel.model.WhenDefinition;
import org.apache.camel.model.WhenSkipSendToEndpointDefinition;
import org.apache.camel.model.WireTapDefinition;
import org.apache.camel.model.app.ApplicationDefinition;
import org.apache.camel.model.app.BeanConstructorDefinition;
import org.apache.camel.model.app.BeanConstructorsDefinition;
import org.apache.camel.model.app.BeanPropertiesDefinition;
import org.apache.camel.model.app.BeanPropertyDefinition;
import org.apache.camel.model.app.BeansDefinition;
import org.apache.camel.model.app.ComponentScanDefinition;
import org.apache.camel.model.app.RegistryBeanDefinition;
import org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration;
import org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration;
import org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration;
import org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration;
import org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration;
import org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration;
import org.apache.camel.model.cloud.ServiceCallConfigurationDefinition;
import org.apache.camel.model.cloud.ServiceCallDefinition;
import org.apache.camel.model.cloud.ServiceCallExpressionConfiguration;
import org.apache.camel.model.cloud.ServiceCallServiceChooserConfiguration;
import org.apache.camel.model.cloud.ServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.cloud.ServiceCallServiceFilterConfiguration;
import org.apache.camel.model.cloud.ServiceCallServiceLoadBalancerConfiguration;
import org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration;
import org.apache.camel.model.config.BatchResequencerConfig;
import org.apache.camel.model.config.StreamResequencerConfig;
import org.apache.camel.model.dataformat.ASN1DataFormat;
import org.apache.camel.model.dataformat.AvroDataFormat;
import org.apache.camel.model.dataformat.BarcodeDataFormat;
import org.apache.camel.model.dataformat.Base64DataFormat;
import org.apache.camel.model.dataformat.BindyDataFormat;
import org.apache.camel.model.dataformat.CBORDataFormat;
import org.apache.camel.model.dataformat.CryptoDataFormat;
import org.apache.camel.model.dataformat.CsvDataFormat;
import org.apache.camel.model.dataformat.CustomDataFormat;
import org.apache.camel.model.dataformat.DataFormatsDefinition;
import org.apache.camel.model.dataformat.FhirJsonDataFormat;
import org.apache.camel.model.dataformat.FhirXmlDataFormat;
import org.apache.camel.model.dataformat.FlatpackDataFormat;
import org.apache.camel.model.dataformat.GrokDataFormat;
import org.apache.camel.model.dataformat.GzipDeflaterDataFormat;
import org.apache.camel.model.dataformat.HL7DataFormat;
import org.apache.camel.model.dataformat.IcalDataFormat;
import org.apache.camel.model.dataformat.JacksonXMLDataFormat;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.JsonApiDataFormat;
import org.apache.camel.model.dataformat.JsonDataFormat;
import org.apache.camel.model.dataformat.LZFDataFormat;
import org.apache.camel.model.dataformat.MimeMultipartDataFormat;
import org.apache.camel.model.dataformat.PGPDataFormat;
import org.apache.camel.model.dataformat.ParquetAvroDataFormat;
import org.apache.camel.model.dataformat.ProtobufDataFormat;
import org.apache.camel.model.dataformat.RssDataFormat;
import org.apache.camel.model.dataformat.SoapDataFormat;
import org.apache.camel.model.dataformat.SwiftMtDataFormat;
import org.apache.camel.model.dataformat.SwiftMxDataFormat;
import org.apache.camel.model.dataformat.SyslogDataFormat;
import org.apache.camel.model.dataformat.TarFileDataFormat;
import org.apache.camel.model.dataformat.ThriftDataFormat;
import org.apache.camel.model.dataformat.TidyMarkupDataFormat;
import org.apache.camel.model.dataformat.UniVocityCsvDataFormat;
import org.apache.camel.model.dataformat.UniVocityFixedDataFormat;
import org.apache.camel.model.dataformat.UniVocityHeader;
import org.apache.camel.model.dataformat.UniVocityTsvDataFormat;
import org.apache.camel.model.dataformat.XMLSecurityDataFormat;
import org.apache.camel.model.dataformat.YAMLDataFormat;
import org.apache.camel.model.dataformat.YAMLTypeFilterDefinition;
import org.apache.camel.model.dataformat.ZipDeflaterDataFormat;
import org.apache.camel.model.dataformat.ZipFileDataFormat;
import org.apache.camel.model.errorhandler.DeadLetterChannelDefinition;
import org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition;
import org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition;
import org.apache.camel.model.errorhandler.NoErrorHandlerDefinition;
import org.apache.camel.model.errorhandler.RefErrorHandlerDefinition;
import org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition;
import org.apache.camel.model.language.CSimpleExpression;
import org.apache.camel.model.language.ConstantExpression;
import org.apache.camel.model.language.DatasonnetExpression;
import org.apache.camel.model.language.ExchangePropertyExpression;
import org.apache.camel.model.language.ExpressionDefinition;
import org.apache.camel.model.language.GroovyExpression;
import org.apache.camel.model.language.HeaderExpression;
import org.apache.camel.model.language.Hl7TerserExpression;
import org.apache.camel.model.language.JavaScriptExpression;
import org.apache.camel.model.language.JoorExpression;
import org.apache.camel.model.language.JqExpression;
import org.apache.camel.model.language.JsonPathExpression;
import org.apache.camel.model.language.LanguageExpression;
import org.apache.camel.model.language.MethodCallExpression;
import org.apache.camel.model.language.MvelExpression;
import org.apache.camel.model.language.OgnlExpression;
import org.apache.camel.model.language.PythonExpression;
import org.apache.camel.model.language.RefExpression;
import org.apache.camel.model.language.SimpleExpression;
import org.apache.camel.model.language.SpELExpression;
import org.apache.camel.model.language.TokenizerExpression;
import org.apache.camel.model.language.XMLTokenizerExpression;
import org.apache.camel.model.language.XPathExpression;
import org.apache.camel.model.language.XQueryExpression;
import org.apache.camel.model.loadbalancer.CustomLoadBalancerDefinition;
import org.apache.camel.model.loadbalancer.FailoverLoadBalancerDefinition;
import org.apache.camel.model.loadbalancer.RandomLoadBalancerDefinition;
import org.apache.camel.model.loadbalancer.RoundRobinLoadBalancerDefinition;
import org.apache.camel.model.loadbalancer.StickyLoadBalancerDefinition;
import org.apache.camel.model.loadbalancer.TopicLoadBalancerDefinition;
import org.apache.camel.model.loadbalancer.WeightedLoadBalancerDefinition;
import org.apache.camel.model.rest.ApiKeyDefinition;
import org.apache.camel.model.rest.BasicAuthDefinition;
import org.apache.camel.model.rest.BearerTokenDefinition;
import org.apache.camel.model.rest.DeleteDefinition;
import org.apache.camel.model.rest.GetDefinition;
import org.apache.camel.model.rest.HeadDefinition;
import org.apache.camel.model.rest.MutualTLSDefinition;
import org.apache.camel.model.rest.OAuth2Definition;
import org.apache.camel.model.rest.OpenIdConnectDefinition;
import org.apache.camel.model.rest.ParamDefinition;
import org.apache.camel.model.rest.PatchDefinition;
import org.apache.camel.model.rest.PostDefinition;
import org.apache.camel.model.rest.PutDefinition;
import org.apache.camel.model.rest.ResponseHeaderDefinition;
import org.apache.camel.model.rest.ResponseMessageDefinition;
import org.apache.camel.model.rest.RestBindingDefinition;
import org.apache.camel.model.rest.RestConfigurationDefinition;
import org.apache.camel.model.rest.RestDefinition;
import org.apache.camel.model.rest.RestPropertyDefinition;
import org.apache.camel.model.rest.RestSecuritiesDefinition;
import org.apache.camel.model.rest.RestsDefinition;
import org.apache.camel.model.rest.SecurityDefinition;
import org.apache.camel.model.transformer.CustomTransformerDefinition;
import org.apache.camel.model.transformer.DataFormatTransformerDefinition;
import org.apache.camel.model.transformer.EndpointTransformerDefinition;
import org.apache.camel.model.transformer.LoadTransformerDefinition;
import org.apache.camel.model.transformer.TransformersDefinition;
import org.apache.camel.model.validator.CustomValidatorDefinition;
import org.apache.camel.model.validator.EndpointValidatorDefinition;
import org.apache.camel.model.validator.PredicateValidatorDefinition;
import org.apache.camel.model.validator.ValidatorsDefinition;
import org.apache.camel.spi.annotations.YamlIn;
import org.apache.camel.spi.annotations.YamlProperty;
import org.apache.camel.spi.annotations.YamlType;
import org.snakeyaml.engine.v2.nodes.MappingNode;
import org.snakeyaml.engine.v2.nodes.Node;

@SuppressWarnings("PMD.UnnecessaryFullyQualifiedName")
public final class ModelDeserializers extends YamlDeserializerSupport {
    private ModelDeserializers() {
    }

    @YamlType(
            nodes = "asn1",
            inline = true,
            types = org.apache.camel.model.dataformat.ASN1DataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "ASN.1 File",
            description = "Encode and decode data structures using Abstract Syntax Notation One (ASN.1).",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class to use when unmarshalling.", displayName = "Unmarshal Type"),
                    @YamlProperty(name = "using-iterator", type = "boolean", description = "If the asn1 file has more than one entry, the setting this option to true, allows working with the splitter EIP, to split the data using an iterator in a streaming mode.", displayName = "Using Iterator")
            }
    )
    public static class ASN1DataFormatDeserializer extends YamlDeserializerBase<ASN1DataFormat> {
        public ASN1DataFormatDeserializer() {
            super(ASN1DataFormat.class);
        }

        @Override
        protected ASN1DataFormat newInstance() {
            return new ASN1DataFormat();
        }

        @Override
        protected ASN1DataFormat newInstance(String value) {
            return new ASN1DataFormat(value);
        }

        @Override
        protected boolean setProperty(ASN1DataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                case "using-iterator": {
                    String val = asText(node);
                    target.setUsingIterator(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "aggregate",
            types = org.apache.camel.model.AggregateDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Aggregate",
            description = "Aggregates many messages into a single message",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "aggregate-controller", type = "string", description = "To use a org.apache.camel.processor.aggregate.AggregateController to allow external sources to control this aggregator.", displayName = "Aggregate Controller"),
                    @YamlProperty(name = "aggregation-repository", type = "string", description = "The AggregationRepository to use. Sets the custom aggregate repository to use. Will by default use org.apache.camel.processor.aggregate.MemoryAggregationRepository", displayName = "Aggregation Repository"),
                    @YamlProperty(name = "aggregation-strategy", type = "string", required = true, description = "The AggregationStrategy to use. For example to lookup a bean with the name foo, the value is simply just #bean:foo. Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges. At first call the oldExchange parameter is null. On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.", displayName = "Aggregation Strategy"),
                    @YamlProperty(name = "aggregation-strategy-method-allow-null", type = "boolean", description = "If this option is false then the aggregate method is not used for the very first aggregation. If this option is true then null values is used as the oldExchange (at the very first aggregation), when using beans as the AggregationStrategy.", displayName = "Aggregation Strategy Method Allow Null"),
                    @YamlProperty(name = "aggregation-strategy-method-name", type = "string", description = "This option can be used to explicit declare the method name to use, when using beans as the AggregationStrategy.", displayName = "Aggregation Strategy Method Name"),
                    @YamlProperty(name = "close-correlation-key-on-completion", type = "number", description = "Closes a correlation key when its complete. Any late received exchanges which has a correlation key that has been closed, it will be defined and a ClosedCorrelationKeyException is thrown.", displayName = "Close Correlation Key On Completion"),
                    @YamlProperty(name = "complete-all-on-stop", type = "boolean", description = "Indicates to wait to complete all current and partial (pending) aggregated exchanges when the context is stopped. This also means that we will wait for all pending exchanges which are stored in the aggregation repository to complete so the repository is empty before we can stop. You may want to enable this when using the memory based aggregation repository that is memory based only, and do not store data on disk. When this option is enabled, then the aggregator is waiting to complete all those exchanges before its stopped, when stopping CamelContext or the route using it.", displayName = "Complete All On Stop"),
                    @YamlProperty(name = "completion-from-batch-consumer", type = "boolean", description = "Enables the batch completion mode where we aggregate from a org.apache.camel.BatchConsumer and aggregate the total number of exchanges the org.apache.camel.BatchConsumer has reported as total by checking the exchange property org.apache.camel.Exchange#BATCH_COMPLETE when its complete. This option cannot be used together with discardOnAggregationFailure.", displayName = "Completion From Batch Consumer"),
                    @YamlProperty(name = "completion-interval", type = "string", description = "A repeating period in millis by which the aggregator will complete all current aggregated exchanges. Camel has a background task which is triggered every period. You cannot use this option together with completionTimeout, only one of them can be used.", displayName = "Completion Interval"),
                    @YamlProperty(name = "completion-on-new-correlation-group", type = "boolean", description = "Enables completion on all previous groups when a new incoming correlation group. This can for example be used to complete groups with same correlation keys when they are in consecutive order. Notice when this is enabled then only 1 correlation group can be in progress as when a new correlation group starts, then the previous groups is forced completed.", displayName = "Completion On New Correlation Group"),
                    @YamlProperty(name = "completion-predicate", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "A Predicate to indicate when an aggregated exchange is complete. If this is not specified and the AggregationStrategy object implements Predicate, the aggregationStrategy object will be used as the completionPredicate.", displayName = "Completion Predicate"),
                    @YamlProperty(name = "completion-size", type = "number", description = "Number of messages aggregated before the aggregation is complete. This option can be set as either a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.", displayName = "Completion Size"),
                    @YamlProperty(name = "completion-size-expression", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "Number of messages aggregated before the aggregation is complete. This option can be set as either a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.", displayName = "Completion Size Expression"),
                    @YamlProperty(name = "completion-timeout", type = "string", description = "Time in millis that an aggregated exchange should be inactive before its complete (timeout). This option can be set as either a fixed value or using an Expression which allows you to evaluate a timeout dynamically - will use Long as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0. You cannot use this option together with completionInterval, only one of the two can be used. By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option to configure how frequently to run the checker. The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value. It is not recommended to use very low timeout values or checker intervals.", displayName = "Completion Timeout"),
                    @YamlProperty(name = "completion-timeout-checker-interval", type = "string", defaultValue = "1000", description = "Interval in millis that is used by the background task that checks for timeouts ( org.apache.camel.TimeoutMap ). By default the timeout checker runs every second. The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value. It is not recommended to use very low timeout values or checker intervals.", displayName = "Completion Timeout Checker Interval"),
                    @YamlProperty(name = "completion-timeout-expression", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "Time in millis that an aggregated exchange should be inactive before its complete (timeout). This option can be set as either a fixed value or using an Expression which allows you to evaluate a timeout dynamically - will use Long as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0. You cannot use this option together with completionInterval, only one of the two can be used. By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option to configure how frequently to run the checker. The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value. It is not recommended to use very low timeout values or checker intervals.", displayName = "Completion Timeout Expression"),
                    @YamlProperty(name = "correlation-expression", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "The expression used to calculate the correlation key to use for aggregation. The Exchange which has the same correlation key is aggregated together. If the correlation key could not be evaluated an Exception is thrown. You can disable this by using the ignoreBadCorrelationKeys option.", displayName = "Correlation Expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "discard-on-aggregation-failure", type = "boolean", description = "Discards the aggregated message when aggregation failed (an exception was thrown from AggregationStrategy . This means the partly aggregated message is dropped and not sent out of the aggregator. This option cannot be used together with completionFromBatchConsumer.", displayName = "Discard On Aggregation Failure"),
                    @YamlProperty(name = "discard-on-completion-timeout", type = "boolean", description = "Discards the aggregated message on completion timeout. This means on timeout the aggregated message is dropped and not sent out of the aggregator.", displayName = "Discard On Completion Timeout"),
                    @YamlProperty(name = "eager-check-completion", type = "boolean", description = "Use eager completion checking which means that the completionPredicate will use the incoming Exchange. As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.", displayName = "Eager Check Completion"),
                    @YamlProperty(name = "executor-service", type = "string", description = "If using parallelProcessing you can specify a custom thread pool to be used. In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.", displayName = "Executor Service"),
                    @YamlProperty(name = "force-completion-on-stop", type = "boolean", description = "Indicates to complete all current aggregated exchanges when the context is stopped", displayName = "Force Completion On Stop"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-correlation-keys", type = "boolean", description = "If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just ignore the incoming Exchange.", displayName = "Ignore Invalid Correlation Keys"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "optimistic-lock-retry-policy", type = "object:org.apache.camel.model.OptimisticLockRetryPolicyDefinition", description = "Allows to configure retry settings when using optimistic locking.", displayName = "Optimistic Lock Retry Policy"),
                    @YamlProperty(name = "optimistic-locking", type = "boolean", description = "Turns on using optimistic locking, which requires the aggregationRepository being used, is supporting this by implementing org.apache.camel.spi.OptimisticLockingAggregationRepository .", displayName = "Optimistic Locking"),
                    @YamlProperty(name = "parallel-processing", type = "boolean", description = "When aggregated are completed they are being send out of the aggregator. This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency. If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.", displayName = "Parallel Processing"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "timeout-checker-executor-service", type = "string", description = "If using either of the completionTimeout, completionTimeoutExpression, or completionInterval options a background thread is created to check for the completion for every aggregator. Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.", displayName = "Timeout Checker Executor Service")
            }
    )
    public static class AggregateDefinitionDeserializer extends YamlDeserializerBase<AggregateDefinition> {
        public AggregateDefinitionDeserializer() {
            super(AggregateDefinition.class);
        }

        @Override
        protected AggregateDefinition newInstance() {
            return new AggregateDefinition();
        }

        @Override
        protected boolean setProperty(AggregateDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "aggregate-controller": {
                    String val = asText(node);
                    target.setAggregateController(val);
                    break;
                }
                case "aggregation-repository": {
                    String val = asText(node);
                    target.setAggregationRepository(val);
                    break;
                }
                case "aggregation-strategy": {
                    String val = asText(node);
                    target.setAggregationStrategy(val);
                    break;
                }
                case "aggregation-strategy-method-allow-null": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodAllowNull(val);
                    break;
                }
                case "aggregation-strategy-method-name": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodName(val);
                    break;
                }
                case "close-correlation-key-on-completion": {
                    String val = asText(node);
                    target.setCloseCorrelationKeyOnCompletion(val);
                    break;
                }
                case "complete-all-on-stop": {
                    String val = asText(node);
                    target.setCompleteAllOnStop(val);
                    break;
                }
                case "completion-from-batch-consumer": {
                    String val = asText(node);
                    target.setCompletionFromBatchConsumer(val);
                    break;
                }
                case "completion-interval": {
                    String val = asText(node);
                    target.setCompletionInterval(val);
                    break;
                }
                case "completion-on-new-correlation-group": {
                    String val = asText(node);
                    target.setCompletionOnNewCorrelationGroup(val);
                    break;
                }
                case "completion-predicate": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setCompletionPredicate(val);
                    break;
                }
                case "completion-size": {
                    String val = asText(node);
                    target.setCompletionSize(val);
                    break;
                }
                case "completion-size-expression": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setCompletionSizeExpression(val);
                    break;
                }
                case "completion-timeout": {
                    String val = asText(node);
                    target.setCompletionTimeout(val);
                    break;
                }
                case "completion-timeout-checker-interval": {
                    String val = asText(node);
                    target.setCompletionTimeoutCheckerInterval(val);
                    break;
                }
                case "completion-timeout-expression": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setCompletionTimeoutExpression(val);
                    break;
                }
                case "correlation-expression": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setCorrelationExpression(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "discard-on-aggregation-failure": {
                    String val = asText(node);
                    target.setDiscardOnAggregationFailure(val);
                    break;
                }
                case "discard-on-completion-timeout": {
                    String val = asText(node);
                    target.setDiscardOnCompletionTimeout(val);
                    break;
                }
                case "eager-check-completion": {
                    String val = asText(node);
                    target.setEagerCheckCompletion(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "force-completion-on-stop": {
                    String val = asText(node);
                    target.setForceCompletionOnStop(val);
                    break;
                }
                case "ignore-invalid-correlation-keys": {
                    String val = asText(node);
                    target.setIgnoreInvalidCorrelationKeys(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "optimistic-lock-retry-policy": {
                    org.apache.camel.model.OptimisticLockRetryPolicyDefinition val = asType(node, org.apache.camel.model.OptimisticLockRetryPolicyDefinition.class);
                    target.setOptimisticLockRetryPolicyDefinition(val);
                    break;
                }
                case "optimistic-locking": {
                    String val = asText(node);
                    target.setOptimisticLocking(val);
                    break;
                }
                case "parallel-processing": {
                    String val = asText(node);
                    target.setParallelProcessing(val);
                    break;
                }
                case "timeout-checker-executor-service": {
                    String val = asText(node);
                    target.setTimeoutCheckerExecutorService(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "api-key",
                    "apiKey"
            },
            types = org.apache.camel.model.rest.ApiKeyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Api Key",
            description = "Rest security basic auth definition",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "A short description for security scheme.", displayName = "Description"),
                    @YamlProperty(name = "in-cookie", type = "boolean", description = "To use a cookie as the location of the API key.", displayName = "In Cookie"),
                    @YamlProperty(name = "in-header", type = "boolean", description = "To use header as the location of the API key.", displayName = "In Header"),
                    @YamlProperty(name = "in-query", type = "boolean", description = "To use query parameter as the location of the API key.", displayName = "In Query"),
                    @YamlProperty(name = "key", type = "string", required = true, description = "Key used to refer to this security definition", displayName = "Key"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "The name of the header or query parameter to be used.", displayName = "Name")
            }
    )
    public static class ApiKeyDefinitionDeserializer extends YamlDeserializerBase<ApiKeyDefinition> {
        public ApiKeyDefinitionDeserializer() {
            super(ApiKeyDefinition.class);
        }

        @Override
        protected ApiKeyDefinition newInstance() {
            return new ApiKeyDefinition();
        }

        @Override
        protected boolean setProperty(ApiKeyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "in-cookie": {
                    String val = asText(node);
                    target.setInCookie(val);
                    break;
                }
                case "in-header": {
                    String val = asText(node);
                    target.setInHeader(val);
                    break;
                }
                case "in-query": {
                    String val = asText(node);
                    target.setInQuery(val);
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "camel",
            types = org.apache.camel.model.app.ApplicationDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Camel",
            description = "If beans reminds Spring application too much, we can use camel.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "bean", type = "array:org.apache.camel.model.app.RegistryBeanDefinition", displayName = "Bean"),
                    @YamlProperty(name = "component-scan", type = "array:org.apache.camel.model.app.ComponentScanDefinition"),
                    @YamlProperty(name = "rest", type = "array:org.apache.camel.model.rest.RestDefinition", displayName = "Rest"),
                    @YamlProperty(name = "rest-configuration", type = "array:org.apache.camel.model.rest.RestConfigurationDefinition", displayName = "Rest Configuration"),
                    @YamlProperty(name = "route", type = "array:org.apache.camel.model.RouteDefinition", displayName = "Route"),
                    @YamlProperty(name = "route-configuration", type = "array:org.apache.camel.model.RouteConfigurationDefinition", displayName = "Route Configuration"),
                    @YamlProperty(name = "route-template", type = "array:org.apache.camel.model.RouteTemplateDefinition", displayName = "Route Template"),
                    @YamlProperty(name = "templated-route", type = "array:org.apache.camel.model.TemplatedRouteDefinition", displayName = "Templated Route")
            }
    )
    public static class ApplicationDefinitionDeserializer extends YamlDeserializerBase<ApplicationDefinition> {
        public ApplicationDefinitionDeserializer() {
            super(ApplicationDefinition.class);
        }

        @Override
        protected ApplicationDefinition newInstance() {
            return new ApplicationDefinition();
        }

        @Override
        protected boolean setProperty(ApplicationDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "bean": {
                    java.util.List<org.apache.camel.model.app.RegistryBeanDefinition> val = asFlatList(node, org.apache.camel.model.app.RegistryBeanDefinition.class);
                    target.setBeans(val);
                    break;
                }
                case "component-scan": {
                    java.util.List<org.apache.camel.model.app.ComponentScanDefinition> val = asFlatList(node, org.apache.camel.model.app.ComponentScanDefinition.class);
                    target.setComponentScanning(val);
                    break;
                }
                case "rest-configuration": {
                    java.util.List<org.apache.camel.model.rest.RestConfigurationDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestConfigurationDefinition.class);
                    target.setRestConfigurations(val);
                    break;
                }
                case "rest": {
                    java.util.List<org.apache.camel.model.rest.RestDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestDefinition.class);
                    target.setRests(val);
                    break;
                }
                case "route-configuration": {
                    java.util.List<org.apache.camel.model.RouteConfigurationDefinition> val = asFlatList(node, org.apache.camel.model.RouteConfigurationDefinition.class);
                    target.setRouteConfigurations(val);
                    break;
                }
                case "route-template": {
                    java.util.List<org.apache.camel.model.RouteTemplateDefinition> val = asFlatList(node, org.apache.camel.model.RouteTemplateDefinition.class);
                    target.setRouteTemplates(val);
                    break;
                }
                case "route": {
                    java.util.List<org.apache.camel.model.RouteDefinition> val = asFlatList(node, org.apache.camel.model.RouteDefinition.class);
                    target.setRoutes(val);
                    break;
                }
                case "templated-route": {
                    java.util.List<org.apache.camel.model.TemplatedRouteDefinition> val = asFlatList(node, org.apache.camel.model.TemplatedRouteDefinition.class);
                    target.setTemplatedRoutes(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "avro",
            inline = true,
            types = org.apache.camel.model.dataformat.AvroDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Avro",
            description = "Serialize and deserialize messages using Apache Avro binary data format.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-jms-type", type = "boolean", description = "Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.", displayName = "Allow Jms Type"),
                    @YamlProperty(name = "allow-unmarshall-type", type = "boolean", description = "If enabled then Jackson is allowed to attempt to use the CamelJacksonUnmarshalType header during the unmarshalling. This should only be enabled when desired to be used.", displayName = "Allow Unmarshall Type"),
                    @YamlProperty(name = "auto-discover-object-mapper", type = "boolean", description = "If set to true then Jackson will lookup for an objectMapper into the registry", displayName = "Auto Discover Object Mapper"),
                    @YamlProperty(name = "auto-discover-schema-resolver", type = "boolean", description = "When not disabled, the SchemaResolver will be looked up into the registry", displayName = "Auto Discover Schema Resolver"),
                    @YamlProperty(name = "collection-type", type = "string", description = "Refers to a custom collection type to lookup in the registry to use. This option should rarely be used, but allows to use different collection types than java.util.Collection based as default.", displayName = "Collection Type"),
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "disable-features", type = "string", description = "Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Disable Features"),
                    @YamlProperty(name = "enable-features", type = "string", description = "Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Enable Features"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "include", type = "string", description = "If you want to marshal a pojo to JSON, and the pojo has some fields with null values. And you want to skip these null values, you can set this option to NON_NULL", displayName = "Include"),
                    @YamlProperty(name = "instance-class-name", type = "string", description = "Class name to use for marshal and unmarshalling", displayName = "Instance Class Name"),
                    @YamlProperty(name = "json-view", type = "string", description = "When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations", displayName = "Json View"),
                    @YamlProperty(name = "library", type = "enum:ApacheAvro,Jackson", defaultValue = "ApacheAvro", description = "Which Avro library to use.", displayName = "Library"),
                    @YamlProperty(name = "module-class-names", type = "string", description = "To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.", displayName = "Module Class Names"),
                    @YamlProperty(name = "module-refs", type = "string", description = "To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.", displayName = "Module Refs"),
                    @YamlProperty(name = "object-mapper", type = "string", description = "Lookup and use the existing ObjectMapper with the given id when using Jackson.", displayName = "Object Mapper"),
                    @YamlProperty(name = "schema-resolver", type = "string", description = "Optional schema resolver used to lookup schemas for the data in transit.", displayName = "Schema Resolver"),
                    @YamlProperty(name = "timezone", type = "string", description = "If set then Jackson will use the Timezone when marshalling/unmarshalling.", displayName = "Timezone"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class name of the java type to use when unmarshalling", displayName = "Unmarshal Type"),
                    @YamlProperty(name = "use-default-object-mapper", type = "boolean", description = "Whether to lookup and use default Jackson ObjectMapper from the registry.", displayName = "Use Default Object Mapper"),
                    @YamlProperty(name = "use-list", type = "boolean", description = "To unmarshal to a List of Map or a List of Pojo.", displayName = "Use List")
            }
    )
    public static class AvroDataFormatDeserializer extends YamlDeserializerBase<AvroDataFormat> {
        public AvroDataFormatDeserializer() {
            super(AvroDataFormat.class);
        }

        @Override
        protected AvroDataFormat newInstance() {
            return new AvroDataFormat();
        }

        @Override
        protected AvroDataFormat newInstance(String value) {
            return new AvroDataFormat(value);
        }

        @Override
        protected boolean setProperty(AvroDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-jms-type": {
                    String val = asText(node);
                    target.setAllowJmsType(val);
                    break;
                }
                case "allow-unmarshall-type": {
                    String val = asText(node);
                    target.setAllowUnmarshallType(val);
                    break;
                }
                case "auto-discover-object-mapper": {
                    String val = asText(node);
                    target.setAutoDiscoverObjectMapper(val);
                    break;
                }
                case "auto-discover-schema-resolver": {
                    String val = asText(node);
                    target.setAutoDiscoverSchemaResolver(val);
                    break;
                }
                case "collection-type": {
                    String val = asText(node);
                    target.setCollectionTypeName(val);
                    break;
                }
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "disable-features": {
                    String val = asText(node);
                    target.setDisableFeatures(val);
                    break;
                }
                case "enable-features": {
                    String val = asText(node);
                    target.setEnableFeatures(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "include": {
                    String val = asText(node);
                    target.setInclude(val);
                    break;
                }
                case "instance-class-name": {
                    String val = asText(node);
                    target.setInstanceClassName(val);
                    break;
                }
                case "json-view": {
                    String val = asText(node);
                    target.setJsonViewTypeName(val);
                    break;
                }
                case "library": {
                    target.setLibrary(asEnum(node, org.apache.camel.model.dataformat.AvroLibrary.class));
                    break;
                }
                case "module-class-names": {
                    String val = asText(node);
                    target.setModuleClassNames(val);
                    break;
                }
                case "module-refs": {
                    String val = asText(node);
                    target.setModuleRefs(val);
                    break;
                }
                case "object-mapper": {
                    String val = asText(node);
                    target.setObjectMapper(val);
                    break;
                }
                case "schema-resolver": {
                    String val = asText(node);
                    target.setSchemaResolver(val);
                    break;
                }
                case "timezone": {
                    String val = asText(node);
                    target.setTimezone(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                case "use-default-object-mapper": {
                    String val = asText(node);
                    target.setUseDefaultObjectMapper(val);
                    break;
                }
                case "use-list": {
                    String val = asText(node);
                    target.setUseList(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "barcode",
            types = org.apache.camel.model.dataformat.BarcodeDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Barcode",
            description = "Transform strings to various 1D/2D barcode bitmap formats and back.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "barcode-format", type = "string", description = "Barcode format such as QR-Code", displayName = "Barcode Format"),
                    @YamlProperty(name = "height", type = "number", description = "Height of the barcode", displayName = "Height"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "image-type", type = "string", description = "Image type of the barcode such as png", displayName = "Image Type"),
                    @YamlProperty(name = "width", type = "number", description = "Width of the barcode", displayName = "Width")
            }
    )
    public static class BarcodeDataFormatDeserializer extends YamlDeserializerBase<BarcodeDataFormat> {
        public BarcodeDataFormatDeserializer() {
            super(BarcodeDataFormat.class);
        }

        @Override
        protected BarcodeDataFormat newInstance() {
            return new BarcodeDataFormat();
        }

        @Override
        protected boolean setProperty(BarcodeDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "barcode-format": {
                    String val = asText(node);
                    target.setBarcodeFormat(val);
                    break;
                }
                case "height": {
                    String val = asText(node);
                    target.setHeight(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "image-type": {
                    String val = asText(node);
                    target.setImageType(val);
                    break;
                }
                case "width": {
                    String val = asText(node);
                    target.setWidth(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "base64",
            types = org.apache.camel.model.dataformat.Base64DataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Base64",
            description = "Encode and decode data using Base64.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "line-length", type = "number", defaultValue = "76", description = "To specific a maximum line length for the encoded data. By default 76 is used.", displayName = "Line Length"),
                    @YamlProperty(name = "line-separator", type = "string", description = "The line separators to use. Uses new line characters (CRLF) by default.", displayName = "Line Separator"),
                    @YamlProperty(name = "url-safe", type = "boolean", description = "Instead of emitting '' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode operations. Decoding seamlessly handles both modes. Is by default false.", displayName = "Url Safe")
            }
    )
    public static class Base64DataFormatDeserializer extends YamlDeserializerBase<Base64DataFormat> {
        public Base64DataFormatDeserializer() {
            super(Base64DataFormat.class);
        }

        @Override
        protected Base64DataFormat newInstance() {
            return new Base64DataFormat();
        }

        @Override
        protected boolean setProperty(Base64DataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "line-length": {
                    String val = asText(node);
                    target.setLineLength(val);
                    break;
                }
                case "line-separator": {
                    String val = asText(node);
                    target.setLineSeparator(val);
                    break;
                }
                case "url-safe": {
                    String val = asText(node);
                    target.setUrlSafe(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "basic-auth",
                    "basicAuth"
            },
            types = org.apache.camel.model.rest.BasicAuthDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Basic Auth",
            description = "Rest security basic auth definition",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "A short description for security scheme.", displayName = "Description"),
                    @YamlProperty(name = "key", type = "string", required = true, description = "Key used to refer to this security definition", displayName = "Key")
            }
    )
    public static class BasicAuthDefinitionDeserializer extends YamlDeserializerBase<BasicAuthDefinition> {
        public BasicAuthDefinitionDeserializer() {
            super(BasicAuthDefinition.class);
        }

        @Override
        protected BasicAuthDefinition newInstance() {
            return new BasicAuthDefinition();
        }

        @Override
        protected boolean setProperty(BasicAuthDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "batch-config",
            types = org.apache.camel.model.config.BatchResequencerConfig.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Batch-config",
            description = "Configures batch-processing resequence eip.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-duplicates", type = "boolean", description = "Whether to allow duplicates.", displayName = "Allow Duplicates"),
                    @YamlProperty(name = "batch-size", type = "number", defaultValue = "100", description = "Sets the size of the batch to be re-ordered. The default size is 100.", displayName = "Batch Size"),
                    @YamlProperty(name = "batch-timeout", type = "string", defaultValue = "1000", description = "Sets the timeout for collecting elements to be re-ordered. The default timeout is 1000 msec.", displayName = "Batch Timeout"),
                    @YamlProperty(name = "ignore-invalid-exchanges", type = "boolean", description = "Whether to ignore invalid exchanges", displayName = "Ignore Invalid Exchanges"),
                    @YamlProperty(name = "reverse", type = "boolean", description = "Whether to reverse the ordering.", displayName = "Reverse")
            }
    )
    public static class BatchResequencerConfigDeserializer extends YamlDeserializerBase<BatchResequencerConfig> {
        public BatchResequencerConfigDeserializer() {
            super(BatchResequencerConfig.class);
        }

        @Override
        protected BatchResequencerConfig newInstance() {
            return new BatchResequencerConfig();
        }

        @Override
        protected boolean setProperty(BatchResequencerConfig target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-duplicates": {
                    String val = asText(node);
                    target.setAllowDuplicates(val);
                    break;
                }
                case "batch-size": {
                    String val = asText(node);
                    target.setBatchSize(val);
                    break;
                }
                case "batch-timeout": {
                    String val = asText(node);
                    target.setBatchTimeout(val);
                    break;
                }
                case "ignore-invalid-exchanges": {
                    String val = asText(node);
                    target.setIgnoreInvalidExchanges(val);
                    break;
                }
                case "reverse": {
                    String val = asText(node);
                    target.setReverse(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.app.BeanConstructorDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "index", type = "number"),
                    @YamlProperty(name = "value", type = "string", required = true)
            }
    )
    public static class BeanConstructorDefinitionDeserializer extends YamlDeserializerBase<BeanConstructorDefinition> {
        public BeanConstructorDefinitionDeserializer() {
            super(BeanConstructorDefinition.class);
        }

        @Override
        protected BeanConstructorDefinition newInstance() {
            return new BeanConstructorDefinition();
        }

        @Override
        protected boolean setProperty(BeanConstructorDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "index": {
                    String val = asText(node);
                    target.setIndex(java.lang.Integer.valueOf(val));
                    break;
                }
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.app.BeanConstructorsDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = @YamlProperty(name = "constructor", type = "array:org.apache.camel.model.app.BeanConstructorDefinition")
    )
    public static class BeanConstructorsDefinitionDeserializer extends YamlDeserializerBase<BeanConstructorsDefinition> {
        public BeanConstructorsDefinitionDeserializer() {
            super(BeanConstructorsDefinition.class);
        }

        @Override
        protected BeanConstructorsDefinition newInstance() {
            return new BeanConstructorsDefinition();
        }

        @Override
        protected boolean setProperty(BeanConstructorsDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "constructor": {
                    java.util.List<org.apache.camel.model.app.BeanConstructorDefinition> val = asFlatList(node, org.apache.camel.model.app.BeanConstructorDefinition.class);
                    target.setConstructors(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "bean",
            inline = true,
            types = org.apache.camel.model.BeanDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Bean",
            description = "Calls a Java bean",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "bean-type", type = "string", description = "Sets the class name (fully qualified) of the bean to use", displayName = "Bean Type"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "method", type = "string", description = "Sets the method name on the bean to use", displayName = "Method"),
                    @YamlProperty(name = "ref", type = "string", description = "Sets a reference to an exiting bean to use, which is looked up from the registry", displayName = "Ref"),
                    @YamlProperty(name = "scope", type = "enum:Singleton,Request,Prototype", defaultValue = "Singleton", description = "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. So when using prototype scope then this depends on the bean registry implementation.", displayName = "Scope")
            }
    )
    public static class BeanDefinitionDeserializer extends YamlDeserializerBase<BeanDefinition> {
        public BeanDefinitionDeserializer() {
            super(BeanDefinition.class);
        }

        @Override
        protected BeanDefinition newInstance() {
            return new BeanDefinition();
        }

        @Override
        protected BeanDefinition newInstance(String value) {
            return new BeanDefinition(value);
        }

        @Override
        protected boolean setProperty(BeanDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "bean-type": {
                    String val = asText(node);
                    target.setBeanType(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "method": {
                    String val = asText(node);
                    target.setMethod(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "scope": {
                    String val = asText(node);
                    target.setScope(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.app.BeanPropertiesDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = @YamlProperty(name = "property", type = "array:org.apache.camel.model.app.BeanPropertyDefinition")
    )
    public static class BeanPropertiesDefinitionDeserializer extends YamlDeserializerBase<BeanPropertiesDefinition> {
        public BeanPropertiesDefinitionDeserializer() {
            super(BeanPropertiesDefinition.class);
        }

        @Override
        protected BeanPropertiesDefinition newInstance() {
            return new BeanPropertiesDefinition();
        }

        @Override
        protected boolean setProperty(BeanPropertiesDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "property": {
                    java.util.List<org.apache.camel.model.app.BeanPropertyDefinition> val = asFlatList(node, org.apache.camel.model.app.BeanPropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.app.BeanPropertyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "key", type = "string"),
                    @YamlProperty(name = "properties", type = "object:org.apache.camel.model.app.BeanPropertiesDefinition"),
                    @YamlProperty(name = "value", type = "string")
            }
    )
    public static class BeanPropertyDefinitionDeserializer extends YamlDeserializerBase<BeanPropertyDefinition> {
        public BeanPropertyDefinitionDeserializer() {
            super(BeanPropertyDefinition.class);
        }

        @Override
        protected BeanPropertyDefinition newInstance() {
            return new BeanPropertyDefinition();
        }

        @Override
        protected boolean setProperty(BeanPropertyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "properties": {
                    org.apache.camel.model.app.BeanPropertiesDefinition val = asType(node, org.apache.camel.model.app.BeanPropertiesDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "beans",
            types = org.apache.camel.model.app.BeansDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Beans",
            description = "A grouping POJO (and related XML root element) that's historically associated with entire application (or its distinguished fragment). This class is not meant to be used with Camel Java DSL, but it's needed to generate XML Schema and MX parser methods.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "bean", type = "array:org.apache.camel.model.app.RegistryBeanDefinition", displayName = "Bean"),
                    @YamlProperty(name = "component-scan", type = "array:org.apache.camel.model.app.ComponentScanDefinition"),
                    @YamlProperty(name = "rest", type = "array:org.apache.camel.model.rest.RestDefinition", displayName = "Rest"),
                    @YamlProperty(name = "rest-configuration", type = "array:org.apache.camel.model.rest.RestConfigurationDefinition", displayName = "Rest Configuration"),
                    @YamlProperty(name = "route", type = "array:org.apache.camel.model.RouteDefinition", displayName = "Route"),
                    @YamlProperty(name = "route-configuration", type = "array:org.apache.camel.model.RouteConfigurationDefinition", displayName = "Route Configuration"),
                    @YamlProperty(name = "route-template", type = "array:org.apache.camel.model.RouteTemplateDefinition", displayName = "Route Template"),
                    @YamlProperty(name = "templated-route", type = "array:org.apache.camel.model.TemplatedRouteDefinition", displayName = "Templated Route")
            }
    )
    public static class BeansDefinitionDeserializer extends YamlDeserializerBase<BeansDefinition> {
        public BeansDefinitionDeserializer() {
            super(BeansDefinition.class);
        }

        @Override
        protected BeansDefinition newInstance() {
            return new BeansDefinition();
        }

        @Override
        protected boolean setProperty(BeansDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "bean": {
                    java.util.List<org.apache.camel.model.app.RegistryBeanDefinition> val = asFlatList(node, org.apache.camel.model.app.RegistryBeanDefinition.class);
                    target.setBeans(val);
                    break;
                }
                case "component-scan": {
                    java.util.List<org.apache.camel.model.app.ComponentScanDefinition> val = asFlatList(node, org.apache.camel.model.app.ComponentScanDefinition.class);
                    target.setComponentScanning(val);
                    break;
                }
                case "rest-configuration": {
                    java.util.List<org.apache.camel.model.rest.RestConfigurationDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestConfigurationDefinition.class);
                    target.setRestConfigurations(val);
                    break;
                }
                case "rest": {
                    java.util.List<org.apache.camel.model.rest.RestDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestDefinition.class);
                    target.setRests(val);
                    break;
                }
                case "route-configuration": {
                    java.util.List<org.apache.camel.model.RouteConfigurationDefinition> val = asFlatList(node, org.apache.camel.model.RouteConfigurationDefinition.class);
                    target.setRouteConfigurations(val);
                    break;
                }
                case "route-template": {
                    java.util.List<org.apache.camel.model.RouteTemplateDefinition> val = asFlatList(node, org.apache.camel.model.RouteTemplateDefinition.class);
                    target.setRouteTemplates(val);
                    break;
                }
                case "route": {
                    java.util.List<org.apache.camel.model.RouteDefinition> val = asFlatList(node, org.apache.camel.model.RouteDefinition.class);
                    target.setRoutes(val);
                    break;
                }
                case "templated-route": {
                    java.util.List<org.apache.camel.model.TemplatedRouteDefinition> val = asFlatList(node, org.apache.camel.model.TemplatedRouteDefinition.class);
                    target.setTemplatedRoutes(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "bearer-token",
                    "bearerToken"
            },
            types = org.apache.camel.model.rest.BearerTokenDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Bearer Token",
            description = "Rest security bearer token authentication definition",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "A short description for security scheme.", displayName = "Description"),
                    @YamlProperty(name = "format", type = "string", description = "A hint to the client to identify how the bearer token is formatted.", displayName = "Format"),
                    @YamlProperty(name = "key", type = "string", required = true, description = "Key used to refer to this security definition", displayName = "Key")
            }
    )
    public static class BearerTokenDefinitionDeserializer extends YamlDeserializerBase<BearerTokenDefinition> {
        public BearerTokenDefinitionDeserializer() {
            super(BearerTokenDefinition.class);
        }

        @Override
        protected BearerTokenDefinition newInstance() {
            return new BearerTokenDefinition();
        }

        @Override
        protected boolean setProperty(BearerTokenDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "format": {
                    String val = asText(node);
                    target.setFormat(val);
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "bindy",
            types = org.apache.camel.model.dataformat.BindyDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Bindy",
            description = "Marshal and unmarshal Java beans from and to flat payloads (such as CSV, delimited, fixed length formats, or FIX messages).",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-empty-stream", type = "boolean", description = "Whether to allow empty streams in the unmarshal process. If true, no exception will be thrown when a body without records is provided.", displayName = "Allow Empty Stream"),
                    @YamlProperty(name = "class-type", type = "string", description = "Name of model class to use.", displayName = "Class Type"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "locale", type = "string", description = "To configure a default locale to use, such as us for united states. To use the JVM platform default locale then use the name default", displayName = "Locale"),
                    @YamlProperty(name = "type", type = "enum:Csv,Fixed,KeyValue", description = "Whether to use Csv, Fixed, or KeyValue.", displayName = "Type"),
                    @YamlProperty(name = "unwrap-single-instance", type = "boolean", description = "When unmarshalling should a single instance be unwrapped and returned instead of wrapped in a java.util.List.", displayName = "Unwrap Single Instance")
            }
    )
    public static class BindyDataFormatDeserializer extends YamlDeserializerBase<BindyDataFormat> {
        public BindyDataFormatDeserializer() {
            super(BindyDataFormat.class);
        }

        @Override
        protected BindyDataFormat newInstance() {
            return new BindyDataFormat();
        }

        @Override
        protected boolean setProperty(BindyDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-empty-stream": {
                    String val = asText(node);
                    target.setAllowEmptyStream(val);
                    break;
                }
                case "class-type": {
                    String val = asText(node);
                    target.setClassTypeAsString(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "locale": {
                    String val = asText(node);
                    target.setLocale(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "unwrap-single-instance": {
                    String val = asText(node);
                    target.setUnwrapSingleInstance(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "blacklist-service-filter",
                    "blacklistServiceFilter"
            },
            types = org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Blacklist Service Filter",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "servers", type = "array:string", description = "Sets the server blacklist. Each entry can be a list of servers separated by comma in the format: servicehost:port,servicehost2:port,servicehost3:port", displayName = "Servers")
            }
    )
    public static class BlacklistServiceCallServiceFilterConfigurationDeserializer extends YamlDeserializerBase<BlacklistServiceCallServiceFilterConfiguration> {
        public BlacklistServiceCallServiceFilterConfigurationDeserializer() {
            super(BlacklistServiceCallServiceFilterConfiguration.class);
        }

        @Override
        protected BlacklistServiceCallServiceFilterConfiguration newInstance() {
            return new BlacklistServiceCallServiceFilterConfiguration();
        }

        @Override
        protected boolean setProperty(BlacklistServiceCallServiceFilterConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "servers": {
                    java.util.List<String> val = asStringList(node);
                    target.setServers(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "cbor",
            types = org.apache.camel.model.dataformat.CBORDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "CBOR",
            description = "Unmarshal a CBOR payload to POJO and back.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-jms-type", type = "boolean", description = "Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.", displayName = "Allow Jms Type"),
                    @YamlProperty(name = "allow-unmarshall-type", type = "boolean", description = "If enabled then Jackson CBOR is allowed to attempt to use the CamelCBORUnmarshalType header during the unmarshalling. This should only be enabled when desired to be used.", displayName = "Allow Unmarshall Type"),
                    @YamlProperty(name = "collection-type", type = "string", description = "Refers to a custom collection type to lookup in the registry to use. This option should rarely be used, but allows to use different collection types than java.util.Collection based as default.", displayName = "Collection Type"),
                    @YamlProperty(name = "disable-features", type = "string", description = "Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Disable Features"),
                    @YamlProperty(name = "enable-features", type = "string", description = "Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Enable Features"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "object-mapper", type = "string", description = "Lookup and use the existing CBOR ObjectMapper with the given id when using Jackson.", displayName = "Object Mapper"),
                    @YamlProperty(name = "pretty-print", type = "boolean", description = "To enable pretty printing output nicely formatted. Is by default false.", displayName = "Pretty Print"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class name of the java type to use when unmarshalling", displayName = "Unmarshal Type"),
                    @YamlProperty(name = "use-default-object-mapper", type = "boolean", description = "Whether to lookup and use default Jackson CBOR ObjectMapper from the registry.", displayName = "Use Default Object Mapper"),
                    @YamlProperty(name = "use-list", type = "boolean", description = "To unmarshal to a List of Map or a List of Pojo.", displayName = "Use List")
            }
    )
    public static class CBORDataFormatDeserializer extends YamlDeserializerBase<CBORDataFormat> {
        public CBORDataFormatDeserializer() {
            super(CBORDataFormat.class);
        }

        @Override
        protected CBORDataFormat newInstance() {
            return new CBORDataFormat();
        }

        @Override
        protected boolean setProperty(CBORDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-jms-type": {
                    String val = asText(node);
                    target.setAllowJmsType(val);
                    break;
                }
                case "allow-unmarshall-type": {
                    String val = asText(node);
                    target.setAllowUnmarshallType(val);
                    break;
                }
                case "collection-type": {
                    String val = asText(node);
                    target.setCollectionTypeName(val);
                    break;
                }
                case "disable-features": {
                    String val = asText(node);
                    target.setDisableFeatures(val);
                    break;
                }
                case "enable-features": {
                    String val = asText(node);
                    target.setEnableFeatures(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "object-mapper": {
                    String val = asText(node);
                    target.setObjectMapper(val);
                    break;
                }
                case "pretty-print": {
                    String val = asText(node);
                    target.setPrettyPrint(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                case "use-default-object-mapper": {
                    String val = asText(node);
                    target.setUseDefaultObjectMapper(val);
                    break;
                }
                case "use-list": {
                    String val = asText(node);
                    target.setUseList(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "csimple",
            inline = true,
            types = org.apache.camel.model.language.CSimpleExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "CSimple",
            description = "Evaluate a compiled simple expression.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class CSimpleExpressionDeserializer extends YamlDeserializerBase<CSimpleExpression> {
        public CSimpleExpressionDeserializer() {
            super(CSimpleExpression.class);
        }

        @Override
        protected CSimpleExpression newInstance() {
            return new CSimpleExpression();
        }

        @Override
        protected CSimpleExpression newInstance(String value) {
            return new CSimpleExpression(value);
        }

        @Override
        protected boolean setProperty(CSimpleExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "caching-service-discovery",
                    "cachingServiceDiscovery"
            },
            types = org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Caching Service Discovery",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "combined-service-discovery", type = "object:org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "consul-service-discovery", type = "object:org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "dns-service-discovery", type = "object:org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "kubernetes-service-discovery", type = "object:org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "static-service-discovery", type = "object:org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "timeout", type = "number", defaultValue = "60", description = "Set the time the services will be retained.", displayName = "Timeout"),
                    @YamlProperty(name = "units", type = "enum:NANOSECONDS,MICROSECONDS,MILLISECONDS,SECONDS,MINUTES,HOURS,DAYS", defaultValue = "SECONDS", description = "Set the time unit for the timeout.", displayName = "Units")
            }
    )
    public static class CachingServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<CachingServiceCallServiceDiscoveryConfiguration> {
        public CachingServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(CachingServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected CachingServiceCallServiceDiscoveryConfiguration newInstance() {
            return new CachingServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(CachingServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "service-discovery-configuration": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "consul-service-discovery": {
                    org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "dns-service-discovery": {
                    org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "kubernetes-service-discovery": {
                    org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "combined-service-discovery": {
                    org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "static-service-discovery": {
                    org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "timeout": {
                    String val = asText(node);
                    target.setTimeout(val);
                    break;
                }
                case "units": {
                    String val = asText(node);
                    target.setUnits(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "do-catch",
                    "doCatch"
            },
            types = org.apache.camel.model.CatchDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Do Catch",
            description = "Catches exceptions as part of a try, catch, finally block",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "exception", type = "array:string", description = "The exception(s) to catch.", displayName = "Exception"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "on-when", type = "object:org.apache.camel.model.WhenDefinition", description = "Sets an additional predicate that should be true before the onCatch is triggered. To be used for fine grained controlling whether a thrown exception should be intercepted by this exception type or not.", displayName = "On When"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class CatchDefinitionDeserializer extends YamlDeserializerBase<CatchDefinition> {
        public CatchDefinitionDeserializer() {
            super(CatchDefinition.class);
        }

        @Override
        protected CatchDefinition newInstance() {
            return new CatchDefinition();
        }

        @Override
        protected boolean setProperty(CatchDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "exception": {
                    java.util.List<String> val = asStringList(node);
                    target.setExceptions(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "on-when": {
                    org.apache.camel.model.WhenDefinition val = asType(node, org.apache.camel.model.WhenDefinition.class);
                    target.setOnWhen(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "choice",
            types = org.apache.camel.model.ChoiceDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Choice",
            description = "Route messages based on a series of predicates",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "otherwise", type = "object:org.apache.camel.model.OtherwiseDefinition", description = "Sets the otherwise node", displayName = "Otherwise"),
                    @YamlProperty(name = "precondition", type = "boolean", description = "Indicates whether this Choice EIP is in precondition mode or not. If so its branches (when/otherwise) are evaluated during startup to keep at runtime only the branch that matched.", displayName = "Precondition"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "when", type = "array:org.apache.camel.model.WhenDefinition", description = "Sets the when nodes", displayName = "When")
            }
    )
    public static class ChoiceDefinitionDeserializer extends YamlDeserializerBase<ChoiceDefinition> {
        public ChoiceDefinitionDeserializer() {
            super(ChoiceDefinition.class);
        }

        @Override
        protected ChoiceDefinition newInstance() {
            return new ChoiceDefinition();
        }

        @Override
        protected boolean setProperty(ChoiceDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "otherwise": {
                    org.apache.camel.model.OtherwiseDefinition val = asType(node, org.apache.camel.model.OtherwiseDefinition.class);
                    target.setOtherwise(val);
                    break;
                }
                case "precondition": {
                    String val = asText(node);
                    target.setPrecondition(val);
                    break;
                }
                case "when": {
                    java.util.List<org.apache.camel.model.WhenDefinition> val = asFlatList(node, org.apache.camel.model.WhenDefinition.class);
                    target.setWhenClauses(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "circuit-breaker",
                    "circuitBreaker"
            },
            types = org.apache.camel.model.CircuitBreakerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Circuit Breaker",
            description = "Route messages in a fault tolerance way using Circuit Breaker",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "configuration", type = "string", description = "Refers to a circuit breaker configuration (such as resillience4j, or microprofile-fault-tolerance) to use for configuring the circuit breaker EIP.", displayName = "Configuration"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "fault-tolerance-configuration", type = "object:org.apache.camel.model.FaultToleranceConfigurationDefinition", description = "Configures the circuit breaker to use MicroProfile Fault Tolerance with the given configuration.", displayName = "Fault Tolerance Configuration"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "on-fallback", type = "object:org.apache.camel.model.OnFallbackDefinition", description = "The fallback route path to execute that does not go over the network. This should be a static or cached result that can immediately be returned upon failure. If the fallback requires network connection then use onFallbackViaNetwork() .", displayName = "On Fallback"),
                    @YamlProperty(name = "resilience4j-configuration", type = "object:org.apache.camel.model.Resilience4jConfigurationDefinition", description = "Configures the circuit breaker to use Resilience4j with the given configuration.", displayName = "Resilience4j Configuration"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class CircuitBreakerDefinitionDeserializer extends YamlDeserializerBase<CircuitBreakerDefinition> {
        public CircuitBreakerDefinitionDeserializer() {
            super(CircuitBreakerDefinition.class);
        }

        @Override
        protected CircuitBreakerDefinition newInstance() {
            return new CircuitBreakerDefinition();
        }

        @Override
        protected boolean setProperty(CircuitBreakerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "configuration": {
                    String val = asText(node);
                    target.setConfiguration(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "fault-tolerance-configuration": {
                    org.apache.camel.model.FaultToleranceConfigurationDefinition val = asType(node, org.apache.camel.model.FaultToleranceConfigurationDefinition.class);
                    target.setFaultToleranceConfiguration(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "on-fallback": {
                    org.apache.camel.model.OnFallbackDefinition val = asType(node, org.apache.camel.model.OnFallbackDefinition.class);
                    target.setOnFallback(val);
                    break;
                }
                case "resilience4j-configuration": {
                    org.apache.camel.model.Resilience4jConfigurationDefinition val = asType(node, org.apache.camel.model.Resilience4jConfigurationDefinition.class);
                    target.setResilience4jConfiguration(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "claim-check",
                    "claimCheck"
            },
            types = org.apache.camel.model.ClaimCheckDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Claim Check",
            description = "The Claim Check EIP allows you to replace message content with a claim check (a unique key), which can be used to retrieve the message content at a later time.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "aggregation-strategy", type = "string", description = "To use a custom AggregationStrategy instead of the default implementation. Notice you cannot use both custom aggregation strategy and configure data at the same time.", displayName = "Aggregation Strategy"),
                    @YamlProperty(name = "aggregation-strategy-method-name", type = "string", description = "This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Name"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "filter", type = "string", description = "Specify a filter to control what data gets merged data back from the claim check repository. The following syntax is supported: body - to aggregate the message body attachments - to aggregate all the message attachments headers - to aggregate all the message headers header:pattern - to aggregate all the message headers that matches the pattern. The following pattern rules are applied in this order: exact match, returns true wildcard match (pattern ends with a and the name starts with the pattern), returns true regular expression match, returns true otherwise returns false You can specify multiple rules separated by comma. For example, the following includes the message body and all headers starting with foo: body,header:foo. The syntax supports the following prefixes which can be used to specify include,exclude, or remove - to include (which is the default mode) - - to exclude (exclude takes precedence over include) -- - to remove (remove takes precedence) For example to exclude a header name foo, and remove all headers starting with bar, -header:foo,--headers:bar Note you cannot have both include and exclude header:pattern at the same time.", displayName = "Filter"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "key", type = "string", description = "To use a specific key for claim check id (for dynamic keys use simple language syntax as the key).", displayName = "Key"),
                    @YamlProperty(name = "operation", type = "enum:Get,GetAndRemove,Set,Push,Pop", description = "The claim check operation to use. The following operations are supported: Get - Gets (does not remove) the claim check by the given key. GetAndRemove - Gets and removes the claim check by the given key. Set - Sets a new (will override if key already exists) claim check with the given key. Push - Sets a new claim check on the stack (does not use key). Pop - Gets the latest claim check from the stack (does not use key).", displayName = "Operation")
            }
    )
    public static class ClaimCheckDefinitionDeserializer extends YamlDeserializerBase<ClaimCheckDefinition> {
        public ClaimCheckDefinitionDeserializer() {
            super(ClaimCheckDefinition.class);
        }

        @Override
        protected ClaimCheckDefinition newInstance() {
            return new ClaimCheckDefinition();
        }

        @Override
        protected boolean setProperty(ClaimCheckDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "aggregation-strategy": {
                    String val = asText(node);
                    target.setAggregationStrategy(val);
                    break;
                }
                case "aggregation-strategy-method-name": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodName(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "filter": {
                    String val = asText(node);
                    target.setFilter(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "operation": {
                    String val = asText(node);
                    target.setOperation(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "combined-service-discovery",
                    "combinedServiceDiscovery"
            },
            types = org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Combined Service Discovery",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "caching-service-discovery", type = "object:org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration"),
                    @YamlProperty(name = "consul-service-discovery", type = "object:org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration"),
                    @YamlProperty(name = "dns-service-discovery", type = "object:org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "kubernetes-service-discovery", type = "object:org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "static-service-discovery", type = "object:org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration")
            }
    )
    public static class CombinedServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<CombinedServiceCallServiceDiscoveryConfiguration> {
        public CombinedServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(CombinedServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected CombinedServiceCallServiceDiscoveryConfiguration newInstance() {
            return new CombinedServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(CombinedServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "service-discovery-configurations": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "consul-service-discovery": {
                    org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceDiscoveryConfiguration> existing = target.getServiceDiscoveryConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceDiscoveryConfigurations(existing);
                    break;
                }
                case "dns-service-discovery": {
                    org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceDiscoveryConfiguration> existing = target.getServiceDiscoveryConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceDiscoveryConfigurations(existing);
                    break;
                }
                case "kubernetes-service-discovery": {
                    org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceDiscoveryConfiguration> existing = target.getServiceDiscoveryConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceDiscoveryConfigurations(existing);
                    break;
                }
                case "static-service-discovery": {
                    org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceDiscoveryConfiguration> existing = target.getServiceDiscoveryConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceDiscoveryConfigurations(existing);
                    break;
                }
                case "caching-service-discovery": {
                    org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceDiscoveryConfiguration> existing = target.getServiceDiscoveryConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceDiscoveryConfigurations(existing);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "combined-service-filter",
                    "combinedServiceFilter"
            },
            types = org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Combined Service Filter",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "blacklist-service-filter", type = "object:org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration"),
                    @YamlProperty(name = "custom-service-filter", type = "object:org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration"),
                    @YamlProperty(name = "healthy-service-filter", type = "object:org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "pass-through-service-filter", type = "object:org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class CombinedServiceCallServiceFilterConfigurationDeserializer extends YamlDeserializerBase<CombinedServiceCallServiceFilterConfiguration> {
        public CombinedServiceCallServiceFilterConfigurationDeserializer() {
            super(CombinedServiceCallServiceFilterConfiguration.class);
        }

        @Override
        protected CombinedServiceCallServiceFilterConfiguration newInstance() {
            return new CombinedServiceCallServiceFilterConfiguration();
        }

        @Override
        protected boolean setProperty(CombinedServiceCallServiceFilterConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "service-filter-configurations": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "blacklist-service-filter": {
                    org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceFilterConfiguration> existing = target.getServiceFilterConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceFilterConfigurations(existing);
                    break;
                }
                case "custom-service-filter": {
                    org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceFilterConfiguration> existing = target.getServiceFilterConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceFilterConfigurations(existing);
                    break;
                }
                case "healthy-service-filter": {
                    org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceFilterConfiguration> existing = target.getServiceFilterConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceFilterConfigurations(existing);
                    break;
                }
                case "pass-through-service-filter": {
                    org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration.class);
                    java.util.List<org.apache.camel.model.cloud.ServiceCallServiceFilterConfiguration> existing = target.getServiceFilterConfigurations();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setServiceFilterConfigurations(existing);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.app.ComponentScanDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = @YamlProperty(name = "base-package", type = "string")
    )
    public static class ComponentScanDefinitionDeserializer extends YamlDeserializerBase<ComponentScanDefinition> {
        public ComponentScanDefinitionDeserializer() {
            super(ComponentScanDefinition.class);
        }

        @Override
        protected ComponentScanDefinition newInstance() {
            return new ComponentScanDefinition();
        }

        @Override
        protected boolean setProperty(ComponentScanDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "base-package": {
                    String val = asText(node);
                    target.setBasePackage(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "constant",
            inline = true,
            types = org.apache.camel.model.language.ConstantExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Constant",
            description = "A fixed value set only once during the route startup.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class ConstantExpressionDeserializer extends YamlDeserializerBase<ConstantExpression> {
        public ConstantExpressionDeserializer() {
            super(ConstantExpression.class);
        }

        @Override
        protected ConstantExpression newInstance() {
            return new ConstantExpression();
        }

        @Override
        protected ConstantExpression newInstance(String value) {
            return new ConstantExpression(value);
        }

        @Override
        protected boolean setProperty(ConstantExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "consul-service-discovery",
                    "consulServiceDiscovery"
            },
            types = org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Consul Service Discovery",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "acl-token", type = "string", description = "Sets the ACL token to be used with Consul", displayName = "Acl Token"),
                    @YamlProperty(name = "block-seconds", type = "number", defaultValue = "10", description = "The seconds to wait for a watch event, default 10 seconds", displayName = "Block Seconds"),
                    @YamlProperty(name = "connect-timeout-millis", type = "number", description = "Connect timeout for OkHttpClient", displayName = "Connect Timeout Millis"),
                    @YamlProperty(name = "datacenter", type = "string", description = "The data center", displayName = "Datacenter"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "password", type = "string", description = "Sets the password to be used for basic authentication", displayName = "Password"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "read-timeout-millis", type = "number", description = "Read timeout for OkHttpClient", displayName = "Read Timeout Millis"),
                    @YamlProperty(name = "url", type = "string", description = "The Consul agent URL", displayName = "Url"),
                    @YamlProperty(name = "user-name", type = "string", description = "Sets the username to be used for basic authentication", displayName = "User Name"),
                    @YamlProperty(name = "write-timeout-millis", type = "number", description = "Write timeout for OkHttpClient", displayName = "Write Timeout Millis")
            }
    )
    public static class ConsulServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<ConsulServiceCallServiceDiscoveryConfiguration> {
        public ConsulServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(ConsulServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected ConsulServiceCallServiceDiscoveryConfiguration newInstance() {
            return new ConsulServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(ConsulServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "acl-token": {
                    String val = asText(node);
                    target.setAclToken(val);
                    break;
                }
                case "block-seconds": {
                    String val = asText(node);
                    target.setBlockSeconds(val);
                    break;
                }
                case "connect-timeout-millis": {
                    String val = asText(node);
                    target.setConnectTimeoutMillis(val);
                    break;
                }
                case "datacenter": {
                    String val = asText(node);
                    target.setDatacenter(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "password": {
                    String val = asText(node);
                    target.setPassword(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "read-timeout-millis": {
                    String val = asText(node);
                    target.setReadTimeoutMillis(val);
                    break;
                }
                case "url": {
                    String val = asText(node);
                    target.setUrl(val);
                    break;
                }
                case "user-name": {
                    String val = asText(node);
                    target.setUserName(val);
                    break;
                }
                case "write-timeout-millis": {
                    String val = asText(node);
                    target.setWriteTimeoutMillis(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "context-scan",
                    "contextScan"
            },
            types = org.apache.camel.model.ContextScanDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Context Scan",
            description = "Scans for Java org.apache.camel.builder.RouteBuilder instances in the context org.apache.camel.spi.Registry .",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "excludes", type = "array:string", description = "Exclude finding route builder from these java package names.", displayName = "Excludes"),
                    @YamlProperty(name = "include-non-singletons", type = "boolean", description = "Whether to include non-singleton beans (prototypes) By default only singleton beans is included in the context scan", displayName = "Include Non Singletons"),
                    @YamlProperty(name = "includes", type = "array:string", description = "Include finding route builder from these java package names.", displayName = "Includes")
            }
    )
    public static class ContextScanDefinitionDeserializer extends YamlDeserializerBase<ContextScanDefinition> {
        public ContextScanDefinitionDeserializer() {
            super(ContextScanDefinition.class);
        }

        @Override
        protected ContextScanDefinition newInstance() {
            return new ContextScanDefinition();
        }

        @Override
        protected boolean setProperty(ContextScanDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "excludes": {
                    java.util.List<String> val = asStringList(node);
                    target.setExcludes(val);
                    break;
                }
                case "include-non-singletons": {
                    String val = asText(node);
                    target.setIncludeNonSingletons(val);
                    break;
                }
                case "includes": {
                    java.util.List<String> val = asStringList(node);
                    target.setIncludes(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "convert-body-to",
                    "convertBodyTo"
            },
            inline = true,
            types = org.apache.camel.model.ConvertBodyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Convert Body To",
            description = "Converts the message body to another type",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "charset", type = "string", description = "To use a specific charset when converting", displayName = "Charset"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "mandatory", type = "boolean", description = "When mandatory then the conversion must return a value (cannot be null), if this is not possible then NoTypeConversionAvailableException is thrown. Setting this to false could mean conversion is not possible and the value is null.", displayName = "Mandatory"),
                    @YamlProperty(name = "type", type = "string", required = true, description = "The java type to convert to", displayName = "Type")
            }
    )
    public static class ConvertBodyDefinitionDeserializer extends YamlDeserializerBase<ConvertBodyDefinition> {
        public ConvertBodyDefinitionDeserializer() {
            super(ConvertBodyDefinition.class);
        }

        @Override
        protected ConvertBodyDefinition newInstance() {
            return new ConvertBodyDefinition();
        }

        @Override
        protected ConvertBodyDefinition newInstance(String value) {
            return new ConvertBodyDefinition(value);
        }

        @Override
        protected boolean setProperty(ConvertBodyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "charset": {
                    String val = asText(node);
                    target.setCharset(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "mandatory": {
                    String val = asText(node);
                    target.setMandatory(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "crypto",
            types = org.apache.camel.model.dataformat.CryptoDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Crypto (Java Cryptographic Extension)",
            description = "Encrypt and decrypt messages using Java Cryptography Extension (JCE).",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "algorithm", type = "string", description = "The JCE algorithm name indicating the cryptographic algorithm that will be used.", displayName = "Algorithm"),
                    @YamlProperty(name = "algorithm-parameter-ref", type = "string", description = "A JCE AlgorithmParameterSpec used to initialize the Cipher. Will lookup the type using the given name as a java.security.spec.AlgorithmParameterSpec type.", displayName = "Algorithm Parameter Ref"),
                    @YamlProperty(name = "buffer-size", type = "number", defaultValue = "4096", description = "The size of the buffer used in the signature process.", displayName = "Buffer Size"),
                    @YamlProperty(name = "crypto-provider", type = "string", description = "The name of the JCE Security Provider that should be used.", displayName = "Crypto Provider"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "init-vector-ref", type = "string", description = "Refers to a byte array containing the Initialization Vector that will be used to initialize the Cipher.", displayName = "Init Vector Ref"),
                    @YamlProperty(name = "inline", type = "boolean", description = "Flag indicating that the configured IV should be inlined into the encrypted data stream. Is by default false.", displayName = "Inline"),
                    @YamlProperty(name = "key-ref", type = "string", description = "Refers to the secret key to lookup from the register to use.", displayName = "Key Ref"),
                    @YamlProperty(name = "mac-algorithm", type = "string", defaultValue = "HmacSHA1", description = "The JCE algorithm name indicating the Message Authentication algorithm.", displayName = "Mac Algorithm"),
                    @YamlProperty(name = "should-append-hmac", type = "boolean")
            }
    )
    public static class CryptoDataFormatDeserializer extends YamlDeserializerBase<CryptoDataFormat> {
        public CryptoDataFormatDeserializer() {
            super(CryptoDataFormat.class);
        }

        @Override
        protected CryptoDataFormat newInstance() {
            return new CryptoDataFormat();
        }

        @Override
        protected boolean setProperty(CryptoDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "algorithm": {
                    String val = asText(node);
                    target.setAlgorithm(val);
                    break;
                }
                case "algorithm-parameter-ref": {
                    String val = asText(node);
                    target.setAlgorithmParameterRef(val);
                    break;
                }
                case "buffer-size": {
                    String val = asText(node);
                    target.setBufferSize(val);
                    break;
                }
                case "crypto-provider": {
                    String val = asText(node);
                    target.setCryptoProvider(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "init-vector-ref": {
                    String val = asText(node);
                    target.setInitVectorRef(val);
                    break;
                }
                case "inline": {
                    String val = asText(node);
                    target.setInline(val);
                    break;
                }
                case "key-ref": {
                    String val = asText(node);
                    target.setKeyRef(val);
                    break;
                }
                case "mac-algorithm": {
                    String val = asText(node);
                    target.setMacAlgorithm(val);
                    break;
                }
                case "should-append-hmac": {
                    String val = asText(node);
                    target.setShouldAppendHMAC(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "csv",
            inline = true,
            types = org.apache.camel.model.dataformat.CsvDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "CSV",
            description = "Handle CSV (Comma Separated Values) payloads.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-missing-column-names", type = "boolean", description = "Whether to allow missing column names.", displayName = "Allow Missing Column Names"),
                    @YamlProperty(name = "capture-header-record", type = "boolean", description = "Whether the unmarshalling should capture the header record and store it in the message header", displayName = "Capture Header Record"),
                    @YamlProperty(name = "comment-marker", type = "string", description = "Sets the comment marker of the reference format.", displayName = "Comment Marker"),
                    @YamlProperty(name = "comment-marker-disabled", type = "boolean", description = "Disables the comment marker of the reference format.", displayName = "Comment Marker Disabled"),
                    @YamlProperty(name = "delimiter", type = "string", description = "Sets the delimiter to use. The default value is , (comma)", displayName = "Delimiter"),
                    @YamlProperty(name = "escape", type = "string", description = "Sets the escape character to use", displayName = "Escape"),
                    @YamlProperty(name = "escape-disabled", type = "boolean", description = "Use for disabling using escape character", displayName = "Escape Disabled"),
                    @YamlProperty(name = "format-name", type = "enum:DEFAULT,EXCEL,INFORMIX_UNLOAD,INFORMIX_UNLOAD_CSV,MYSQL,RFC4180", defaultValue = "DEFAULT", description = "The name of the format to use, the default value is CSVFormat.DEFAULT", displayName = "Format Name"),
                    @YamlProperty(name = "format-ref", type = "string", description = "The reference format to use, it will be updated with the other format options, the default value is CSVFormat.DEFAULT", displayName = "Format Ref"),
                    @YamlProperty(name = "header", type = "array:string", description = "To configure the CSV headers", displayName = "Header"),
                    @YamlProperty(name = "header-disabled", type = "boolean", description = "Use for disabling headers", displayName = "Header Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-empty-lines", type = "boolean", description = "Whether to ignore empty lines.", displayName = "Ignore Empty Lines"),
                    @YamlProperty(name = "ignore-header-case", type = "boolean", description = "Sets whether or not to ignore case when accessing header names.", displayName = "Ignore Header Case"),
                    @YamlProperty(name = "ignore-surrounding-spaces", type = "boolean", description = "Whether to ignore surrounding spaces", displayName = "Ignore Surrounding Spaces"),
                    @YamlProperty(name = "lazy-load", type = "boolean", description = "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one.", displayName = "Lazy Load"),
                    @YamlProperty(name = "marshaller-factory-ref", type = "string", description = "Sets the implementation of the CsvMarshallerFactory interface which is able to customize marshalling/unmarshalling behavior by extending CsvMarshaller or creating it from scratch.", displayName = "Marshaller Factory Ref"),
                    @YamlProperty(name = "null-string", type = "string", description = "Sets the null string", displayName = "Null String"),
                    @YamlProperty(name = "null-string-disabled", type = "boolean", description = "Used to disable null strings", displayName = "Null String Disabled"),
                    @YamlProperty(name = "quote", type = "string", description = "Sets the quote which by default is", displayName = "Quote"),
                    @YamlProperty(name = "quote-disabled", type = "boolean", description = "Used to disable quotes", displayName = "Quote Disabled"),
                    @YamlProperty(name = "quote-mode", type = "enum:ALL,ALL_NON_NULL,MINIMAL,NON_NUMERIC,NONE", description = "Sets the quote mode", displayName = "Quote Mode"),
                    @YamlProperty(name = "record-converter-ref", type = "string", description = "Refers to a custom CsvRecordConverter to lookup from the registry to use.", displayName = "Record Converter Ref"),
                    @YamlProperty(name = "record-separator", type = "string", description = "Sets the record separator (aka new line) which by default is new line characters (CRLF)", displayName = "Record Separator"),
                    @YamlProperty(name = "record-separator-disabled", type = "string", description = "Used for disabling record separator", displayName = "Record Separator Disabled"),
                    @YamlProperty(name = "skip-header-record", type = "boolean", description = "Whether to skip the header record in the output", displayName = "Skip Header Record"),
                    @YamlProperty(name = "trailing-delimiter", type = "boolean", description = "Sets whether or not to add a trailing delimiter.", displayName = "Trailing Delimiter"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Sets whether or not to trim leading and trailing blanks.", displayName = "Trim"),
                    @YamlProperty(name = "use-maps", type = "boolean", description = "Whether the unmarshalling should produce maps (HashMap)for the lines values instead of lists. It requires to have header (either defined or collected).", displayName = "Use Maps"),
                    @YamlProperty(name = "use-ordered-maps", type = "boolean", description = "Whether the unmarshalling should produce ordered maps (LinkedHashMap) for the lines values instead of lists. It requires to have header (either defined or collected).", displayName = "Use Ordered Maps")
            }
    )
    public static class CsvDataFormatDeserializer extends YamlDeserializerBase<CsvDataFormat> {
        public CsvDataFormatDeserializer() {
            super(CsvDataFormat.class);
        }

        @Override
        protected CsvDataFormat newInstance() {
            return new CsvDataFormat();
        }

        @Override
        protected CsvDataFormat newInstance(String value) {
            return new CsvDataFormat(value);
        }

        @Override
        protected boolean setProperty(CsvDataFormat target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "allow-missing-column-names": {
                    String val = asText(node);
                    target.setAllowMissingColumnNames(val);
                    break;
                }
                case "capture-header-record": {
                    String val = asText(node);
                    target.setCaptureHeaderRecord(val);
                    break;
                }
                case "comment-marker": {
                    String val = asText(node);
                    target.setCommentMarker(val);
                    break;
                }
                case "comment-marker-disabled": {
                    String val = asText(node);
                    target.setCommentMarkerDisabled(val);
                    break;
                }
                case "delimiter": {
                    String val = asText(node);
                    target.setDelimiter(val);
                    break;
                }
                case "escape": {
                    String val = asText(node);
                    target.setEscape(val);
                    break;
                }
                case "escape-disabled": {
                    String val = asText(node);
                    target.setEscapeDisabled(val);
                    break;
                }
                case "format-name": {
                    String val = asText(node);
                    target.setFormatName(val);
                    break;
                }
                case "format-ref": {
                    String val = asText(node);
                    target.setFormatRef(val);
                    break;
                }
                case "header": {
                    java.util.List<String> val = asStringList(node);
                    target.setHeader(val);
                    break;
                }
                case "header-disabled": {
                    String val = asText(node);
                    target.setHeaderDisabled(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ignore-empty-lines": {
                    String val = asText(node);
                    target.setIgnoreEmptyLines(val);
                    break;
                }
                case "ignore-header-case": {
                    String val = asText(node);
                    target.setIgnoreHeaderCase(val);
                    break;
                }
                case "ignore-surrounding-spaces": {
                    String val = asText(node);
                    target.setIgnoreSurroundingSpaces(val);
                    break;
                }
                case "lazy-load": {
                    String val = asText(node);
                    target.setLazyLoad(val);
                    break;
                }
                case "marshaller-factory-ref": {
                    String val = asText(node);
                    target.setMarshallerFactoryRef(val);
                    break;
                }
                case "null-string": {
                    String val = asText(node);
                    target.setNullString(val);
                    break;
                }
                case "null-string-disabled": {
                    String val = asText(node);
                    target.setNullStringDisabled(val);
                    break;
                }
                case "quote": {
                    String val = asText(node);
                    target.setQuote(val);
                    break;
                }
                case "quote-disabled": {
                    String val = asText(node);
                    target.setQuoteDisabled(val);
                    break;
                }
                case "quote-mode": {
                    String val = asText(node);
                    target.setQuoteMode(val);
                    break;
                }
                case "record-converter-ref": {
                    String val = asText(node);
                    target.setRecordConverterRef(val);
                    break;
                }
                case "record-separator": {
                    String val = asText(node);
                    target.setRecordSeparator(val);
                    break;
                }
                case "record-separator-disabled": {
                    String val = asText(node);
                    target.setRecordSeparatorDisabled(val);
                    break;
                }
                case "skip-header-record": {
                    String val = asText(node);
                    target.setSkipHeaderRecord(val);
                    break;
                }
                case "trailing-delimiter": {
                    String val = asText(node);
                    target.setTrailingDelimiter(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                case "use-maps": {
                    String val = asText(node);
                    target.setUseMaps(val);
                    break;
                }
                case "use-ordered-maps": {
                    String val = asText(node);
                    target.setUseOrderedMaps(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "custom",
            inline = true,
            types = org.apache.camel.model.dataformat.CustomDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Custom",
            description = "Delegate to a custom org.apache.camel.spi.DataFormat implementation via Camel registry.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ref", type = "string", required = true, description = "Reference to the custom org.apache.camel.spi.DataFormat to lookup from the Camel registry.", displayName = "Ref")
            }
    )
    public static class CustomDataFormatDeserializer extends YamlDeserializerBase<CustomDataFormat> {
        public CustomDataFormatDeserializer() {
            super(CustomDataFormat.class);
        }

        @Override
        protected CustomDataFormat newInstance() {
            return new CustomDataFormat();
        }

        @Override
        protected CustomDataFormat newInstance(String value) {
            return new CustomDataFormat(value);
        }

        @Override
        protected boolean setProperty(CustomDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "custom-load-balancer",
                    "customLoadBalancer"
            },
            inline = true,
            types = org.apache.camel.model.loadbalancer.CustomLoadBalancerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Custom Load Balancer",
            description = "To use a custom load balancer implementation.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ref", type = "string", required = true, description = "Refers to the custom load balancer to lookup from the registry", displayName = "Ref")
            }
    )
    public static class CustomLoadBalancerDefinitionDeserializer extends YamlDeserializerBase<CustomLoadBalancerDefinition> {
        public CustomLoadBalancerDefinitionDeserializer() {
            super(CustomLoadBalancerDefinition.class);
        }

        @Override
        protected CustomLoadBalancerDefinition newInstance() {
            return new CustomLoadBalancerDefinition();
        }

        @Override
        protected CustomLoadBalancerDefinition newInstance(String value) {
            return new CustomLoadBalancerDefinition(value);
        }

        @Override
        protected boolean setProperty(CustomLoadBalancerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "custom-service-filter",
                    "customServiceFilter"
            },
            types = org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Custom Service Filter",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "ref", type = "string", description = "Reference of a ServiceFilter", displayName = "Ref")
            }
    )
    public static class CustomServiceCallServiceFilterConfigurationDeserializer extends YamlDeserializerBase<CustomServiceCallServiceFilterConfiguration> {
        public CustomServiceCallServiceFilterConfigurationDeserializer() {
            super(CustomServiceCallServiceFilterConfiguration.class);
        }

        @Override
        protected CustomServiceCallServiceFilterConfiguration newInstance() {
            return new CustomServiceCallServiceFilterConfiguration();
        }

        @Override
        protected boolean setProperty(CustomServiceCallServiceFilterConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setServiceFilterRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.transformer.CustomTransformerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "class-name", type = "string"),
                    @YamlProperty(name = "from-type", type = "string"),
                    @YamlProperty(name = "name", type = "string"),
                    @YamlProperty(name = "ref", type = "string"),
                    @YamlProperty(name = "scheme", type = "string"),
                    @YamlProperty(name = "to-type", type = "string")
            }
    )
    public static class CustomTransformerDefinitionDeserializer extends YamlDeserializerBase<CustomTransformerDefinition> {
        public CustomTransformerDefinitionDeserializer() {
            super(CustomTransformerDefinition.class);
        }

        @Override
        protected CustomTransformerDefinition newInstance() {
            return new CustomTransformerDefinition();
        }

        @Override
        protected boolean setProperty(CustomTransformerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "class-name": {
                    String val = asText(node);
                    target.setClassName(val);
                    break;
                }
                case "from-type": {
                    String val = asText(node);
                    target.setFromType(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "scheme": {
                    String val = asText(node);
                    target.setScheme(val);
                    break;
                }
                case "to-type": {
                    String val = asText(node);
                    target.setToType(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.validator.CustomValidatorDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "class-name", type = "string"),
                    @YamlProperty(name = "ref", type = "string"),
                    @YamlProperty(name = "type", type = "string")
            }
    )
    public static class CustomValidatorDefinitionDeserializer extends YamlDeserializerBase<CustomValidatorDefinition> {
        public CustomValidatorDefinitionDeserializer() {
            super(CustomValidatorDefinition.class);
        }

        @Override
        protected CustomValidatorDefinition newInstance() {
            return new CustomValidatorDefinition();
        }

        @Override
        protected boolean setProperty(CustomValidatorDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "class-name": {
                    String val = asText(node);
                    target.setClassName(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.DataFormatDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = @YamlProperty(name = "id", type = "string")
    )
    public static class DataFormatDefinitionDeserializer extends YamlDeserializerBase<DataFormatDefinition> {
        public DataFormatDefinitionDeserializer() {
            super(DataFormatDefinition.class);
        }

        @Override
        protected DataFormatDefinition newInstance() {
            return new DataFormatDefinition();
        }

        @Override
        protected boolean setProperty(DataFormatDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.transformer.DataFormatTransformerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "asn1", type = "object:org.apache.camel.model.dataformat.ASN1DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "avro", type = "object:org.apache.camel.model.dataformat.AvroDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "barcode", type = "object:org.apache.camel.model.dataformat.BarcodeDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "base64", type = "object:org.apache.camel.model.dataformat.Base64DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "bindy", type = "object:org.apache.camel.model.dataformat.BindyDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "cbor", type = "object:org.apache.camel.model.dataformat.CBORDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "crypto", type = "object:org.apache.camel.model.dataformat.CryptoDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "csv", type = "object:org.apache.camel.model.dataformat.CsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "custom", type = "object:org.apache.camel.model.dataformat.CustomDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "fhir-json", type = "object:org.apache.camel.model.dataformat.FhirJsonDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "fhir-xml", type = "object:org.apache.camel.model.dataformat.FhirXmlDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "flatpack", type = "object:org.apache.camel.model.dataformat.FlatpackDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "from-type", type = "string"),
                    @YamlProperty(name = "grok", type = "object:org.apache.camel.model.dataformat.GrokDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "gzip-deflater", type = "object:org.apache.camel.model.dataformat.GzipDeflaterDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "hl7", type = "object:org.apache.camel.model.dataformat.HL7DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "ical", type = "object:org.apache.camel.model.dataformat.IcalDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "jackson-xml", type = "object:org.apache.camel.model.dataformat.JacksonXMLDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "jaxb", type = "object:org.apache.camel.model.dataformat.JaxbDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "json", type = "object:org.apache.camel.model.dataformat.JsonDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "json-api", type = "object:org.apache.camel.model.dataformat.JsonApiDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "lzf", type = "object:org.apache.camel.model.dataformat.LZFDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "mime-multipart", type = "object:org.apache.camel.model.dataformat.MimeMultipartDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "name", type = "string"),
                    @YamlProperty(name = "parquet-avro", type = "object:org.apache.camel.model.dataformat.ParquetAvroDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "pgp", type = "object:org.apache.camel.model.dataformat.PGPDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "protobuf", type = "object:org.apache.camel.model.dataformat.ProtobufDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "rss", type = "object:org.apache.camel.model.dataformat.RssDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "scheme", type = "string"),
                    @YamlProperty(name = "soap", type = "object:org.apache.camel.model.dataformat.SoapDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "swift-mt", type = "object:org.apache.camel.model.dataformat.SwiftMtDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "swift-mx", type = "object:org.apache.camel.model.dataformat.SwiftMxDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "syslog", type = "object:org.apache.camel.model.dataformat.SyslogDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "tar-file", type = "object:org.apache.camel.model.dataformat.TarFileDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "thrift", type = "object:org.apache.camel.model.dataformat.ThriftDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "tidy-markup", type = "object:org.apache.camel.model.dataformat.TidyMarkupDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "to-type", type = "string"),
                    @YamlProperty(name = "univocity-csv", type = "object:org.apache.camel.model.dataformat.UniVocityCsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-fixed", type = "object:org.apache.camel.model.dataformat.UniVocityFixedDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-tsv", type = "object:org.apache.camel.model.dataformat.UniVocityTsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "xml-security", type = "object:org.apache.camel.model.dataformat.XMLSecurityDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "yaml", type = "object:org.apache.camel.model.dataformat.YAMLDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "zip-deflater", type = "object:org.apache.camel.model.dataformat.ZipDeflaterDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "zip-file", type = "object:org.apache.camel.model.dataformat.ZipFileDataFormat", oneOf = "dataFormatType")
            }
    )
    public static class DataFormatTransformerDefinitionDeserializer extends YamlDeserializerBase<DataFormatTransformerDefinition> {
        public DataFormatTransformerDefinitionDeserializer() {
            super(DataFormatTransformerDefinition.class);
        }

        @Override
        protected DataFormatTransformerDefinition newInstance() {
            return new DataFormatTransformerDefinition();
        }

        @Override
        protected boolean setProperty(DataFormatTransformerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "data-format-type": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "asn1": {
                    org.apache.camel.model.dataformat.ASN1DataFormat val = asType(node, org.apache.camel.model.dataformat.ASN1DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "avro": {
                    org.apache.camel.model.dataformat.AvroDataFormat val = asType(node, org.apache.camel.model.dataformat.AvroDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "barcode": {
                    org.apache.camel.model.dataformat.BarcodeDataFormat val = asType(node, org.apache.camel.model.dataformat.BarcodeDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "base64": {
                    org.apache.camel.model.dataformat.Base64DataFormat val = asType(node, org.apache.camel.model.dataformat.Base64DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "bindy": {
                    org.apache.camel.model.dataformat.BindyDataFormat val = asType(node, org.apache.camel.model.dataformat.BindyDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "cbor": {
                    org.apache.camel.model.dataformat.CBORDataFormat val = asType(node, org.apache.camel.model.dataformat.CBORDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "crypto": {
                    org.apache.camel.model.dataformat.CryptoDataFormat val = asType(node, org.apache.camel.model.dataformat.CryptoDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "csv": {
                    org.apache.camel.model.dataformat.CsvDataFormat val = asType(node, org.apache.camel.model.dataformat.CsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "custom": {
                    org.apache.camel.model.dataformat.CustomDataFormat val = asType(node, org.apache.camel.model.dataformat.CustomDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "fhir-json": {
                    org.apache.camel.model.dataformat.FhirJsonDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirJsonDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "fhir-xml": {
                    org.apache.camel.model.dataformat.FhirXmlDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirXmlDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "flatpack": {
                    org.apache.camel.model.dataformat.FlatpackDataFormat val = asType(node, org.apache.camel.model.dataformat.FlatpackDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "grok": {
                    org.apache.camel.model.dataformat.GrokDataFormat val = asType(node, org.apache.camel.model.dataformat.GrokDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "gzip-deflater": {
                    org.apache.camel.model.dataformat.GzipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.GzipDeflaterDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "hl7": {
                    org.apache.camel.model.dataformat.HL7DataFormat val = asType(node, org.apache.camel.model.dataformat.HL7DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "ical": {
                    org.apache.camel.model.dataformat.IcalDataFormat val = asType(node, org.apache.camel.model.dataformat.IcalDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "jackson-xml": {
                    org.apache.camel.model.dataformat.JacksonXMLDataFormat val = asType(node, org.apache.camel.model.dataformat.JacksonXMLDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "jaxb": {
                    org.apache.camel.model.dataformat.JaxbDataFormat val = asType(node, org.apache.camel.model.dataformat.JaxbDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "json": {
                    org.apache.camel.model.dataformat.JsonDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "json-api": {
                    org.apache.camel.model.dataformat.JsonApiDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonApiDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "lzf": {
                    org.apache.camel.model.dataformat.LZFDataFormat val = asType(node, org.apache.camel.model.dataformat.LZFDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "mime-multipart": {
                    org.apache.camel.model.dataformat.MimeMultipartDataFormat val = asType(node, org.apache.camel.model.dataformat.MimeMultipartDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "parquet-avro": {
                    org.apache.camel.model.dataformat.ParquetAvroDataFormat val = asType(node, org.apache.camel.model.dataformat.ParquetAvroDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "protobuf": {
                    org.apache.camel.model.dataformat.ProtobufDataFormat val = asType(node, org.apache.camel.model.dataformat.ProtobufDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "rss": {
                    org.apache.camel.model.dataformat.RssDataFormat val = asType(node, org.apache.camel.model.dataformat.RssDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "soap": {
                    org.apache.camel.model.dataformat.SoapDataFormat val = asType(node, org.apache.camel.model.dataformat.SoapDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "swift-mt": {
                    org.apache.camel.model.dataformat.SwiftMtDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMtDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "swift-mx": {
                    org.apache.camel.model.dataformat.SwiftMxDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMxDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "syslog": {
                    org.apache.camel.model.dataformat.SyslogDataFormat val = asType(node, org.apache.camel.model.dataformat.SyslogDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "tar-file": {
                    org.apache.camel.model.dataformat.TarFileDataFormat val = asType(node, org.apache.camel.model.dataformat.TarFileDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "thrift": {
                    org.apache.camel.model.dataformat.ThriftDataFormat val = asType(node, org.apache.camel.model.dataformat.ThriftDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "tidy-markup": {
                    org.apache.camel.model.dataformat.TidyMarkupDataFormat val = asType(node, org.apache.camel.model.dataformat.TidyMarkupDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-csv": {
                    org.apache.camel.model.dataformat.UniVocityCsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityCsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-fixed": {
                    org.apache.camel.model.dataformat.UniVocityFixedDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityFixedDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-tsv": {
                    org.apache.camel.model.dataformat.UniVocityTsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityTsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "xml-security": {
                    org.apache.camel.model.dataformat.XMLSecurityDataFormat val = asType(node, org.apache.camel.model.dataformat.XMLSecurityDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "pgp": {
                    org.apache.camel.model.dataformat.PGPDataFormat val = asType(node, org.apache.camel.model.dataformat.PGPDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "yaml": {
                    org.apache.camel.model.dataformat.YAMLDataFormat val = asType(node, org.apache.camel.model.dataformat.YAMLDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "zip-deflater": {
                    org.apache.camel.model.dataformat.ZipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipDeflaterDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "zip-file": {
                    org.apache.camel.model.dataformat.ZipFileDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipFileDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "from-type": {
                    String val = asText(node);
                    target.setFromType(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "scheme": {
                    String val = asText(node);
                    target.setScheme(val);
                    break;
                }
                case "to-type": {
                    String val = asText(node);
                    target.setToType(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "data-formats",
                    "dataFormats"
            },
            types = org.apache.camel.model.dataformat.DataFormatsDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Data formats",
            description = "Configure data formats.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "asn1", type = "object:org.apache.camel.model.dataformat.ASN1DataFormat"),
                    @YamlProperty(name = "avro", type = "object:org.apache.camel.model.dataformat.AvroDataFormat"),
                    @YamlProperty(name = "barcode", type = "object:org.apache.camel.model.dataformat.BarcodeDataFormat"),
                    @YamlProperty(name = "base64", type = "object:org.apache.camel.model.dataformat.Base64DataFormat"),
                    @YamlProperty(name = "bindy", type = "object:org.apache.camel.model.dataformat.BindyDataFormat"),
                    @YamlProperty(name = "cbor", type = "object:org.apache.camel.model.dataformat.CBORDataFormat"),
                    @YamlProperty(name = "crypto", type = "object:org.apache.camel.model.dataformat.CryptoDataFormat"),
                    @YamlProperty(name = "csv", type = "object:org.apache.camel.model.dataformat.CsvDataFormat"),
                    @YamlProperty(name = "custom", type = "object:org.apache.camel.model.dataformat.CustomDataFormat"),
                    @YamlProperty(name = "fhir-json", type = "object:org.apache.camel.model.dataformat.FhirJsonDataFormat"),
                    @YamlProperty(name = "fhir-xml", type = "object:org.apache.camel.model.dataformat.FhirXmlDataFormat"),
                    @YamlProperty(name = "flatpack", type = "object:org.apache.camel.model.dataformat.FlatpackDataFormat"),
                    @YamlProperty(name = "grok", type = "object:org.apache.camel.model.dataformat.GrokDataFormat"),
                    @YamlProperty(name = "gzip-deflater", type = "object:org.apache.camel.model.dataformat.GzipDeflaterDataFormat"),
                    @YamlProperty(name = "hl7", type = "object:org.apache.camel.model.dataformat.HL7DataFormat"),
                    @YamlProperty(name = "ical", type = "object:org.apache.camel.model.dataformat.IcalDataFormat"),
                    @YamlProperty(name = "jackson-xml", type = "object:org.apache.camel.model.dataformat.JacksonXMLDataFormat"),
                    @YamlProperty(name = "jaxb", type = "object:org.apache.camel.model.dataformat.JaxbDataFormat"),
                    @YamlProperty(name = "json", type = "object:org.apache.camel.model.dataformat.JsonDataFormat"),
                    @YamlProperty(name = "json-api", type = "object:org.apache.camel.model.dataformat.JsonApiDataFormat"),
                    @YamlProperty(name = "lzf", type = "object:org.apache.camel.model.dataformat.LZFDataFormat"),
                    @YamlProperty(name = "mime-multipart", type = "object:org.apache.camel.model.dataformat.MimeMultipartDataFormat"),
                    @YamlProperty(name = "parquet-avro", type = "object:org.apache.camel.model.dataformat.ParquetAvroDataFormat"),
                    @YamlProperty(name = "pgp", type = "object:org.apache.camel.model.dataformat.PGPDataFormat"),
                    @YamlProperty(name = "protobuf", type = "object:org.apache.camel.model.dataformat.ProtobufDataFormat"),
                    @YamlProperty(name = "rss", type = "object:org.apache.camel.model.dataformat.RssDataFormat"),
                    @YamlProperty(name = "soap", type = "object:org.apache.camel.model.dataformat.SoapDataFormat"),
                    @YamlProperty(name = "swift-mt", type = "object:org.apache.camel.model.dataformat.SwiftMtDataFormat"),
                    @YamlProperty(name = "swift-mx", type = "object:org.apache.camel.model.dataformat.SwiftMxDataFormat"),
                    @YamlProperty(name = "syslog", type = "object:org.apache.camel.model.dataformat.SyslogDataFormat"),
                    @YamlProperty(name = "tar-file", type = "object:org.apache.camel.model.dataformat.TarFileDataFormat"),
                    @YamlProperty(name = "thrift", type = "object:org.apache.camel.model.dataformat.ThriftDataFormat"),
                    @YamlProperty(name = "tidy-markup", type = "object:org.apache.camel.model.dataformat.TidyMarkupDataFormat"),
                    @YamlProperty(name = "univocity-csv", type = "object:org.apache.camel.model.dataformat.UniVocityCsvDataFormat"),
                    @YamlProperty(name = "univocity-fixed", type = "object:org.apache.camel.model.dataformat.UniVocityFixedDataFormat"),
                    @YamlProperty(name = "univocity-tsv", type = "object:org.apache.camel.model.dataformat.UniVocityTsvDataFormat"),
                    @YamlProperty(name = "xml-security", type = "object:org.apache.camel.model.dataformat.XMLSecurityDataFormat"),
                    @YamlProperty(name = "yaml", type = "object:org.apache.camel.model.dataformat.YAMLDataFormat"),
                    @YamlProperty(name = "zip-deflater", type = "object:org.apache.camel.model.dataformat.ZipDeflaterDataFormat"),
                    @YamlProperty(name = "zip-file", type = "object:org.apache.camel.model.dataformat.ZipFileDataFormat")
            }
    )
    public static class DataFormatsDefinitionDeserializer extends YamlDeserializerBase<DataFormatsDefinition> {
        public DataFormatsDefinitionDeserializer() {
            super(DataFormatsDefinition.class);
        }

        @Override
        protected DataFormatsDefinition newInstance() {
            return new DataFormatsDefinition();
        }

        @Override
        protected boolean setProperty(DataFormatsDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "data-formats": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "asn1": {
                    org.apache.camel.model.dataformat.ASN1DataFormat val = asType(node, org.apache.camel.model.dataformat.ASN1DataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "avro": {
                    org.apache.camel.model.dataformat.AvroDataFormat val = asType(node, org.apache.camel.model.dataformat.AvroDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "barcode": {
                    org.apache.camel.model.dataformat.BarcodeDataFormat val = asType(node, org.apache.camel.model.dataformat.BarcodeDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "base64": {
                    org.apache.camel.model.dataformat.Base64DataFormat val = asType(node, org.apache.camel.model.dataformat.Base64DataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "bindy": {
                    org.apache.camel.model.dataformat.BindyDataFormat val = asType(node, org.apache.camel.model.dataformat.BindyDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "cbor": {
                    org.apache.camel.model.dataformat.CBORDataFormat val = asType(node, org.apache.camel.model.dataformat.CBORDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "crypto": {
                    org.apache.camel.model.dataformat.CryptoDataFormat val = asType(node, org.apache.camel.model.dataformat.CryptoDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "csv": {
                    org.apache.camel.model.dataformat.CsvDataFormat val = asType(node, org.apache.camel.model.dataformat.CsvDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "custom": {
                    org.apache.camel.model.dataformat.CustomDataFormat val = asType(node, org.apache.camel.model.dataformat.CustomDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "fhir-json": {
                    org.apache.camel.model.dataformat.FhirJsonDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirJsonDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "fhir-xml": {
                    org.apache.camel.model.dataformat.FhirXmlDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirXmlDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "flatpack": {
                    org.apache.camel.model.dataformat.FlatpackDataFormat val = asType(node, org.apache.camel.model.dataformat.FlatpackDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "grok": {
                    org.apache.camel.model.dataformat.GrokDataFormat val = asType(node, org.apache.camel.model.dataformat.GrokDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "gzip-deflater": {
                    org.apache.camel.model.dataformat.GzipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.GzipDeflaterDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "hl7": {
                    org.apache.camel.model.dataformat.HL7DataFormat val = asType(node, org.apache.camel.model.dataformat.HL7DataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "ical": {
                    org.apache.camel.model.dataformat.IcalDataFormat val = asType(node, org.apache.camel.model.dataformat.IcalDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "jackson-xml": {
                    org.apache.camel.model.dataformat.JacksonXMLDataFormat val = asType(node, org.apache.camel.model.dataformat.JacksonXMLDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "jaxb": {
                    org.apache.camel.model.dataformat.JaxbDataFormat val = asType(node, org.apache.camel.model.dataformat.JaxbDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "json": {
                    org.apache.camel.model.dataformat.JsonDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "json-api": {
                    org.apache.camel.model.dataformat.JsonApiDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonApiDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "lzf": {
                    org.apache.camel.model.dataformat.LZFDataFormat val = asType(node, org.apache.camel.model.dataformat.LZFDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "mime-multipart": {
                    org.apache.camel.model.dataformat.MimeMultipartDataFormat val = asType(node, org.apache.camel.model.dataformat.MimeMultipartDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "parquet-avro": {
                    org.apache.camel.model.dataformat.ParquetAvroDataFormat val = asType(node, org.apache.camel.model.dataformat.ParquetAvroDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "pgp": {
                    org.apache.camel.model.dataformat.PGPDataFormat val = asType(node, org.apache.camel.model.dataformat.PGPDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "protobuf": {
                    org.apache.camel.model.dataformat.ProtobufDataFormat val = asType(node, org.apache.camel.model.dataformat.ProtobufDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "rss": {
                    org.apache.camel.model.dataformat.RssDataFormat val = asType(node, org.apache.camel.model.dataformat.RssDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "soap": {
                    org.apache.camel.model.dataformat.SoapDataFormat val = asType(node, org.apache.camel.model.dataformat.SoapDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "swift-mt": {
                    org.apache.camel.model.dataformat.SwiftMtDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMtDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "swift-mx": {
                    org.apache.camel.model.dataformat.SwiftMxDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMxDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "syslog": {
                    org.apache.camel.model.dataformat.SyslogDataFormat val = asType(node, org.apache.camel.model.dataformat.SyslogDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "tar-file": {
                    org.apache.camel.model.dataformat.TarFileDataFormat val = asType(node, org.apache.camel.model.dataformat.TarFileDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "thrift": {
                    org.apache.camel.model.dataformat.ThriftDataFormat val = asType(node, org.apache.camel.model.dataformat.ThriftDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "tidy-markup": {
                    org.apache.camel.model.dataformat.TidyMarkupDataFormat val = asType(node, org.apache.camel.model.dataformat.TidyMarkupDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "univocity-csv": {
                    org.apache.camel.model.dataformat.UniVocityCsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityCsvDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "univocity-fixed": {
                    org.apache.camel.model.dataformat.UniVocityFixedDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityFixedDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "univocity-tsv": {
                    org.apache.camel.model.dataformat.UniVocityTsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityTsvDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "xml-security": {
                    org.apache.camel.model.dataformat.XMLSecurityDataFormat val = asType(node, org.apache.camel.model.dataformat.XMLSecurityDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "yaml": {
                    org.apache.camel.model.dataformat.YAMLDataFormat val = asType(node, org.apache.camel.model.dataformat.YAMLDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "zip-deflater": {
                    org.apache.camel.model.dataformat.ZipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipDeflaterDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                case "zip-file": {
                    org.apache.camel.model.dataformat.ZipFileDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipFileDataFormat.class);
                    java.util.List<org.apache.camel.model.DataFormatDefinition> existing = target.getDataFormats();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setDataFormats(existing);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "datasonnet",
            inline = true,
            types = org.apache.camel.model.language.DatasonnetExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "DataSonnet",
            description = "To use DataSonnet scripts for message transformations.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "body-media-type", type = "string", description = "The String representation of the message's body MediaType", displayName = "Body Media Type"),
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "output-media-type", type = "string", description = "The String representation of the MediaType to output", displayName = "Output Media Type"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class DatasonnetExpressionDeserializer extends YamlDeserializerBase<DatasonnetExpression> {
        public DatasonnetExpressionDeserializer() {
            super(DatasonnetExpression.class);
        }

        @Override
        protected DatasonnetExpression newInstance() {
            return new DatasonnetExpression();
        }

        @Override
        protected DatasonnetExpression newInstance(String value) {
            return new DatasonnetExpression(value);
        }

        @Override
        protected boolean setProperty(DatasonnetExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "body-media-type": {
                    String val = asText(node);
                    target.setBodyMediaType(val);
                    break;
                }
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "output-media-type": {
                    String val = asText(node);
                    target.setOutputMediaType(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "dead-letter-channel",
                    "deadLetterChannel"
            },
            types = org.apache.camel.model.errorhandler.DeadLetterChannelDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Dead Letter Channel",
            description = "Error handler with dead letter queue.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "dead-letter-handle-new-exception", type = "boolean", description = "Whether the dead letter channel should handle (and ignore) any new exception that may been thrown during sending the message to the dead letter endpoint. The default value is true which means any such kind of exception is handled and ignored. Set this to false to let the exception be propagated back on the org.apache.camel.Exchange . This can be used in situations where you use transactions, and want to use Camel's dead letter channel to deal with exceptions during routing, but if the dead letter channel itself fails because of a new exception being thrown, then by setting this to false the new exceptions is propagated back and set on the org.apache.camel.Exchange , which allows the transaction to detect the exception, and rollback.", displayName = "Dead Letter Handle New Exception"),
                    @YamlProperty(name = "dead-letter-uri", type = "string", required = true, description = "The dead letter endpoint uri for the Dead Letter error handler.", displayName = "Dead Letter Uri"),
                    @YamlProperty(name = "executor-service-ref", type = "string", description = "Sets a reference to a thread pool to be used by the error handler", displayName = "Executor Service Ref"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "ERROR", description = "Logging level to use by error handler", displayName = "Level"),
                    @YamlProperty(name = "log-name", type = "string", description = "Name of the logger to use by the error handler", displayName = "Log Name"),
                    @YamlProperty(name = "logger-ref", type = "string", description = "References to a logger to use as logger for the error handler", displayName = "Logger Ref"),
                    @YamlProperty(name = "on-exception-occurred-ref", type = "string", description = "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.", displayName = "On Exception Occurred Ref"),
                    @YamlProperty(name = "on-prepare-failure-ref", type = "string", description = "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.", displayName = "On Prepare Failure Ref"),
                    @YamlProperty(name = "on-redelivery-ref", type = "string", description = "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.", displayName = "On Redelivery Ref"),
                    @YamlProperty(name = "redelivery-policy", type = "object:org.apache.camel.model.RedeliveryPolicyDefinition", description = "Sets the redelivery settings", displayName = "Redelivery Policy"),
                    @YamlProperty(name = "redelivery-policy-ref", type = "string", description = "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.", displayName = "Redelivery Policy Ref"),
                    @YamlProperty(name = "retry-while-ref", type = "string", description = "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.", displayName = "Retry While Ref"),
                    @YamlProperty(name = "use-original-body", type = "boolean", description = "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Body"),
                    @YamlProperty(name = "use-original-message", type = "boolean", description = "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Message")
            }
    )
    public static class DeadLetterChannelDefinitionDeserializer extends YamlDeserializerBase<DeadLetterChannelDefinition> {
        public DeadLetterChannelDefinitionDeserializer() {
            super(DeadLetterChannelDefinition.class);
        }

        @Override
        protected DeadLetterChannelDefinition newInstance() {
            return new DeadLetterChannelDefinition();
        }

        @Override
        protected boolean setProperty(DeadLetterChannelDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "dead-letter-handle-new-exception": {
                    String val = asText(node);
                    target.setDeadLetterHandleNewException(val);
                    break;
                }
                case "dead-letter-uri": {
                    String val = asText(node);
                    target.setDeadLetterUri(val);
                    break;
                }
                case "executor-service-ref": {
                    String val = asText(node);
                    target.setExecutorServiceRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "level": {
                    String val = asText(node);
                    target.setLevel(val);
                    break;
                }
                case "log-name": {
                    String val = asText(node);
                    target.setLogName(val);
                    break;
                }
                case "logger-ref": {
                    String val = asText(node);
                    target.setLoggerRef(val);
                    break;
                }
                case "on-exception-occurred-ref": {
                    String val = asText(node);
                    target.setOnExceptionOccurredRef(val);
                    break;
                }
                case "on-prepare-failure-ref": {
                    String val = asText(node);
                    target.setOnPrepareFailureRef(val);
                    break;
                }
                case "on-redelivery-ref": {
                    String val = asText(node);
                    target.setOnRedeliveryRef(val);
                    break;
                }
                case "redelivery-policy": {
                    org.apache.camel.model.RedeliveryPolicyDefinition val = asType(node, org.apache.camel.model.RedeliveryPolicyDefinition.class);
                    target.setRedeliveryPolicy(val);
                    break;
                }
                case "redelivery-policy-ref": {
                    String val = asText(node);
                    target.setRedeliveryPolicyRef(val);
                    break;
                }
                case "retry-while-ref": {
                    String val = asText(node);
                    target.setRetryWhileRef(val);
                    break;
                }
                case "use-original-body": {
                    String val = asText(node);
                    target.setUseOriginalBody(val);
                    break;
                }
                case "use-original-message": {
                    String val = asText(node);
                    target.setUseOriginalMessage(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "default-error-handler",
                    "defaultErrorHandler"
            },
            types = org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Default Error Handler",
            description = "The default error handler.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "executor-service-ref", type = "string", description = "Sets a reference to a thread pool to be used by the error handler", displayName = "Executor Service Ref"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "ERROR", description = "Logging level to use by error handler", displayName = "Level"),
                    @YamlProperty(name = "log-name", type = "string", description = "Name of the logger to use by the error handler", displayName = "Log Name"),
                    @YamlProperty(name = "logger-ref", type = "string", description = "References to a logger to use as logger for the error handler", displayName = "Logger Ref"),
                    @YamlProperty(name = "on-exception-occurred-ref", type = "string", description = "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.", displayName = "On Exception Occurred Ref"),
                    @YamlProperty(name = "on-prepare-failure-ref", type = "string", description = "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.", displayName = "On Prepare Failure Ref"),
                    @YamlProperty(name = "on-redelivery-ref", type = "string", description = "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.", displayName = "On Redelivery Ref"),
                    @YamlProperty(name = "redelivery-policy", type = "object:org.apache.camel.model.RedeliveryPolicyDefinition", description = "Sets the redelivery settings", displayName = "Redelivery Policy"),
                    @YamlProperty(name = "redelivery-policy-ref", type = "string", description = "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.", displayName = "Redelivery Policy Ref"),
                    @YamlProperty(name = "retry-while-ref", type = "string", description = "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.", displayName = "Retry While Ref"),
                    @YamlProperty(name = "use-original-body", type = "boolean", description = "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Body"),
                    @YamlProperty(name = "use-original-message", type = "boolean", description = "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Message")
            }
    )
    public static class DefaultErrorHandlerDefinitionDeserializer extends YamlDeserializerBase<DefaultErrorHandlerDefinition> {
        public DefaultErrorHandlerDefinitionDeserializer() {
            super(DefaultErrorHandlerDefinition.class);
        }

        @Override
        protected DefaultErrorHandlerDefinition newInstance() {
            return new DefaultErrorHandlerDefinition();
        }

        @Override
        protected boolean setProperty(DefaultErrorHandlerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "executor-service-ref": {
                    String val = asText(node);
                    target.setExecutorServiceRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "level": {
                    String val = asText(node);
                    target.setLevel(val);
                    break;
                }
                case "log-name": {
                    String val = asText(node);
                    target.setLogName(val);
                    break;
                }
                case "logger-ref": {
                    String val = asText(node);
                    target.setLoggerRef(val);
                    break;
                }
                case "on-exception-occurred-ref": {
                    String val = asText(node);
                    target.setOnExceptionOccurredRef(val);
                    break;
                }
                case "on-prepare-failure-ref": {
                    String val = asText(node);
                    target.setOnPrepareFailureRef(val);
                    break;
                }
                case "on-redelivery-ref": {
                    String val = asText(node);
                    target.setOnRedeliveryRef(val);
                    break;
                }
                case "redelivery-policy": {
                    org.apache.camel.model.RedeliveryPolicyDefinition val = asType(node, org.apache.camel.model.RedeliveryPolicyDefinition.class);
                    target.setRedeliveryPolicy(val);
                    break;
                }
                case "redelivery-policy-ref": {
                    String val = asText(node);
                    target.setRedeliveryPolicyRef(val);
                    break;
                }
                case "retry-while-ref": {
                    String val = asText(node);
                    target.setRetryWhileRef(val);
                    break;
                }
                case "use-original-body": {
                    String val = asText(node);
                    target.setUseOriginalBody(val);
                    break;
                }
                case "use-original-message": {
                    String val = asText(node);
                    target.setUseOriginalMessage(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "default-load-balancer",
                    "defaultLoadBalancer"
            },
            types = org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Default Load Balancer",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class DefaultServiceCallServiceLoadBalancerConfigurationDeserializer extends YamlDeserializerBase<DefaultServiceCallServiceLoadBalancerConfiguration> {
        public DefaultServiceCallServiceLoadBalancerConfigurationDeserializer() {
            super(DefaultServiceCallServiceLoadBalancerConfiguration.class);
        }

        @Override
        protected DefaultServiceCallServiceLoadBalancerConfiguration newInstance() {
            return new DefaultServiceCallServiceLoadBalancerConfiguration();
        }

        @Override
        protected boolean setProperty(DefaultServiceCallServiceLoadBalancerConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "delay",
            types = org.apache.camel.model.DelayDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Delay",
            description = "Delays processing for a specified length of time",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "async-delayed", type = "boolean", description = "Enables asynchronous delay which means the thread will not block while delaying.", displayName = "Async Delayed"),
                    @YamlProperty(name = "caller-runs-when-rejected", type = "boolean", description = "Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true", displayName = "Caller Runs When Rejected"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "executor-service", type = "string", description = "To use a custom Thread Pool if asyncDelay has been enabled.", displayName = "Executor Service"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to define how long time to wait (in millis)", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean")
            }
    )
    public static class DelayDefinitionDeserializer extends YamlDeserializerBase<DelayDefinition> {
        public DelayDefinitionDeserializer() {
            super(DelayDefinition.class);
        }

        @Override
        protected DelayDefinition newInstance() {
            return new DelayDefinition();
        }

        @Override
        protected boolean setProperty(DelayDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "async-delayed": {
                    String val = asText(node);
                    target.setAsyncDelayed(val);
                    break;
                }
                case "caller-runs-when-rejected": {
                    String val = asText(node);
                    target.setCallerRunsWhenRejected(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "delete",
            types = org.apache.camel.model.rest.DeleteDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Delete",
            description = "Rest DELETE command",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-docs", type = "boolean", description = "Whether to include or exclude this rest operation in API documentation. The default value is true.", displayName = "Api Docs"),
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json. This option will override what may be configured on a parent level", displayName = "Consumes"),
                    @YamlProperty(name = "deprecated", type = "boolean", description = "Marks this rest operation as deprecated in OpenApi documentation.", displayName = "Deprecated"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this REST service from the route during build time. Once an REST service has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "out-type", type = "string", description = "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Out Type"),
                    @YamlProperty(name = "param", type = "array:org.apache.camel.model.rest.ParamDefinition"),
                    @YamlProperty(name = "path", type = "string", description = "The path mapping URIs of this REST operation such as /{id}.", displayName = "Path"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json This option will override what may be configured on a parent level", displayName = "Produces"),
                    @YamlProperty(name = "response-message", type = "array:org.apache.camel.model.rest.ResponseMessageDefinition"),
                    @YamlProperty(name = "route-id", type = "string", description = "Sets the id of the route", displayName = "Route Id"),
                    @YamlProperty(name = "security", type = "array:org.apache.camel.model.rest.SecurityDefinition"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do. This option will override what may be configured on a parent level", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "to", type = "object:org.apache.camel.model.ToDefinition", description = "The Camel endpoint this REST service will call, such as a direct endpoint to link to an existing route that handles this REST call.", displayName = "To"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level. The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Type")
            }
    )
    public static class DeleteDefinitionDeserializer extends YamlDeserializerBase<DeleteDefinition> {
        public DeleteDefinitionDeserializer() {
            super(DeleteDefinition.class);
        }

        @Override
        protected DeleteDefinition newInstance() {
            return new DeleteDefinition();
        }

        @Override
        protected boolean setProperty(DeleteDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "api-docs": {
                    String val = asText(node);
                    target.setApiDocs(val);
                    break;
                }
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "deprecated": {
                    String val = asText(node);
                    target.setDeprecated(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "out-type": {
                    String val = asText(node);
                    target.setOutType(val);
                    break;
                }
                case "param": {
                    java.util.List<org.apache.camel.model.rest.ParamDefinition> val = asFlatList(node, org.apache.camel.model.rest.ParamDefinition.class);
                    target.setParams(val);
                    break;
                }
                case "path": {
                    String val = asText(node);
                    target.setPath(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "response-message": {
                    java.util.List<org.apache.camel.model.rest.ResponseMessageDefinition> val = asFlatList(node, org.apache.camel.model.rest.ResponseMessageDefinition.class);
                    target.setResponseMsgs(val);
                    break;
                }
                case "route-id": {
                    String val = asText(node);
                    target.setRouteId(val);
                    break;
                }
                case "security": {
                    java.util.List<org.apache.camel.model.rest.SecurityDefinition> val = asFlatList(node, org.apache.camel.model.rest.SecurityDefinition.class);
                    target.setSecurity(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "to": {
                    org.apache.camel.model.ToDefinition val = asType(node, org.apache.camel.model.ToDefinition.class);
                    target.setTo(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "dns-service-discovery",
                    "dnsServiceDiscovery"
            },
            types = org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Dns Service Discovery",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "domain", type = "string", description = "The domain name;", displayName = "Domain"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "proto", type = "string", defaultValue = "_tcp", description = "The transport protocol of the desired service.", displayName = "Proto")
            }
    )
    public static class DnsServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<DnsServiceCallServiceDiscoveryConfiguration> {
        public DnsServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(DnsServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected DnsServiceCallServiceDiscoveryConfiguration newInstance() {
            return new DnsServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(DnsServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "domain": {
                    String val = asText(node);
                    target.setDomain(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "proto": {
                    String val = asText(node);
                    target.setProto(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "dynamic-router",
                    "dynamicRouter"
            },
            types = org.apache.camel.model.DynamicRouterDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Dynamic Router",
            description = "Route messages based on dynamic rules",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "cache-size", type = "number", description = "Sets the maximum size used by the org.apache.camel.spi.ProducerCache which is used to cache and reuse producers when using this dynamic router, when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.", displayName = "Cache Size"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to call that returns the endpoint(s) to route to in the dynamic routing. Important: The expression will be called in a while loop fashion, until the expression returns null which means the dynamic router is finished.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-endpoints", type = "boolean", description = "Ignore the invalidate endpoint exception when try to create a producer with that endpoint", displayName = "Ignore Invalid Endpoints"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "uri-delimiter", type = "string", defaultValue = ",", description = "Sets the uri delimiter to use", displayName = "Uri Delimiter")
            }
    )
    public static class DynamicRouterDefinitionDeserializer extends YamlDeserializerBase<DynamicRouterDefinition> {
        public DynamicRouterDefinitionDeserializer() {
            super(DynamicRouterDefinition.class);
        }

        @Override
        protected DynamicRouterDefinition newInstance() {
            return new DynamicRouterDefinition();
        }

        @Override
        protected boolean setProperty(DynamicRouterDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "cache-size": {
                    String val = asText(node);
                    target.setCacheSize(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "ignore-invalid-endpoints": {
                    String val = asText(node);
                    target.setIgnoreInvalidEndpoints(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "uri-delimiter": {
                    String val = asText(node);
                    target.setUriDelimiter(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.transformer.EndpointTransformerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "from-type", type = "string"),
                    @YamlProperty(name = "name", type = "string"),
                    @YamlProperty(name = "ref", type = "string"),
                    @YamlProperty(name = "scheme", type = "string"),
                    @YamlProperty(name = "to-type", type = "string"),
                    @YamlProperty(name = "uri", type = "string")
            }
    )
    public static class EndpointTransformerDefinitionDeserializer extends YamlDeserializerBase<EndpointTransformerDefinition> {
        public EndpointTransformerDefinitionDeserializer() {
            super(EndpointTransformerDefinition.class);
        }

        @Override
        protected EndpointTransformerDefinition newInstance() {
            return new EndpointTransformerDefinition();
        }

        @Override
        protected boolean setProperty(EndpointTransformerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "from-type": {
                    String val = asText(node);
                    target.setFromType(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "scheme": {
                    String val = asText(node);
                    target.setScheme(val);
                    break;
                }
                case "to-type": {
                    String val = asText(node);
                    target.setToType(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.validator.EndpointValidatorDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "ref", type = "string"),
                    @YamlProperty(name = "type", type = "string"),
                    @YamlProperty(name = "uri", type = "string")
            }
    )
    public static class EndpointValidatorDefinitionDeserializer extends YamlDeserializerBase<EndpointValidatorDefinition> {
        public EndpointValidatorDefinitionDeserializer() {
            super(EndpointValidatorDefinition.class);
        }

        @Override
        protected EndpointValidatorDefinition newInstance() {
            return new EndpointValidatorDefinition();
        }

        @Override
        protected boolean setProperty(EndpointValidatorDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "enrich",
            types = org.apache.camel.model.EnrichDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Enrich",
            description = "Enriches a message with data from a secondary resource",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "aggregate-on-exception", type = "boolean", description = "If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.", displayName = "Aggregate On Exception"),
                    @YamlProperty(name = "aggregation-strategy", type = "string", description = "Sets the AggregationStrategy to be used to merge the reply from the external service, into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.", displayName = "Aggregation Strategy"),
                    @YamlProperty(name = "aggregation-strategy-method-allow-null", type = "string", description = "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Allow Null"),
                    @YamlProperty(name = "aggregation-strategy-method-name", type = "string", description = "This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Name"),
                    @YamlProperty(name = "allow-optimised-components", type = "boolean", description = "Whether to allow components to optimise enricher if they are org.apache.camel.spi.SendDynamicAware .", displayName = "Allow Optimised Components"),
                    @YamlProperty(name = "cache-size", type = "number", description = "Sets the maximum size used by the org.apache.camel.spi.ProducerCache which is used to cache and reuse producer when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.", displayName = "Cache Size"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression that computes the endpoint uri to use as the resource endpoint to enrich from", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-endpoint", type = "boolean", description = "Ignore the invalidate endpoint exception when try to create a producer with that endpoint", displayName = "Ignore Invalid Endpoint"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "share-unit-of-work", type = "boolean", description = "Shares the org.apache.camel.spi.UnitOfWork with the parent and the resource exchange. Enrich will by default not share unit of work between the parent exchange and the resource exchange. This means the resource exchange has its own individual unit of work.", displayName = "Share Unit Of Work")
            }
    )
    public static class EnrichDefinitionDeserializer extends YamlDeserializerBase<EnrichDefinition> {
        public EnrichDefinitionDeserializer() {
            super(EnrichDefinition.class);
        }

        @Override
        protected EnrichDefinition newInstance() {
            return new EnrichDefinition();
        }

        @Override
        protected boolean setProperty(EnrichDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "aggregate-on-exception": {
                    String val = asText(node);
                    target.setAggregateOnException(val);
                    break;
                }
                case "aggregation-strategy": {
                    String val = asText(node);
                    target.setAggregationStrategy(val);
                    break;
                }
                case "aggregation-strategy-method-allow-null": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodAllowNull(val);
                    break;
                }
                case "aggregation-strategy-method-name": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodName(val);
                    break;
                }
                case "allow-optimised-components": {
                    String val = asText(node);
                    target.setAllowOptimisedComponents(val);
                    break;
                }
                case "cache-size": {
                    String val = asText(node);
                    target.setCacheSize(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "ignore-invalid-endpoint": {
                    String val = asText(node);
                    target.setIgnoreInvalidEndpoint(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "share-unit-of-work": {
                    String val = asText(node);
                    target.setShareUnitOfWork(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "error-handler",
                    "errorHandler"
            },
            types = org.apache.camel.model.ErrorHandlerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Error Handler",
            description = "Camel error handling.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "dead-letter-channel", type = "object:org.apache.camel.model.errorhandler.DeadLetterChannelDefinition", oneOf = "errorHandlerType"),
                    @YamlProperty(name = "default-error-handler", type = "object:org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition", oneOf = "errorHandlerType"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "jta-transaction-error-handler", type = "object:org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition", oneOf = "errorHandlerType"),
                    @YamlProperty(name = "no-error-handler", type = "object:org.apache.camel.model.errorhandler.NoErrorHandlerDefinition", oneOf = "errorHandlerType"),
                    @YamlProperty(name = "spring-transaction-error-handler", type = "object:org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition", oneOf = "errorHandlerType")
            }
    )
    public static class ErrorHandlerDefinitionDeserializer extends YamlDeserializerBase<ErrorHandlerDefinition> {
        public ErrorHandlerDefinitionDeserializer() {
            super(ErrorHandlerDefinition.class);
        }

        @Override
        protected ErrorHandlerDefinition newInstance() {
            return new ErrorHandlerDefinition();
        }

        @Override
        protected boolean setProperty(ErrorHandlerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "error-handler-type": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "dead-letter-channel": {
                    org.apache.camel.model.errorhandler.DeadLetterChannelDefinition val = asType(node, org.apache.camel.model.errorhandler.DeadLetterChannelDefinition.class);
                    target.setErrorHandlerType(val);
                    break;
                }
                case "default-error-handler": {
                    org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition val = asType(node, org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition.class);
                    target.setErrorHandlerType(val);
                    break;
                }
                case "no-error-handler": {
                    org.apache.camel.model.errorhandler.NoErrorHandlerDefinition val = asType(node, org.apache.camel.model.errorhandler.NoErrorHandlerDefinition.class);
                    target.setErrorHandlerType(val);
                    break;
                }
                case "jta-transaction-error-handler": {
                    org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition val = asType(node, org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition.class);
                    target.setErrorHandlerType(val);
                    break;
                }
                case "spring-transaction-error-handler": {
                    org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition val = asType(node, org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition.class);
                    target.setErrorHandlerType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "exchange-property",
                    "exchangeProperty"
            },
            inline = true,
            types = org.apache.camel.model.language.ExchangePropertyExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "ExchangeProperty",
            description = "Gets a property from the Exchange.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class ExchangePropertyExpressionDeserializer extends YamlDeserializerBase<ExchangePropertyExpression> {
        public ExchangePropertyExpressionDeserializer() {
            super(ExchangePropertyExpression.class);
        }

        @Override
        protected ExchangePropertyExpression newInstance() {
            return new ExchangePropertyExpression();
        }

        @Override
        protected ExchangePropertyExpression newInstance(String value) {
            return new ExchangePropertyExpression(value);
        }

        @Override
        protected boolean setProperty(ExchangePropertyExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "failover",
            types = org.apache.camel.model.loadbalancer.FailoverLoadBalancerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Failover",
            description = "In case of failures the exchange will be tried on the next endpoint.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "exception", type = "array:string", description = "A list of class names for specific exceptions to monitor. If no exceptions are configured then all exceptions are monitored", displayName = "Exception"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "maximum-failover-attempts", type = "string", defaultValue = "-1", description = "A value to indicate after X failover attempts we should exhaust (give up). Use -1 to indicate never give up and continuously try to failover. Use 0 to never failover. And use e.g. 3 to failover at most 3 times before giving up. his option can be used whether or not roundRobin is enabled or not.", displayName = "Maximum Failover Attempts"),
                    @YamlProperty(name = "round-robin", type = "string", description = "Whether or not the failover load balancer should operate in round robin mode or not. If not, then it will always start from the first endpoint when a new message is to be processed. In other words it restart from the top for every message. If round robin is enabled, then it keeps state and will continue with the next endpoint in a round robin fashion. You can also enable sticky mode together with round robin, if so then it will pick the last known good endpoint to use when starting the load balancing (instead of using the next when starting).", displayName = "Round Robin"),
                    @YamlProperty(name = "sticky", type = "string", description = "Whether or not the failover load balancer should operate in sticky mode or not. If not, then it will always start from the first endpoint when a new message is to be processed. In other words it restart from the top for every message. If sticky is enabled, then it keeps state and will continue with the last known good endpoint. You can also enable sticky mode together with round robin, if so then it will pick the last known good endpoint to use when starting the load balancing (instead of using the next when starting).", displayName = "Sticky")
            }
    )
    public static class FailoverLoadBalancerDefinitionDeserializer extends YamlDeserializerBase<FailoverLoadBalancerDefinition> {
        public FailoverLoadBalancerDefinitionDeserializer() {
            super(FailoverLoadBalancerDefinition.class);
        }

        @Override
        protected FailoverLoadBalancerDefinition newInstance() {
            return new FailoverLoadBalancerDefinition();
        }

        @Override
        protected boolean setProperty(FailoverLoadBalancerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "exception": {
                    java.util.List<String> val = asStringList(node);
                    target.setExceptions(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "maximum-failover-attempts": {
                    String val = asText(node);
                    target.setMaximumFailoverAttempts(val);
                    break;
                }
                case "round-robin": {
                    String val = asText(node);
                    target.setRoundRobin(val);
                    break;
                }
                case "sticky": {
                    String val = asText(node);
                    target.setSticky(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "fault-tolerance-configuration",
                    "faultToleranceConfiguration"
            },
            types = org.apache.camel.model.FaultToleranceConfigurationDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Fault Tolerance Configuration",
            description = "MicroProfile Fault Tolerance Circuit Breaker EIP configuration",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "bulkhead-enabled", type = "boolean", description = "Whether bulkhead is enabled or not on the circuit breaker. Default is false.", displayName = "Bulkhead Enabled"),
                    @YamlProperty(name = "bulkhead-executor-service", type = "string", description = "References to a custom thread pool to use when bulkhead is enabled.", displayName = "Bulkhead Executor Service"),
                    @YamlProperty(name = "bulkhead-max-concurrent-calls", type = "number", defaultValue = "10", description = "Configures the max amount of concurrent calls the bulkhead will support.", displayName = "Bulkhead Max Concurrent Calls"),
                    @YamlProperty(name = "bulkhead-waiting-task-queue", type = "number", defaultValue = "10", description = "Configures the task queue size for holding waiting tasks to be processed by the bulkhead.", displayName = "Bulkhead Waiting Task Queue"),
                    @YamlProperty(name = "circuit-breaker", type = "string", description = "Refers to an existing io.smallrye.faulttolerance.core.circuit.breaker.CircuitBreaker instance to lookup and use from the registry. When using this, then any other circuit breaker options are not in use.", displayName = "Circuit Breaker"),
                    @YamlProperty(name = "delay", type = "string", defaultValue = "5000", description = "Control how long the circuit breaker stays open. The default is 5 seconds.", displayName = "Delay"),
                    @YamlProperty(name = "failure-ratio", type = "number", defaultValue = "50", description = "Configures the failure rate threshold in percentage. If the failure rate is equal or greater than the threshold the CircuitBreaker transitions to open and starts short-circuiting calls. The threshold must be greater than 0 and not greater than 100. Default value is 50 percentage.", displayName = "Failure Ratio"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "request-volume-threshold", type = "number", defaultValue = "20", description = "Controls the size of the rolling window used when the circuit breaker is closed", displayName = "Request Volume Threshold"),
                    @YamlProperty(name = "success-threshold", type = "number", defaultValue = "1", description = "Controls the number of trial calls which are allowed when the circuit breaker is half-open", displayName = "Success Threshold"),
                    @YamlProperty(name = "timeout-duration", type = "string", defaultValue = "1000", description = "Configures the thread execution timeout. Default value is 1 second.", displayName = "Timeout Duration"),
                    @YamlProperty(name = "timeout-enabled", type = "boolean", description = "Whether timeout is enabled or not on the circuit breaker. Default is false.", displayName = "Timeout Enabled"),
                    @YamlProperty(name = "timeout-pool-size", type = "number", defaultValue = "10", description = "Configures the pool size of the thread pool when timeout is enabled. Default value is 10.", displayName = "Timeout Pool Size"),
                    @YamlProperty(name = "timeout-scheduled-executor-service", type = "string", description = "References to a custom thread pool to use when timeout is enabled", displayName = "Timeout Scheduled Executor Service")
            }
    )
    public static class FaultToleranceConfigurationDefinitionDeserializer extends YamlDeserializerBase<FaultToleranceConfigurationDefinition> {
        public FaultToleranceConfigurationDefinitionDeserializer() {
            super(FaultToleranceConfigurationDefinition.class);
        }

        @Override
        protected FaultToleranceConfigurationDefinition newInstance() {
            return new FaultToleranceConfigurationDefinition();
        }

        @Override
        protected boolean setProperty(FaultToleranceConfigurationDefinition target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "bulkhead-enabled": {
                    String val = asText(node);
                    target.setBulkheadEnabled(val);
                    break;
                }
                case "bulkhead-executor-service": {
                    String val = asText(node);
                    target.setBulkheadExecutorService(val);
                    break;
                }
                case "bulkhead-max-concurrent-calls": {
                    String val = asText(node);
                    target.setBulkheadMaxConcurrentCalls(val);
                    break;
                }
                case "bulkhead-waiting-task-queue": {
                    String val = asText(node);
                    target.setBulkheadWaitingTaskQueue(val);
                    break;
                }
                case "circuit-breaker": {
                    String val = asText(node);
                    target.setCircuitBreaker(val);
                    break;
                }
                case "delay": {
                    String val = asText(node);
                    target.setDelay(val);
                    break;
                }
                case "failure-ratio": {
                    String val = asText(node);
                    target.setFailureRatio(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "request-volume-threshold": {
                    String val = asText(node);
                    target.setRequestVolumeThreshold(val);
                    break;
                }
                case "success-threshold": {
                    String val = asText(node);
                    target.setSuccessThreshold(val);
                    break;
                }
                case "timeout-duration": {
                    String val = asText(node);
                    target.setTimeoutDuration(val);
                    break;
                }
                case "timeout-enabled": {
                    String val = asText(node);
                    target.setTimeoutEnabled(val);
                    break;
                }
                case "timeout-pool-size": {
                    String val = asText(node);
                    target.setTimeoutPoolSize(val);
                    break;
                }
                case "timeout-scheduled-executor-service": {
                    String val = asText(node);
                    target.setTimeoutScheduledExecutorService(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "fhir-json",
                    "fhirJson"
            },
            types = org.apache.camel.model.dataformat.FhirJsonDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "FHIR JSon",
            description = "Marshall and unmarshall FHIR objects to/from JSON.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "dont-encode-elements", type = "string", description = "If provided, specifies the elements which should NOT be encoded. Multiple elements can be separated by comma when using String parameter. Valid values for this field would include: Patient - Don't encode patient and all its children Patient.name - Don't encode the patient's name Patient.name.family - Don't encode the patient's family name .text - Don't encode the text element on any resource (only the very first position may contain a wildcard) DSTU2 note: Note that values including meta, such as Patient.meta will work for DSTU2 parsers, but values with subelements on meta such as Patient.meta.lastUpdated will only work in DSTU3 mode.", displayName = "Dont Encode Elements"),
                    @YamlProperty(name = "dont-strip-versions-from-references-at-paths", type = "string", description = "If supplied value(s), any resource references at the specified paths will have their resource versions encoded instead of being automatically stripped during the encoding process. This setting has no effect on the parsing process. Multiple elements can be separated by comma when using String parameter. This method provides a finer-grained level of control than setStripVersionsFromReferences(String) and any paths specified by this method will be encoded even if setStripVersionsFromReferences(String) has been set to true (which is the default)", displayName = "Dont Strip Versions From References At Paths"),
                    @YamlProperty(name = "encode-elements", type = "string", description = "If provided, specifies the elements which should be encoded, to the exclusion of all others. Multiple elements can be separated by comma when using String parameter. Valid values for this field would include: Patient - Encode patient and all its children Patient.name - Encode only the patient's name Patient.name.family - Encode only the patient's family name .text - Encode the text element on any resource (only the very first position may contain a wildcard) .(mandatory) - This is a special case which causes any mandatory fields (min 0) to be encoded", displayName = "Encode Elements"),
                    @YamlProperty(name = "encode-elements-applies-to-child-resources-only", type = "boolean", description = "If set to true (default is false), the values supplied to setEncodeElements(Set) will not be applied to the root resource (typically a Bundle), but will be applied to any sub-resources contained within it (i.e. search result resources in that bundle)", displayName = "Encode Elements Applies To Child Resources Only"),
                    @YamlProperty(name = "fhir-context", type = "string", description = "To use a custom fhir context. Reference to object of type ca.uhn.fhir.context.FhirContext", displayName = "Fhir Context"),
                    @YamlProperty(name = "fhir-version", type = "enum:DSTU2,DSTU2_HL7ORG,DSTU2_1,DSTU3,R4,R5", defaultValue = "R4", description = "The version of FHIR to use. Possible values are: DSTU2,DSTU2_HL7ORG,DSTU2_1,DSTU3,R4,R5", displayName = "Fhir Version"),
                    @YamlProperty(name = "force-resource-id", type = "string", description = "When encoding, force this resource ID to be encoded as the resource ID. Reference to object of type org.hl7.fhir.instance.model.api.IIdType", displayName = "Force Resource Id"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "omit-resource-id", type = "boolean", description = "If set to true (default is false) the ID of any resources being encoded will not be included in the output. Note that this does not apply to contained resources, only to root resources. In other words, if this is set to true, contained resources will still have local IDs but the outer/containing ID will not have an ID.", displayName = "Omit Resource Id"),
                    @YamlProperty(name = "override-resource-id-with-bundle-entry-full-url", type = "boolean", description = "If set to true (which is the default), the Bundle.entry.fullUrl will override the Bundle.entry.resource's resource id if the fullUrl is defined. This behavior happens when parsing the source data into a Bundle object. Set this to false if this is not the desired behavior (e.g. the client code wishes to perform additional validation checks between the fullUrl and the resource id).", displayName = "Override Resource Id With Bundle Entry Full Url"),
                    @YamlProperty(name = "parser-error-handler", type = "string", description = "Registers an error handler which will be invoked when any parse errors are found. Reference to object of type ca.uhn.fhir.parser.IParserErrorHandler", displayName = "Parser Error Handler"),
                    @YamlProperty(name = "parser-options", type = "string", description = "Sets the parser options object which will be used to supply default options to newly created parsers. Reference to object of type ca.uhn.fhir.context.ParserOptions.", displayName = "Parser Options"),
                    @YamlProperty(name = "prefer-types", type = "string", description = "If set (FQN class names), when parsing resources the parser will try to use the given types when possible, in the order that they are provided (from highest to lowest priority). For example, if a custom type which declares to implement the Patient resource is passed in here, and the parser is parsing a Bundle containing a Patient resource, the parser will use the given custom type. Multiple class names can be separated by comma.", displayName = "Prefer Types"),
                    @YamlProperty(name = "pretty-print", type = "boolean", description = "Sets the pretty print flag, meaning that the parser will encode resources with human-readable spacing and newlines between elements instead of condensing output as much as possible.", displayName = "Pretty Print"),
                    @YamlProperty(name = "server-base-url", type = "string", description = "Sets the server's base URL used by this parser. If a value is set, resource references will be turned into relative references if they are provided as absolute URLs but have a base matching the given base.", displayName = "Server Base Url"),
                    @YamlProperty(name = "strip-versions-from-references", type = "boolean", description = "If set to true (which is the default), resource references containing a version will have the version removed when the resource is encoded. This is generally good behaviour because in most situations, references from one resource to another should be to the resource by ID, not by ID and version. In some cases though, it may be desirable to preserve the version in resource links. In that case, this value should be set to false. This method provides the ability to globally disable reference encoding. If finer-grained control is needed, use setDontStripVersionsFromReferencesAtPaths(List)", displayName = "Strip Versions From References"),
                    @YamlProperty(name = "summary-mode", type = "boolean", description = "If set to true (default is false) only elements marked by the FHIR specification as being summary elements will be included.", displayName = "Summary Mode"),
                    @YamlProperty(name = "suppress-narratives", type = "boolean", description = "If set to true (default is false), narratives will not be included in the encoded values.", displayName = "Suppress Narratives")
            }
    )
    public static class FhirJsonDataFormatDeserializer extends YamlDeserializerBase<FhirJsonDataFormat> {
        public FhirJsonDataFormatDeserializer() {
            super(FhirJsonDataFormat.class);
        }

        @Override
        protected FhirJsonDataFormat newInstance() {
            return new FhirJsonDataFormat();
        }

        @Override
        protected boolean setProperty(FhirJsonDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "dont-encode-elements": {
                    String val = asText(node);
                    target.setDontEncodeElements(val);
                    break;
                }
                case "dont-strip-versions-from-references-at-paths": {
                    String val = asText(node);
                    target.setDontStripVersionsFromReferencesAtPaths(val);
                    break;
                }
                case "encode-elements": {
                    String val = asText(node);
                    target.setEncodeElements(val);
                    break;
                }
                case "encode-elements-applies-to-child-resources-only": {
                    String val = asText(node);
                    target.setEncodeElementsAppliesToChildResourcesOnly(val);
                    break;
                }
                case "fhir-context": {
                    String val = asText(node);
                    target.setFhirContext(val);
                    break;
                }
                case "fhir-version": {
                    String val = asText(node);
                    target.setFhirVersion(val);
                    break;
                }
                case "force-resource-id": {
                    String val = asText(node);
                    target.setForceResourceId(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "omit-resource-id": {
                    String val = asText(node);
                    target.setOmitResourceId(val);
                    break;
                }
                case "override-resource-id-with-bundle-entry-full-url": {
                    String val = asText(node);
                    target.setOverrideResourceIdWithBundleEntryFullUrl(val);
                    break;
                }
                case "parser-error-handler": {
                    String val = asText(node);
                    target.setParserErrorHandler(val);
                    break;
                }
                case "parser-options": {
                    String val = asText(node);
                    target.setParserOptions(val);
                    break;
                }
                case "prefer-types": {
                    String val = asText(node);
                    target.setPreferTypes(val);
                    break;
                }
                case "pretty-print": {
                    String val = asText(node);
                    target.setPrettyPrint(val);
                    break;
                }
                case "server-base-url": {
                    String val = asText(node);
                    target.setServerBaseUrl(val);
                    break;
                }
                case "strip-versions-from-references": {
                    String val = asText(node);
                    target.setStripVersionsFromReferences(val);
                    break;
                }
                case "summary-mode": {
                    String val = asText(node);
                    target.setSummaryMode(val);
                    break;
                }
                case "suppress-narratives": {
                    String val = asText(node);
                    target.setSuppressNarratives(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "fhir-xml",
                    "fhirXml"
            },
            types = org.apache.camel.model.dataformat.FhirXmlDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "FHIR XML",
            description = "Marshall and unmarshall FHIR objects to/from XML.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "dont-encode-elements", type = "string", description = "If provided, specifies the elements which should NOT be encoded. Multiple elements can be separated by comma when using String parameter. Valid values for this field would include: Patient - Don't encode patient and all its children Patient.name - Don't encode the patient's name Patient.name.family - Don't encode the patient's family name .text - Don't encode the text element on any resource (only the very first position may contain a wildcard) DSTU2 note: Note that values including meta, such as Patient.meta will work for DSTU2 parsers, but values with subelements on meta such as Patient.meta.lastUpdated will only work in DSTU3 mode.", displayName = "Dont Encode Elements"),
                    @YamlProperty(name = "dont-strip-versions-from-references-at-paths", type = "string", description = "If supplied value(s), any resource references at the specified paths will have their resource versions encoded instead of being automatically stripped during the encoding process. This setting has no effect on the parsing process. Multiple elements can be separated by comma when using String parameter. This method provides a finer-grained level of control than setStripVersionsFromReferences(String) and any paths specified by this method will be encoded even if setStripVersionsFromReferences(String) has been set to true (which is the default)", displayName = "Dont Strip Versions From References At Paths"),
                    @YamlProperty(name = "encode-elements", type = "string", description = "If provided, specifies the elements which should be encoded, to the exclusion of all others. Multiple elements can be separated by comma when using String parameter. Valid values for this field would include: Patient - Encode patient and all its children Patient.name - Encode only the patient's name Patient.name.family - Encode only the patient's family name .text - Encode the text element on any resource (only the very first position may contain a wildcard) .(mandatory) - This is a special case which causes any mandatory fields (min 0) to be encoded", displayName = "Encode Elements"),
                    @YamlProperty(name = "encode-elements-applies-to-child-resources-only", type = "boolean", description = "If set to true (default is false), the values supplied to setEncodeElements(Set) will not be applied to the root resource (typically a Bundle), but will be applied to any sub-resources contained within it (i.e. search result resources in that bundle)", displayName = "Encode Elements Applies To Child Resources Only"),
                    @YamlProperty(name = "fhir-context", type = "string", description = "To use a custom fhir context. Reference to object of type ca.uhn.fhir.context.FhirContext", displayName = "Fhir Context"),
                    @YamlProperty(name = "fhir-version", type = "enum:DSTU2,DSTU2_HL7ORG,DSTU2_1,DSTU3,R4,R5", defaultValue = "R4", description = "The version of FHIR to use. Possible values are: DSTU2,DSTU2_HL7ORG,DSTU2_1,DSTU3,R4,R5", displayName = "Fhir Version"),
                    @YamlProperty(name = "force-resource-id", type = "string", description = "When encoding, force this resource ID to be encoded as the resource ID. Reference to object of type org.hl7.fhir.instance.model.api.IIdType", displayName = "Force Resource Id"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "omit-resource-id", type = "boolean", description = "If set to true (default is false) the ID of any resources being encoded will not be included in the output. Note that this does not apply to contained resources, only to root resources. In other words, if this is set to true, contained resources will still have local IDs but the outer/containing ID will not have an ID.", displayName = "Omit Resource Id"),
                    @YamlProperty(name = "override-resource-id-with-bundle-entry-full-url", type = "boolean", description = "If set to true (which is the default), the Bundle.entry.fullUrl will override the Bundle.entry.resource's resource id if the fullUrl is defined. This behavior happens when parsing the source data into a Bundle object. Set this to false if this is not the desired behavior (e.g. the client code wishes to perform additional validation checks between the fullUrl and the resource id).", displayName = "Override Resource Id With Bundle Entry Full Url"),
                    @YamlProperty(name = "parser-error-handler", type = "string", description = "Registers an error handler which will be invoked when any parse errors are found. Reference to object of type ca.uhn.fhir.parser.IParserErrorHandler", displayName = "Parser Error Handler"),
                    @YamlProperty(name = "parser-options", type = "string", description = "Sets the parser options object which will be used to supply default options to newly created parsers. Reference to object of type ca.uhn.fhir.context.ParserOptions.", displayName = "Parser Options"),
                    @YamlProperty(name = "prefer-types", type = "string", description = "If set (FQN class names), when parsing resources the parser will try to use the given types when possible, in the order that they are provided (from highest to lowest priority). For example, if a custom type which declares to implement the Patient resource is passed in here, and the parser is parsing a Bundle containing a Patient resource, the parser will use the given custom type. Multiple class names can be separated by comma.", displayName = "Prefer Types"),
                    @YamlProperty(name = "pretty-print", type = "boolean", description = "Sets the pretty print flag, meaning that the parser will encode resources with human-readable spacing and newlines between elements instead of condensing output as much as possible.", displayName = "Pretty Print"),
                    @YamlProperty(name = "server-base-url", type = "string", description = "Sets the server's base URL used by this parser. If a value is set, resource references will be turned into relative references if they are provided as absolute URLs but have a base matching the given base.", displayName = "Server Base Url"),
                    @YamlProperty(name = "strip-versions-from-references", type = "boolean", description = "If set to true (which is the default), resource references containing a version will have the version removed when the resource is encoded. This is generally good behaviour because in most situations, references from one resource to another should be to the resource by ID, not by ID and version. In some cases though, it may be desirable to preserve the version in resource links. In that case, this value should be set to false. This method provides the ability to globally disable reference encoding. If finer-grained control is needed, use setDontStripVersionsFromReferencesAtPaths(List)", displayName = "Strip Versions From References"),
                    @YamlProperty(name = "summary-mode", type = "boolean", description = "If set to true (default is false) only elements marked by the FHIR specification as being summary elements will be included.", displayName = "Summary Mode"),
                    @YamlProperty(name = "suppress-narratives", type = "boolean", description = "If set to true (default is false), narratives will not be included in the encoded values.", displayName = "Suppress Narratives")
            }
    )
    public static class FhirXmlDataFormatDeserializer extends YamlDeserializerBase<FhirXmlDataFormat> {
        public FhirXmlDataFormatDeserializer() {
            super(FhirXmlDataFormat.class);
        }

        @Override
        protected FhirXmlDataFormat newInstance() {
            return new FhirXmlDataFormat();
        }

        @Override
        protected boolean setProperty(FhirXmlDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "dont-encode-elements": {
                    String val = asText(node);
                    target.setDontEncodeElements(val);
                    break;
                }
                case "dont-strip-versions-from-references-at-paths": {
                    String val = asText(node);
                    target.setDontStripVersionsFromReferencesAtPaths(val);
                    break;
                }
                case "encode-elements": {
                    String val = asText(node);
                    target.setEncodeElements(val);
                    break;
                }
                case "encode-elements-applies-to-child-resources-only": {
                    String val = asText(node);
                    target.setEncodeElementsAppliesToChildResourcesOnly(val);
                    break;
                }
                case "fhir-context": {
                    String val = asText(node);
                    target.setFhirContext(val);
                    break;
                }
                case "fhir-version": {
                    String val = asText(node);
                    target.setFhirVersion(val);
                    break;
                }
                case "force-resource-id": {
                    String val = asText(node);
                    target.setForceResourceId(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "omit-resource-id": {
                    String val = asText(node);
                    target.setOmitResourceId(val);
                    break;
                }
                case "override-resource-id-with-bundle-entry-full-url": {
                    String val = asText(node);
                    target.setOverrideResourceIdWithBundleEntryFullUrl(val);
                    break;
                }
                case "parser-error-handler": {
                    String val = asText(node);
                    target.setParserErrorHandler(val);
                    break;
                }
                case "parser-options": {
                    String val = asText(node);
                    target.setParserOptions(val);
                    break;
                }
                case "prefer-types": {
                    String val = asText(node);
                    target.setPreferTypes(val);
                    break;
                }
                case "pretty-print": {
                    String val = asText(node);
                    target.setPrettyPrint(val);
                    break;
                }
                case "server-base-url": {
                    String val = asText(node);
                    target.setServerBaseUrl(val);
                    break;
                }
                case "strip-versions-from-references": {
                    String val = asText(node);
                    target.setStripVersionsFromReferences(val);
                    break;
                }
                case "summary-mode": {
                    String val = asText(node);
                    target.setSummaryMode(val);
                    break;
                }
                case "suppress-narratives": {
                    String val = asText(node);
                    target.setSuppressNarratives(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "filter",
            types = org.apache.camel.model.FilterDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Filter",
            description = "Filter out messages based using a predicate",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to determine if the message should be filtered or not. If the expression returns an empty value or false then the message is filtered (dropped), otherwise the message is continued being routed.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "status-property-name", type = "string", description = "Name of exchange property to use for storing the status of the filtering. Setting this allows to know if the filter predicate evaluated as true or false.", displayName = "Status Property Name"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class FilterDefinitionDeserializer extends YamlDeserializerBase<FilterDefinition> {
        public FilterDefinitionDeserializer() {
            super(FilterDefinition.class);
        }

        @Override
        protected FilterDefinition newInstance() {
            return new FilterDefinition();
        }

        @Override
        protected boolean setProperty(FilterDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "status-property-name": {
                    String val = asText(node);
                    target.setStatusPropertyName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "do-finally",
                    "doFinally"
            },
            types = org.apache.camel.model.FinallyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Do Finally",
            description = "Path traversed when a try, catch, finally block exits",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class FinallyDefinitionDeserializer extends YamlDeserializerBase<FinallyDefinition> {
        public FinallyDefinitionDeserializer() {
            super(FinallyDefinition.class);
        }

        @Override
        protected FinallyDefinition newInstance() {
            return new FinallyDefinition();
        }

        @Override
        protected boolean setProperty(FinallyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "flatpack",
            types = org.apache.camel.model.dataformat.FlatpackDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Flatpack",
            description = "Marshal and unmarshal Java lists and maps to/from flat files (such as CSV, delimited, or fixed length formats) using Flatpack library.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-short-lines", type = "boolean", description = "Allows for lines to be shorter than expected and ignores the extra characters", displayName = "Allow Short Lines"),
                    @YamlProperty(name = "definition", type = "string", description = "The flatpack pzmap configuration file. Can be omitted in simpler situations, but its preferred to use the pzmap.", displayName = "Definition"),
                    @YamlProperty(name = "delimiter", type = "string", defaultValue = ",", description = "The delimiter char (could be ; , or similar)", displayName = "Delimiter"),
                    @YamlProperty(name = "fixed", type = "boolean", description = "Delimited or fixed. Is by default false = delimited", displayName = "Fixed"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-extra-columns", type = "boolean", description = "Allows for lines to be longer than expected and ignores the extra characters.", displayName = "Ignore Extra Columns"),
                    @YamlProperty(name = "ignore-first-record", type = "boolean", description = "Whether the first line is ignored for delimited files (for the column headers). Is by default true.", displayName = "Ignore First Record"),
                    @YamlProperty(name = "parser-factory-ref", type = "string", description = "References to a custom parser factory to lookup in the registry", displayName = "Parser Factory Ref"),
                    @YamlProperty(name = "text-qualifier", type = "string", description = "If the text is qualified with a character. Uses quote character by default.", displayName = "Text Qualifier")
            }
    )
    public static class FlatpackDataFormatDeserializer extends YamlDeserializerBase<FlatpackDataFormat> {
        public FlatpackDataFormatDeserializer() {
            super(FlatpackDataFormat.class);
        }

        @Override
        protected FlatpackDataFormat newInstance() {
            return new FlatpackDataFormat();
        }

        @Override
        protected boolean setProperty(FlatpackDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-short-lines": {
                    String val = asText(node);
                    target.setAllowShortLines(val);
                    break;
                }
                case "definition": {
                    String val = asText(node);
                    target.setDefinition(val);
                    break;
                }
                case "delimiter": {
                    String val = asText(node);
                    target.setDelimiter(val);
                    break;
                }
                case "fixed": {
                    String val = asText(node);
                    target.setFixed(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ignore-extra-columns": {
                    String val = asText(node);
                    target.setIgnoreExtraColumns(val);
                    break;
                }
                case "ignore-first-record": {
                    String val = asText(node);
                    target.setIgnoreFirstRecord(val);
                    break;
                }
                case "parser-factory-ref": {
                    String val = asText(node);
                    target.setParserFactoryRef(val);
                    break;
                }
                case "text-qualifier": {
                    String val = asText(node);
                    target.setTextQualifier(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "get",
            types = org.apache.camel.model.rest.GetDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Get",
            description = "Rest GET command",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-docs", type = "boolean", description = "Whether to include or exclude this rest operation in API documentation. The default value is true.", displayName = "Api Docs"),
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json. This option will override what may be configured on a parent level", displayName = "Consumes"),
                    @YamlProperty(name = "deprecated", type = "boolean", description = "Marks this rest operation as deprecated in OpenApi documentation.", displayName = "Deprecated"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this REST service from the route during build time. Once an REST service has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "out-type", type = "string", description = "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Out Type"),
                    @YamlProperty(name = "param", type = "array:org.apache.camel.model.rest.ParamDefinition"),
                    @YamlProperty(name = "path", type = "string", description = "The path mapping URIs of this REST operation such as /{id}.", displayName = "Path"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json This option will override what may be configured on a parent level", displayName = "Produces"),
                    @YamlProperty(name = "response-message", type = "array:org.apache.camel.model.rest.ResponseMessageDefinition"),
                    @YamlProperty(name = "route-id", type = "string", description = "Sets the id of the route", displayName = "Route Id"),
                    @YamlProperty(name = "security", type = "array:org.apache.camel.model.rest.SecurityDefinition"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do. This option will override what may be configured on a parent level", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "to", type = "object:org.apache.camel.model.ToDefinition", description = "The Camel endpoint this REST service will call, such as a direct endpoint to link to an existing route that handles this REST call.", displayName = "To"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level. The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Type")
            }
    )
    public static class GetDefinitionDeserializer extends YamlDeserializerBase<GetDefinition> {
        public GetDefinitionDeserializer() {
            super(GetDefinition.class);
        }

        @Override
        protected GetDefinition newInstance() {
            return new GetDefinition();
        }

        @Override
        protected boolean setProperty(GetDefinition target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "api-docs": {
                    String val = asText(node);
                    target.setApiDocs(val);
                    break;
                }
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "deprecated": {
                    String val = asText(node);
                    target.setDeprecated(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "out-type": {
                    String val = asText(node);
                    target.setOutType(val);
                    break;
                }
                case "param": {
                    java.util.List<org.apache.camel.model.rest.ParamDefinition> val = asFlatList(node, org.apache.camel.model.rest.ParamDefinition.class);
                    target.setParams(val);
                    break;
                }
                case "path": {
                    String val = asText(node);
                    target.setPath(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "response-message": {
                    java.util.List<org.apache.camel.model.rest.ResponseMessageDefinition> val = asFlatList(node, org.apache.camel.model.rest.ResponseMessageDefinition.class);
                    target.setResponseMsgs(val);
                    break;
                }
                case "route-id": {
                    String val = asText(node);
                    target.setRouteId(val);
                    break;
                }
                case "security": {
                    java.util.List<org.apache.camel.model.rest.SecurityDefinition> val = asFlatList(node, org.apache.camel.model.rest.SecurityDefinition.class);
                    target.setSecurity(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "to": {
                    org.apache.camel.model.ToDefinition val = asType(node, org.apache.camel.model.ToDefinition.class);
                    target.setTo(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "global-option",
                    "globalOption"
            },
            types = org.apache.camel.model.GlobalOptionDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Global Option",
            description = "Models a string key/value pair for configuring some global options on a Camel context such as max debug log length.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "key", type = "string", required = true, description = "Global option key", displayName = "Key"),
                    @YamlProperty(name = "value", type = "string", required = true, description = "Global option value", displayName = "Value")
            }
    )
    public static class GlobalOptionDefinitionDeserializer extends YamlDeserializerBase<GlobalOptionDefinition> {
        public GlobalOptionDefinitionDeserializer() {
            super(GlobalOptionDefinition.class);
        }

        @Override
        protected GlobalOptionDefinition newInstance() {
            return new GlobalOptionDefinition();
        }

        @Override
        protected boolean setProperty(GlobalOptionDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "global-options",
                    "globalOptions"
            },
            types = org.apache.camel.model.GlobalOptionsDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Global Options",
            description = "Models a series of string key/value pairs for configuring some global options on a Camel context such as max debug log length.",
            deprecated = false,
            properties = @YamlProperty(name = "global-option", type = "array:org.apache.camel.model.GlobalOptionDefinition", description = "A series of global options as key value pairs", displayName = "Global Option")
    )
    public static class GlobalOptionsDefinitionDeserializer extends YamlDeserializerBase<GlobalOptionsDefinition> {
        public GlobalOptionsDefinitionDeserializer() {
            super(GlobalOptionsDefinition.class);
        }

        @Override
        protected GlobalOptionsDefinition newInstance() {
            return new GlobalOptionsDefinition();
        }

        @Override
        protected boolean setProperty(GlobalOptionsDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "global-option": {
                    java.util.List<org.apache.camel.model.GlobalOptionDefinition> val = asFlatList(node, org.apache.camel.model.GlobalOptionDefinition.class);
                    target.setGlobalOptions(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "grok",
            types = org.apache.camel.model.dataformat.GrokDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Grok",
            description = "Unmarshal unstructured data to objects using Logstash based Grok patterns.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-multiple-matches-per-line", type = "boolean", description = "If false, every line of input is matched for pattern only once. Otherwise the line can be scanned multiple times when non-terminal pattern is used.", displayName = "Allow Multiple Matches Per Line"),
                    @YamlProperty(name = "flattened", type = "boolean", description = "Turns on flattened mode. In flattened mode the exception is thrown when there are multiple pattern matches with same key.", displayName = "Flattened"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "named-only", type = "boolean", description = "Whether to capture named expressions only or not (i.e. %{IP:ip} but not ${IP})", displayName = "Named Only"),
                    @YamlProperty(name = "pattern", type = "string", required = true, description = "The grok pattern to match lines of input", displayName = "Pattern")
            }
    )
    public static class GrokDataFormatDeserializer extends YamlDeserializerBase<GrokDataFormat> {
        public GrokDataFormatDeserializer() {
            super(GrokDataFormat.class);
        }

        @Override
        protected GrokDataFormat newInstance() {
            return new GrokDataFormat();
        }

        @Override
        protected boolean setProperty(GrokDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-multiple-matches-per-line": {
                    String val = asText(node);
                    target.setAllowMultipleMatchesPerLine(val);
                    break;
                }
                case "flattened": {
                    String val = asText(node);
                    target.setFlattened(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "named-only": {
                    String val = asText(node);
                    target.setNamedOnly(val);
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "groovy",
            inline = true,
            types = org.apache.camel.model.language.GroovyExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Groovy",
            description = "Evaluates a Groovy script.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class GroovyExpressionDeserializer extends YamlDeserializerBase<GroovyExpression> {
        public GroovyExpressionDeserializer() {
            super(GroovyExpression.class);
        }

        @Override
        protected GroovyExpression newInstance() {
            return new GroovyExpression();
        }

        @Override
        protected GroovyExpression newInstance(String value) {
            return new GroovyExpression(value);
        }

        @Override
        protected boolean setProperty(GroovyExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "gzip-deflater",
                    "gzipDeflater"
            },
            types = org.apache.camel.model.dataformat.GzipDeflaterDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "GZip Deflater",
            description = "Compress and decompress messages using java.util.zip.GZIPStream.",
            deprecated = false,
            properties = @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
    )
    public static class GzipDeflaterDataFormatDeserializer extends YamlDeserializerBase<GzipDeflaterDataFormat> {
        public GzipDeflaterDataFormatDeserializer() {
            super(GzipDeflaterDataFormat.class);
        }

        @Override
        protected GzipDeflaterDataFormat newInstance() {
            return new GzipDeflaterDataFormat();
        }

        @Override
        protected boolean setProperty(GzipDeflaterDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "hl7",
            types = org.apache.camel.model.dataformat.HL7DataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "HL7",
            description = "Marshal and unmarshal HL7 (Health Care) model objects using the HL7 MLLP codec.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "validate", type = "boolean", description = "Whether to validate the HL7 message Is by default true.", displayName = "Validate")
            }
    )
    public static class HL7DataFormatDeserializer extends YamlDeserializerBase<HL7DataFormat> {
        public HL7DataFormatDeserializer() {
            super(HL7DataFormat.class);
        }

        @Override
        protected HL7DataFormat newInstance() {
            return new HL7DataFormat();
        }

        @Override
        protected boolean setProperty(HL7DataFormat target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "validate": {
                    String val = asText(node);
                    target.setValidate(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "head",
            types = org.apache.camel.model.rest.HeadDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Head",
            description = "Rest HEAD command",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-docs", type = "boolean", description = "Whether to include or exclude this rest operation in API documentation. The default value is true.", displayName = "Api Docs"),
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json. This option will override what may be configured on a parent level", displayName = "Consumes"),
                    @YamlProperty(name = "deprecated", type = "boolean", description = "Marks this rest operation as deprecated in OpenApi documentation.", displayName = "Deprecated"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this REST service from the route during build time. Once an REST service has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "out-type", type = "string", description = "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Out Type"),
                    @YamlProperty(name = "param", type = "array:org.apache.camel.model.rest.ParamDefinition"),
                    @YamlProperty(name = "path", type = "string", description = "The path mapping URIs of this REST operation such as /{id}.", displayName = "Path"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json This option will override what may be configured on a parent level", displayName = "Produces"),
                    @YamlProperty(name = "response-message", type = "array:org.apache.camel.model.rest.ResponseMessageDefinition"),
                    @YamlProperty(name = "route-id", type = "string", description = "Sets the id of the route", displayName = "Route Id"),
                    @YamlProperty(name = "security", type = "array:org.apache.camel.model.rest.SecurityDefinition"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do. This option will override what may be configured on a parent level", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "to", type = "object:org.apache.camel.model.ToDefinition", description = "The Camel endpoint this REST service will call, such as a direct endpoint to link to an existing route that handles this REST call.", displayName = "To"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level. The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Type")
            }
    )
    public static class HeadDefinitionDeserializer extends YamlDeserializerBase<HeadDefinition> {
        public HeadDefinitionDeserializer() {
            super(HeadDefinition.class);
        }

        @Override
        protected HeadDefinition newInstance() {
            return new HeadDefinition();
        }

        @Override
        protected boolean setProperty(HeadDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "api-docs": {
                    String val = asText(node);
                    target.setApiDocs(val);
                    break;
                }
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "deprecated": {
                    String val = asText(node);
                    target.setDeprecated(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "out-type": {
                    String val = asText(node);
                    target.setOutType(val);
                    break;
                }
                case "param": {
                    java.util.List<org.apache.camel.model.rest.ParamDefinition> val = asFlatList(node, org.apache.camel.model.rest.ParamDefinition.class);
                    target.setParams(val);
                    break;
                }
                case "path": {
                    String val = asText(node);
                    target.setPath(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "response-message": {
                    java.util.List<org.apache.camel.model.rest.ResponseMessageDefinition> val = asFlatList(node, org.apache.camel.model.rest.ResponseMessageDefinition.class);
                    target.setResponseMsgs(val);
                    break;
                }
                case "route-id": {
                    String val = asText(node);
                    target.setRouteId(val);
                    break;
                }
                case "security": {
                    java.util.List<org.apache.camel.model.rest.SecurityDefinition> val = asFlatList(node, org.apache.camel.model.rest.SecurityDefinition.class);
                    target.setSecurity(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "to": {
                    org.apache.camel.model.ToDefinition val = asType(node, org.apache.camel.model.ToDefinition.class);
                    target.setTo(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "header",
            inline = true,
            types = org.apache.camel.model.language.HeaderExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Header",
            description = "Gets a header from the Exchange.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class HeaderExpressionDeserializer extends YamlDeserializerBase<HeaderExpression> {
        public HeaderExpressionDeserializer() {
            super(HeaderExpression.class);
        }

        @Override
        protected HeaderExpression newInstance() {
            return new HeaderExpression();
        }

        @Override
        protected HeaderExpression newInstance(String value) {
            return new HeaderExpression(value);
        }

        @Override
        protected boolean setProperty(HeaderExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "healthy-service-filter",
                    "healthyServiceFilter"
            },
            types = org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Healthy Service Filter",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class HealthyServiceCallServiceFilterConfigurationDeserializer extends YamlDeserializerBase<HealthyServiceCallServiceFilterConfiguration> {
        public HealthyServiceCallServiceFilterConfigurationDeserializer() {
            super(HealthyServiceCallServiceFilterConfiguration.class);
        }

        @Override
        protected HealthyServiceCallServiceFilterConfiguration newInstance() {
            return new HealthyServiceCallServiceFilterConfiguration();
        }

        @Override
        protected boolean setProperty(HealthyServiceCallServiceFilterConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "hl7terser",
            inline = true,
            types = org.apache.camel.model.language.Hl7TerserExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "HL7 Terser",
            description = "Get the value of a HL7 message field specified by terse location specification syntax.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "header-name", type = "string", description = "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set.", displayName = "Header Name"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "property-name", type = "string", description = "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set.", displayName = "Property Name"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class Hl7TerserExpressionDeserializer extends YamlDeserializerBase<Hl7TerserExpression> {
        public Hl7TerserExpressionDeserializer() {
            super(Hl7TerserExpression.class);
        }

        @Override
        protected Hl7TerserExpression newInstance() {
            return new Hl7TerserExpression();
        }

        @Override
        protected Hl7TerserExpression newInstance(String value) {
            return new Hl7TerserExpression(value);
        }

        @Override
        protected boolean setProperty(Hl7TerserExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "header-name": {
                    String val = asText(node);
                    target.setHeaderName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "property-name": {
                    String val = asText(node);
                    target.setPropertyName(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "ical",
            types = org.apache.camel.model.dataformat.IcalDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "iCal",
            description = "Marshal and unmarshal iCal (.ics) documents to/from model objects.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "validating", type = "boolean", description = "Whether to validate.", displayName = "Validating")
            }
    )
    public static class IcalDataFormatDeserializer extends YamlDeserializerBase<IcalDataFormat> {
        public IcalDataFormatDeserializer() {
            super(IcalDataFormat.class);
        }

        @Override
        protected IcalDataFormat newInstance() {
            return new IcalDataFormat();
        }

        @Override
        protected boolean setProperty(IcalDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "validating": {
                    String val = asText(node);
                    target.setValidating(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "idempotent-consumer",
                    "idempotentConsumer"
            },
            types = org.apache.camel.model.IdempotentConsumerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Idempotent Consumer",
            description = "Filters out duplicate messages",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "completion-eager", type = "boolean", description = "Sets whether to complete the idempotent consumer eager or when the exchange is done. If this option is true to complete eager, then the idempotent consumer will trigger its completion when the exchange reached the end of the block of the idempotent consumer pattern. So if the exchange is continued routed after the block ends, then whatever happens there does not affect the state. If this option is false (default) to not complete eager, then the idempotent consumer will complete when the exchange is done being routed. So if the exchange is continued routed after the block ends, then whatever happens there also affect the state. For example if the exchange failed due to an exception, then the state of the idempotent consumer will be a rollback.", displayName = "Completion Eager"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "eager", type = "boolean", description = "Sets whether to eagerly add the key to the idempotent repository or wait until the exchange is complete. Eager is default enabled.", displayName = "Eager"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression used to calculate the correlation key to use for duplicate check. The Exchange which has the same correlation key is regarded as a duplicate and will be rejected.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "idempotent-repository", type = "string", required = true, description = "Sets the reference name of the message id repository", displayName = "Idempotent Repository"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "remove-on-failure", type = "boolean", description = "Sets whether to remove or keep the key on failure. The default behavior is to remove the key on failure.", displayName = "Remove On Failure"),
                    @YamlProperty(name = "skip-duplicate", type = "boolean", description = "Sets whether to skip duplicates or not. The default behavior is to skip duplicates. A duplicate message would have the Exchange property org.apache.camel.Exchange#DUPLICATE_MESSAGE set to a Boolean#TRUE value. A none duplicate message will not have this property set.", displayName = "Skip Duplicate"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class IdempotentConsumerDefinitionDeserializer extends YamlDeserializerBase<IdempotentConsumerDefinition> {
        public IdempotentConsumerDefinitionDeserializer() {
            super(IdempotentConsumerDefinition.class);
        }

        @Override
        protected IdempotentConsumerDefinition newInstance() {
            return new IdempotentConsumerDefinition();
        }

        @Override
        protected boolean setProperty(IdempotentConsumerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "completion-eager": {
                    String val = asText(node);
                    target.setCompletionEager(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "eager": {
                    String val = asText(node);
                    target.setEager(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "idempotent-repository": {
                    String val = asText(node);
                    target.setIdempotentRepository(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "remove-on-failure": {
                    String val = asText(node);
                    target.setRemoveOnFailure(val);
                    break;
                }
                case "skip-duplicate": {
                    String val = asText(node);
                    target.setSkipDuplicate(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "input-type",
                    "inputType"
            },
            types = org.apache.camel.model.InputTypeDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Input Type",
            description = "Set the expected data type of the input message. If the actual message type is different at runtime, camel look for a required Transformer and apply if exists. If validate attribute is true then camel applies Validator as well. Type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name' is a fully qualified class name. For example {code java:java.lang.String} , {code json:ABCOrder} . It's also possible to specify only scheme part, so that it works like a wildcard. If only 'xml' is specified, all the XML message matches. It's handy to add only one transformer/validator for all the transformation from/to XML.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "urn", type = "string", required = true, description = "The input type URN.", displayName = "Urn"),
                    @YamlProperty(name = "validate", type = "boolean", description = "Whether if validation is required for this input type.", displayName = "Validate")
            }
    )
    public static class InputTypeDefinitionDeserializer extends YamlDeserializerBase<InputTypeDefinition> {
        public InputTypeDefinitionDeserializer() {
            super(InputTypeDefinition.class);
        }

        @Override
        protected InputTypeDefinition newInstance() {
            return new InputTypeDefinition();
        }

        @Override
        protected boolean setProperty(InputTypeDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "urn": {
                    String val = asText(node);
                    target.setUrn(val);
                    break;
                }
                case "validate": {
                    String val = asText(node);
                    target.setValidate(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlIn
    @YamlType(
            nodes = "intercept",
            types = org.apache.camel.model.InterceptDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Intercept",
            description = "Intercepts a message at each step in the route",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class InterceptDefinitionDeserializer extends YamlDeserializerBase<InterceptDefinition> {
        public InterceptDefinitionDeserializer() {
            super(InterceptDefinition.class);
        }

        @Override
        protected InterceptDefinition newInstance() {
            return new InterceptDefinition();
        }

        @Override
        protected boolean setProperty(InterceptDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlIn
    @YamlType(
            nodes = {
                    "intercept-from",
                    "interceptFrom"
            },
            inline = true,
            types = org.apache.camel.model.InterceptFromDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Intercept From",
            description = "Intercepts incoming messages",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "uri", type = "string", description = "Intercept incoming messages from the uri or uri pattern. If this option is not configured, then all incoming messages is intercepted.", displayName = "Uri")
            }
    )
    public static class InterceptFromDefinitionDeserializer extends YamlDeserializerBase<InterceptFromDefinition> {
        public InterceptFromDefinitionDeserializer() {
            super(InterceptFromDefinition.class);
        }

        @Override
        protected InterceptFromDefinition newInstance() {
            return new InterceptFromDefinition();
        }

        @Override
        protected InterceptFromDefinition newInstance(String value) {
            return new InterceptFromDefinition(value);
        }

        @Override
        protected boolean setProperty(InterceptFromDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlIn
    @YamlType(
            nodes = {
                    "intercept-send-to-endpoint",
                    "interceptSendToEndpoint"
            },
            inline = true,
            types = org.apache.camel.model.InterceptSendToEndpointDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Intercept Send To Endpoint",
            description = "Intercepts messages being sent to an endpoint",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "after-uri", type = "string", description = "After sending to the endpoint then send the message to this uri which allows to process its result.", displayName = "After Uri"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "skip-send-to-original-endpoint", type = "string", description = "If set to true then the message is not sent to the original endpoint. By default (false) the message is both intercepted and then sent to the original endpoint.", displayName = "Skip Send To Original Endpoint"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "uri", type = "string", required = true, description = "Intercept sending to the uri or uri pattern.", displayName = "Uri")
            }
    )
    public static class InterceptSendToEndpointDefinitionDeserializer extends YamlDeserializerBase<InterceptSendToEndpointDefinition> {
        public InterceptSendToEndpointDefinitionDeserializer() {
            super(InterceptSendToEndpointDefinition.class);
        }

        @Override
        protected InterceptSendToEndpointDefinition newInstance() {
            return new InterceptSendToEndpointDefinition();
        }

        @Override
        protected InterceptSendToEndpointDefinition newInstance(String value) {
            return new InterceptSendToEndpointDefinition(value);
        }

        @Override
        protected boolean setProperty(InterceptSendToEndpointDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "after-uri": {
                    String val = asText(node);
                    target.setAfterUri(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "skip-send-to-original-endpoint": {
                    String val = asText(node);
                    target.setSkipSendToOriginalEndpoint(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "jackson-xml",
                    "jacksonXml"
            },
            types = org.apache.camel.model.dataformat.JacksonXMLDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Jackson XML",
            description = "Unmarshal an XML payloads to POJOs and back using XMLMapper extension of Jackson.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-jms-type", type = "boolean", description = "Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.", displayName = "Allow Jms Type"),
                    @YamlProperty(name = "allow-unmarshall-type", type = "boolean", description = "If enabled then Jackson is allowed to attempt to use the CamelJacksonUnmarshalType header during the unmarshalling. This should only be enabled when desired to be used.", displayName = "Allow Unmarshall Type"),
                    @YamlProperty(name = "collection-type", type = "string", description = "Refers to a custom collection type to lookup in the registry to use. This option should rarely be used, but allows to use different collection types than java.util.Collection based as default.", displayName = "Collection Type"),
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "disable-features", type = "string", description = "Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Disable Features"),
                    @YamlProperty(name = "enable-features", type = "string", description = "Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Enable Features"),
                    @YamlProperty(name = "enable-jaxb-annotation-module", type = "boolean", description = "Whether to enable the JAXB annotations module when using jackson. When enabled then JAXB annotations can be used by Jackson.", displayName = "Enable Jaxb Annotation Module"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "include", type = "string", description = "If you want to marshal a pojo to JSON, and the pojo has some fields with null values. And you want to skip these null values, you can set this option to NON_NULL", displayName = "Include"),
                    @YamlProperty(name = "json-view", type = "string", description = "When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations", displayName = "Json View"),
                    @YamlProperty(name = "module-class-names", type = "string", description = "To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.", displayName = "Module Class Names"),
                    @YamlProperty(name = "module-refs", type = "string", description = "To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.", displayName = "Module Refs"),
                    @YamlProperty(name = "pretty-print", type = "boolean", description = "To enable pretty printing output nicely formatted. Is by default false.", displayName = "Pretty Print"),
                    @YamlProperty(name = "timezone", type = "string", description = "If set then Jackson will use the Timezone when marshalling/unmarshalling.", displayName = "Timezone"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class name of the java type to use when unmarshalling", displayName = "Unmarshal Type"),
                    @YamlProperty(name = "use-list", type = "boolean", description = "To unmarshal to a List of Map or a List of Pojo.", displayName = "Use List"),
                    @YamlProperty(name = "xml-mapper", type = "string", description = "Lookup and use the existing XmlMapper with the given id.", displayName = "Xml Mapper")
            }
    )
    public static class JacksonXMLDataFormatDeserializer extends YamlDeserializerBase<JacksonXMLDataFormat> {
        public JacksonXMLDataFormatDeserializer() {
            super(JacksonXMLDataFormat.class);
        }

        @Override
        protected JacksonXMLDataFormat newInstance() {
            return new JacksonXMLDataFormat();
        }

        @Override
        protected boolean setProperty(JacksonXMLDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-jms-type": {
                    String val = asText(node);
                    target.setAllowJmsType(val);
                    break;
                }
                case "allow-unmarshall-type": {
                    String val = asText(node);
                    target.setAllowUnmarshallType(val);
                    break;
                }
                case "collection-type": {
                    String val = asText(node);
                    target.setCollectionTypeName(val);
                    break;
                }
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "disable-features": {
                    String val = asText(node);
                    target.setDisableFeatures(val);
                    break;
                }
                case "enable-features": {
                    String val = asText(node);
                    target.setEnableFeatures(val);
                    break;
                }
                case "enable-jaxb-annotation-module": {
                    String val = asText(node);
                    target.setEnableJaxbAnnotationModule(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "include": {
                    String val = asText(node);
                    target.setInclude(val);
                    break;
                }
                case "json-view": {
                    String val = asText(node);
                    target.setJsonViewTypeName(val);
                    break;
                }
                case "module-class-names": {
                    String val = asText(node);
                    target.setModuleClassNames(val);
                    break;
                }
                case "module-refs": {
                    String val = asText(node);
                    target.setModuleRefs(val);
                    break;
                }
                case "pretty-print": {
                    String val = asText(node);
                    target.setPrettyPrint(val);
                    break;
                }
                case "timezone": {
                    String val = asText(node);
                    target.setTimezone(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                case "use-list": {
                    String val = asText(node);
                    target.setUseList(val);
                    break;
                }
                case "xml-mapper": {
                    String val = asText(node);
                    target.setXmlMapper(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "js",
            inline = true,
            types = org.apache.camel.model.language.JavaScriptExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "JavaScript",
            description = "Evaluates a JavaScript expression.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class JavaScriptExpressionDeserializer extends YamlDeserializerBase<JavaScriptExpression> {
        public JavaScriptExpressionDeserializer() {
            super(JavaScriptExpression.class);
        }

        @Override
        protected JavaScriptExpression newInstance() {
            return new JavaScriptExpression();
        }

        @Override
        protected JavaScriptExpression newInstance(String value) {
            return new JavaScriptExpression(value);
        }

        @Override
        protected boolean setProperty(JavaScriptExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "jaxb",
            types = org.apache.camel.model.dataformat.JaxbDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "JAXB",
            description = "Unmarshal XML payloads to POJOs and back using JAXB2 XML marshalling standard.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "access-external-schema-protocols", type = "string", defaultValue = "false", description = "Only in use if schema validation has been enabled. Restrict access to the protocols specified for external reference set by the schemaLocation attribute, Import and Include element. Examples of protocols are file, http, jar:file. false or none to deny all access to external references; a specific protocol, such as file, to give permission to only the protocol; the keyword all to grant permission to all protocols.", displayName = "Access External Schema Protocols"),
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "context-path", type = "string", required = true, description = "Package name where your JAXB classes are located.", displayName = "Context Path"),
                    @YamlProperty(name = "context-path-is-class-name", type = "boolean", description = "This can be set to true to mark that the contextPath is referring to a classname and not a package name.", displayName = "Context Path Is Class Name"),
                    @YamlProperty(name = "encoding", type = "string", description = "To overrule and use a specific encoding", displayName = "Encoding"),
                    @YamlProperty(name = "filter-non-xml-chars", type = "boolean", description = "To ignore non xml characheters and replace them with an empty space.", displayName = "Filter Non Xml Chars"),
                    @YamlProperty(name = "fragment", type = "boolean", description = "To turn on marshalling XML fragment trees. By default JAXB looks for XmlRootElement annotation on given class to operate on whole XML tree. This is useful but not always - sometimes generated code does not have XmlRootElement annotation, sometimes you need unmarshall only part of tree. In that case you can use partial unmarshalling. To enable this behaviours you need set property partClass. Camel will pass this class to JAXB's unmarshaler.", displayName = "Fragment"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-jaxb-element", type = "boolean"),
                    @YamlProperty(name = "jaxb-provider-properties", type = "string", description = "Refers to a custom java.util.Map to lookup in the registry containing custom JAXB provider properties to be used with the JAXB marshaller.", displayName = "Jaxb Provider Properties"),
                    @YamlProperty(name = "must-be-jaxb-element", type = "boolean"),
                    @YamlProperty(name = "namespace-prefix-ref", type = "string", description = "When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes, such as ns2, ns3, ns4 etc. To control this mapping, Camel allows you to refer to a map which contains the desired mapping.", displayName = "Namespace Prefix Ref"),
                    @YamlProperty(name = "no-namespace-schema-location", type = "string", description = "To define the location of the namespaceless schema", displayName = "No Namespace Schema Location"),
                    @YamlProperty(name = "object-factory", type = "boolean", description = "Whether to allow using ObjectFactory classes to create the POJO classes during marshalling. This only applies to POJO classes that has not been annotated with JAXB and providing jaxb.index descriptor files.", displayName = "Object Factory"),
                    @YamlProperty(name = "part-class", type = "string", description = "Name of class used for fragment parsing. See more details at the fragment option.", displayName = "Part Class"),
                    @YamlProperty(name = "part-namespace", type = "string", description = "XML namespace to use for fragment parsing. See more details at the fragment option.", displayName = "Part Namespace"),
                    @YamlProperty(name = "pretty-print", type = "boolean", description = "To enable pretty printing output nicely formatted. Is by default false.", displayName = "Pretty Print"),
                    @YamlProperty(name = "schema", type = "string", description = "To validate against an existing schema. Your can use the prefix classpath:, file: or http: to specify how the resource should be resolved. You can separate multiple schema files by using the ',' character.", displayName = "Schema"),
                    @YamlProperty(name = "schema-location", type = "string", description = "To define the location of the schema", displayName = "Schema Location"),
                    @YamlProperty(name = "schema-severity-level", type = "enum:0,1,2", defaultValue = "0", description = "Sets the schema severity level to use when validating against a schema. This level determines the minimum severity error that triggers JAXB to stop continue parsing. The default value of 0 (warning) means that any error (warning, error or fatal error) will trigger JAXB to stop. There are the following three levels: 0=warning, 1=error, 2=fatal error.", displayName = "Schema Severity Level"),
                    @YamlProperty(name = "xml-stream-writer-wrapper", type = "string", description = "To use a custom xml stream writer.", displayName = "Xml Stream Writer Wrapper")
            }
    )
    public static class JaxbDataFormatDeserializer extends YamlDeserializerBase<JaxbDataFormat> {
        public JaxbDataFormatDeserializer() {
            super(JaxbDataFormat.class);
        }

        @Override
        protected JaxbDataFormat newInstance() {
            return new JaxbDataFormat();
        }

        @Override
        protected boolean setProperty(JaxbDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "access-external-schema-protocols": {
                    String val = asText(node);
                    target.setAccessExternalSchemaProtocols(val);
                    break;
                }
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "context-path": {
                    String val = asText(node);
                    target.setContextPath(val);
                    break;
                }
                case "context-path-is-class-name": {
                    String val = asText(node);
                    target.setContextPathIsClassName(val);
                    break;
                }
                case "encoding": {
                    String val = asText(node);
                    target.setEncoding(val);
                    break;
                }
                case "filter-non-xml-chars": {
                    String val = asText(node);
                    target.setFilterNonXmlChars(val);
                    break;
                }
                case "fragment": {
                    String val = asText(node);
                    target.setFragment(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ignore-jaxb-element": {
                    String val = asText(node);
                    target.setIgnoreJAXBElement(val);
                    break;
                }
                case "jaxb-provider-properties": {
                    String val = asText(node);
                    target.setJaxbProviderProperties(val);
                    break;
                }
                case "must-be-jaxb-element": {
                    String val = asText(node);
                    target.setMustBeJAXBElement(val);
                    break;
                }
                case "namespace-prefix-ref": {
                    String val = asText(node);
                    target.setNamespacePrefixRef(val);
                    break;
                }
                case "no-namespace-schema-location": {
                    String val = asText(node);
                    target.setNoNamespaceSchemaLocation(val);
                    break;
                }
                case "object-factory": {
                    String val = asText(node);
                    target.setObjectFactory(val);
                    break;
                }
                case "part-class": {
                    String val = asText(node);
                    target.setPartClass(val);
                    break;
                }
                case "part-namespace": {
                    String val = asText(node);
                    target.setPartNamespace(val);
                    break;
                }
                case "pretty-print": {
                    String val = asText(node);
                    target.setPrettyPrint(val);
                    break;
                }
                case "schema": {
                    String val = asText(node);
                    target.setSchema(val);
                    break;
                }
                case "schema-location": {
                    String val = asText(node);
                    target.setSchemaLocation(val);
                    break;
                }
                case "schema-severity-level": {
                    String val = asText(node);
                    target.setSchemaSeverityLevel(val);
                    break;
                }
                case "xml-stream-writer-wrapper": {
                    String val = asText(node);
                    target.setXmlStreamWriterWrapper(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "joor",
            inline = true,
            types = org.apache.camel.model.language.JoorExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "jOOR",
            description = "Evaluates a jOOR (Java compiled once at runtime) expression.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "pre-compile", type = "boolean", description = "Whether the expression should be pre compiled once during initialization phase. If this is turned off, then the expression is reloaded and compiled on each evaluation.", displayName = "Pre Compile"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "single-quotes", type = "boolean", description = "Whether single quotes can be used as replacement for double quotes. This is convenient when you need to work with strings inside strings.", displayName = "Single Quotes"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class JoorExpressionDeserializer extends YamlDeserializerBase<JoorExpression> {
        public JoorExpressionDeserializer() {
            super(JoorExpression.class);
        }

        @Override
        protected JoorExpression newInstance() {
            return new JoorExpression();
        }

        @Override
        protected JoorExpression newInstance(String value) {
            return new JoorExpression(value);
        }

        @Override
        protected boolean setProperty(JoorExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "pre-compile": {
                    String val = asText(node);
                    target.setPreCompile(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "single-quotes": {
                    String val = asText(node);
                    target.setSingleQuotes(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "jq",
            inline = true,
            types = org.apache.camel.model.language.JqExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "JQ",
            description = "Evaluates a JQ expression against a JSON message body.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "header-name", type = "string", description = "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set.", displayName = "Header Name"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "property-name", type = "string", description = "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set.", displayName = "Property Name"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class JqExpressionDeserializer extends YamlDeserializerBase<JqExpression> {
        public JqExpressionDeserializer() {
            super(JqExpression.class);
        }

        @Override
        protected JqExpression newInstance() {
            return new JqExpression();
        }

        @Override
        protected JqExpression newInstance(String value) {
            return new JqExpression(value);
        }

        @Override
        protected boolean setProperty(JqExpression target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "header-name": {
                    String val = asText(node);
                    target.setHeaderName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "property-name": {
                    String val = asText(node);
                    target.setPropertyName(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "json-api",
                    "jsonApi"
            },
            types = org.apache.camel.model.dataformat.JsonApiDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "JSonApi",
            description = "Marshal and unmarshal JSON:API resources using JSONAPI-Converter library.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "data-format-types", type = "string", description = "The classes to take into account for the marshalling. Multiple classes can be separated by comma.", displayName = "Data Format Types"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "main-format-type", type = "string", description = "The class to take into account while unmarshalling.", displayName = "Main Format Type")
            }
    )
    public static class JsonApiDataFormatDeserializer extends YamlDeserializerBase<JsonApiDataFormat> {
        public JsonApiDataFormatDeserializer() {
            super(JsonApiDataFormat.class);
        }

        @Override
        protected JsonApiDataFormat newInstance() {
            return new JsonApiDataFormat();
        }

        @Override
        protected boolean setProperty(JsonApiDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "data-format-types": {
                    String val = asText(node);
                    target.setDataFormatTypes(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "main-format-type": {
                    String val = asText(node);
                    target.setMainFormatType(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "json",
            types = org.apache.camel.model.dataformat.JsonDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "JSon",
            description = "Marshal POJOs to JSON and back.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-jms-type", type = "boolean", description = "Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.", displayName = "Allow Jms Type"),
                    @YamlProperty(name = "allow-unmarshall-type", type = "boolean", description = "If enabled then Jackson is allowed to attempt to use the CamelJacksonUnmarshalType header during the unmarshalling. This should only be enabled when desired to be used.", displayName = "Allow Unmarshall Type"),
                    @YamlProperty(name = "auto-discover-object-mapper", type = "boolean", description = "If set to true then Jackson will look for an objectMapper to use from the registry", displayName = "Auto Discover Object Mapper"),
                    @YamlProperty(name = "auto-discover-schema-resolver", type = "boolean", description = "When not disabled, the SchemaResolver will be looked up into the registry", displayName = "Auto Discover Schema Resolver"),
                    @YamlProperty(name = "collection-type", type = "string", description = "Refers to a custom collection type to lookup in the registry to use. This option should rarely be used, but allows using different collection types than java.util.Collection based as default.", displayName = "Collection Type"),
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "date-format-pattern", type = "string", description = "To configure the date format while marshall or unmarshall Date fields in JSON using Gson", displayName = "Date Format Pattern"),
                    @YamlProperty(name = "disable-features", type = "string", description = "Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Disable Features"),
                    @YamlProperty(name = "enable-features", type = "string", description = "Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Enable Features"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "include", type = "string", description = "If you want to marshal a pojo to JSON, and the pojo has some fields with null values. And you want to skip these null values, you can set this option to NON_NULL", displayName = "Include"),
                    @YamlProperty(name = "json-view", type = "string", description = "When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations", displayName = "Json View"),
                    @YamlProperty(name = "library", type = "enum:Fastjson,Gson,Jackson,Johnzon,Jsonb", defaultValue = "Jackson", description = "Which json library to use.", displayName = "Library"),
                    @YamlProperty(name = "module-class-names", type = "string", description = "To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.", displayName = "Module Class Names"),
                    @YamlProperty(name = "module-refs", type = "string", description = "To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.", displayName = "Module Refs"),
                    @YamlProperty(name = "naming-strategy", type = "string", description = "If set then Jackson will use the the defined Property Naming Strategy.Possible values are: LOWER_CAMEL_CASE, LOWER_DOT_CASE, LOWER_CASE, KEBAB_CASE, SNAKE_CASE and UPPER_CAMEL_CASE", displayName = "Naming Strategy"),
                    @YamlProperty(name = "object-mapper", type = "string", description = "Lookup and use the existing ObjectMapper with the given id when using Jackson.", displayName = "Object Mapper"),
                    @YamlProperty(name = "pretty-print", type = "boolean", description = "To enable pretty printing output nicely formatted. Is by default false.", displayName = "Pretty Print"),
                    @YamlProperty(name = "schema-resolver", type = "string", description = "Optional schema resolver used to lookup schemas for the data in transit.", displayName = "Schema Resolver"),
                    @YamlProperty(name = "timezone", type = "string", description = "If set then Jackson will use the Timezone when marshalling/unmarshalling. This option will have no effect on the others Json DataFormat, like gson and fastjson.", displayName = "Timezone"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class name of the java type to use when unmarshalling", displayName = "Unmarshal Type"),
                    @YamlProperty(name = "use-default-object-mapper", type = "boolean", description = "Whether to lookup and use default Jackson ObjectMapper from the registry.", displayName = "Use Default Object Mapper"),
                    @YamlProperty(name = "use-list", type = "boolean", description = "To unmarshal to a List of Map or a List of Pojo.", displayName = "Use List")
            }
    )
    public static class JsonDataFormatDeserializer extends YamlDeserializerBase<JsonDataFormat> {
        public JsonDataFormatDeserializer() {
            super(JsonDataFormat.class);
        }

        @Override
        protected JsonDataFormat newInstance() {
            return new JsonDataFormat();
        }

        @Override
        protected boolean setProperty(JsonDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-jms-type": {
                    String val = asText(node);
                    target.setAllowJmsType(val);
                    break;
                }
                case "allow-unmarshall-type": {
                    String val = asText(node);
                    target.setAllowUnmarshallType(val);
                    break;
                }
                case "auto-discover-object-mapper": {
                    String val = asText(node);
                    target.setAutoDiscoverObjectMapper(val);
                    break;
                }
                case "auto-discover-schema-resolver": {
                    String val = asText(node);
                    target.setAutoDiscoverSchemaResolver(val);
                    break;
                }
                case "collection-type": {
                    String val = asText(node);
                    target.setCollectionTypeName(val);
                    break;
                }
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "date-format-pattern": {
                    String val = asText(node);
                    target.setDateFormatPattern(val);
                    break;
                }
                case "disable-features": {
                    String val = asText(node);
                    target.setDisableFeatures(val);
                    break;
                }
                case "enable-features": {
                    String val = asText(node);
                    target.setEnableFeatures(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "include": {
                    String val = asText(node);
                    target.setInclude(val);
                    break;
                }
                case "json-view": {
                    String val = asText(node);
                    target.setJsonViewTypeName(val);
                    break;
                }
                case "library": {
                    target.setLibrary(asEnum(node, org.apache.camel.model.dataformat.JsonLibrary.class));
                    break;
                }
                case "module-class-names": {
                    String val = asText(node);
                    target.setModuleClassNames(val);
                    break;
                }
                case "module-refs": {
                    String val = asText(node);
                    target.setModuleRefs(val);
                    break;
                }
                case "naming-strategy": {
                    String val = asText(node);
                    target.setNamingStrategy(val);
                    break;
                }
                case "object-mapper": {
                    String val = asText(node);
                    target.setObjectMapper(val);
                    break;
                }
                case "pretty-print": {
                    String val = asText(node);
                    target.setPrettyPrint(val);
                    break;
                }
                case "schema-resolver": {
                    String val = asText(node);
                    target.setSchemaResolver(val);
                    break;
                }
                case "timezone": {
                    String val = asText(node);
                    target.setTimezone(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                case "use-default-object-mapper": {
                    String val = asText(node);
                    target.setUseDefaultObjectMapper(val);
                    break;
                }
                case "use-list": {
                    String val = asText(node);
                    target.setUseList(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "jsonpath",
            inline = true,
            types = org.apache.camel.model.language.JsonPathExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "JSONPath",
            description = "Evaluates a JSONPath expression against a JSON message body.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-easy-predicate", type = "boolean", description = "Whether to allow using the easy predicate parser to pre-parse predicates.", displayName = "Allow Easy Predicate"),
                    @YamlProperty(name = "allow-simple", type = "boolean", description = "Whether to allow in inlined Simple exceptions in the JSONPath expression", displayName = "Allow Simple"),
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "header-name", type = "string", description = "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set.", displayName = "Header Name"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "option", type = "enum:DEFAULT_PATH_LEAF_TO_NULL,ALWAYS_RETURN_LIST,AS_PATH_LIST,SUPPRESS_EXCEPTIONS,REQUIRE_PROPERTIES", description = "To configure additional options on JSONPath. Multiple values can be separated by comma.", displayName = "Option"),
                    @YamlProperty(name = "property-name", type = "string", description = "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set.", displayName = "Property Name"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "suppress-exceptions", type = "boolean", description = "Whether to suppress exceptions such as PathNotFoundException.", displayName = "Suppress Exceptions"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
                    @YamlProperty(name = "unpack-array", type = "boolean", description = "Whether to unpack a single element json-array into an object.", displayName = "Unpack Array"),
                    @YamlProperty(name = "write-as-string", type = "boolean", description = "Whether to write the output of each row/element as a JSON String value instead of a Map/POJO value.", displayName = "Write As String")
            }
    )
    public static class JsonPathExpressionDeserializer extends YamlDeserializerBase<JsonPathExpression> {
        public JsonPathExpressionDeserializer() {
            super(JsonPathExpression.class);
        }

        @Override
        protected JsonPathExpression newInstance() {
            return new JsonPathExpression();
        }

        @Override
        protected JsonPathExpression newInstance(String value) {
            return new JsonPathExpression(value);
        }

        @Override
        protected boolean setProperty(JsonPathExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-easy-predicate": {
                    String val = asText(node);
                    target.setAllowEasyPredicate(val);
                    break;
                }
                case "allow-simple": {
                    String val = asText(node);
                    target.setAllowSimple(val);
                    break;
                }
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "header-name": {
                    String val = asText(node);
                    target.setHeaderName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "option": {
                    String val = asText(node);
                    target.setOption(val);
                    break;
                }
                case "property-name": {
                    String val = asText(node);
                    target.setPropertyName(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "suppress-exceptions": {
                    String val = asText(node);
                    target.setSuppressExceptions(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                case "unpack-array": {
                    String val = asText(node);
                    target.setUnpackArray(val);
                    break;
                }
                case "write-as-string": {
                    String val = asText(node);
                    target.setWriteAsString(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "jta-transaction-error-handler",
                    "jtaTransactionErrorHandler"
            },
            types = org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Jta Transaction Error Handler",
            description = "JTA based transactional error handler (requires camel-jta).",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "executor-service-ref", type = "string", description = "Sets a reference to a thread pool to be used by the error handler", displayName = "Executor Service Ref"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "ERROR", description = "Logging level to use by error handler", displayName = "Level"),
                    @YamlProperty(name = "log-name", type = "string", description = "Name of the logger to use by the error handler", displayName = "Log Name"),
                    @YamlProperty(name = "logger-ref", type = "string", description = "References to a logger to use as logger for the error handler", displayName = "Logger Ref"),
                    @YamlProperty(name = "on-exception-occurred-ref", type = "string", description = "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.", displayName = "On Exception Occurred Ref"),
                    @YamlProperty(name = "on-prepare-failure-ref", type = "string", description = "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.", displayName = "On Prepare Failure Ref"),
                    @YamlProperty(name = "on-redelivery-ref", type = "string", description = "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.", displayName = "On Redelivery Ref"),
                    @YamlProperty(name = "redelivery-policy", type = "object:org.apache.camel.model.RedeliveryPolicyDefinition", description = "Sets the redelivery settings", displayName = "Redelivery Policy"),
                    @YamlProperty(name = "redelivery-policy-ref", type = "string", description = "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.", displayName = "Redelivery Policy Ref"),
                    @YamlProperty(name = "retry-while-ref", type = "string", description = "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.", displayName = "Retry While Ref"),
                    @YamlProperty(name = "rollback-logging-level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "WARN", description = "Sets the logging level to use for logging transactional rollback. This option is default WARN.", displayName = "Rollback Logging Level"),
                    @YamlProperty(name = "transacted-policy-ref", type = "string", description = "The transacted policy to use that is configured for either Spring or JTA based transactions. If no policy has been configured then Camel will attempt to auto-discover.", displayName = "Transacted Policy Ref"),
                    @YamlProperty(name = "use-original-body", type = "boolean", description = "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Body"),
                    @YamlProperty(name = "use-original-message", type = "boolean", description = "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Message")
            }
    )
    public static class JtaTransactionErrorHandlerDefinitionDeserializer extends YamlDeserializerBase<JtaTransactionErrorHandlerDefinition> {
        public JtaTransactionErrorHandlerDefinitionDeserializer() {
            super(JtaTransactionErrorHandlerDefinition.class);
        }

        @Override
        protected JtaTransactionErrorHandlerDefinition newInstance() {
            return new JtaTransactionErrorHandlerDefinition();
        }

        @Override
        protected boolean setProperty(JtaTransactionErrorHandlerDefinition target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "executor-service-ref": {
                    String val = asText(node);
                    target.setExecutorServiceRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "level": {
                    String val = asText(node);
                    target.setLevel(val);
                    break;
                }
                case "log-name": {
                    String val = asText(node);
                    target.setLogName(val);
                    break;
                }
                case "logger-ref": {
                    String val = asText(node);
                    target.setLoggerRef(val);
                    break;
                }
                case "on-exception-occurred-ref": {
                    String val = asText(node);
                    target.setOnExceptionOccurredRef(val);
                    break;
                }
                case "on-prepare-failure-ref": {
                    String val = asText(node);
                    target.setOnPrepareFailureRef(val);
                    break;
                }
                case "on-redelivery-ref": {
                    String val = asText(node);
                    target.setOnRedeliveryRef(val);
                    break;
                }
                case "redelivery-policy": {
                    org.apache.camel.model.RedeliveryPolicyDefinition val = asType(node, org.apache.camel.model.RedeliveryPolicyDefinition.class);
                    target.setRedeliveryPolicy(val);
                    break;
                }
                case "redelivery-policy-ref": {
                    String val = asText(node);
                    target.setRedeliveryPolicyRef(val);
                    break;
                }
                case "retry-while-ref": {
                    String val = asText(node);
                    target.setRetryWhileRef(val);
                    break;
                }
                case "rollback-logging-level": {
                    String val = asText(node);
                    target.setRollbackLoggingLevel(val);
                    break;
                }
                case "transacted-policy-ref": {
                    String val = asText(node);
                    target.setTransactedPolicyRef(val);
                    break;
                }
                case "use-original-body": {
                    String val = asText(node);
                    target.setUseOriginalBody(val);
                    break;
                }
                case "use-original-message": {
                    String val = asText(node);
                    target.setUseOriginalMessage(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "kubernetes-service-discovery",
                    "kubernetesServiceDiscovery"
            },
            types = org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Kubernetes Service Discovery",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "api-version", type = "string", description = "Sets the API version when using client lookup", displayName = "Api Version"),
                    @YamlProperty(name = "ca-cert-data", type = "string", description = "Sets the Certificate Authority data when using client lookup", displayName = "Ca Cert Data"),
                    @YamlProperty(name = "ca-cert-file", type = "string", description = "Sets the Certificate Authority data that are loaded from the file when using client lookup", displayName = "Ca Cert File"),
                    @YamlProperty(name = "client-cert-data", type = "string", description = "Sets the Client Certificate data when using client lookup", displayName = "Client Cert Data"),
                    @YamlProperty(name = "client-cert-file", type = "string", description = "Sets the Client Certificate data that are loaded from the file when using client lookup", displayName = "Client Cert File"),
                    @YamlProperty(name = "client-key-algo", type = "string", description = "Sets the Client Keystore algorithm, such as RSA when using client lookup", displayName = "Client Key Algo"),
                    @YamlProperty(name = "client-key-data", type = "string", description = "Sets the Client Keystore data when using client lookup", displayName = "Client Key Data"),
                    @YamlProperty(name = "client-key-file", type = "string", description = "Sets the Client Keystore data that are loaded from the file when using client lookup", displayName = "Client Key File"),
                    @YamlProperty(name = "client-key-passphrase", type = "string", description = "Sets the Client Keystore passphrase when using client lookup", displayName = "Client Key Passphrase"),
                    @YamlProperty(name = "dns-domain", type = "string", description = "Sets the DNS domain to use for DNS lookup.", displayName = "Dns Domain"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "lookup", type = "enum:environment,dns,client", defaultValue = "environment", description = "How to perform service lookup. Possible values: client, dns, environment. When using client, then the client queries the kubernetes master to obtain a list of active pods that provides the service, and then random (or round robin) select a pod. When using dns the service name is resolved as name.namespace.svc.dnsDomain. When using dnssrv the service name is resolved with SRV query for _._...svc... When using environment then environment variables are used to lookup the service. By default environment is used.", displayName = "Lookup"),
                    @YamlProperty(name = "master-url", type = "string", description = "Sets the URL to the master when using client lookup", displayName = "Master Url"),
                    @YamlProperty(name = "namespace", type = "string", description = "Sets the namespace to use. Will by default use namespace from the ENV variable KUBERNETES_MASTER.", displayName = "Namespace"),
                    @YamlProperty(name = "oauth-token", type = "string", description = "Sets the OAUTH token for authentication (instead of username/password) when using client lookup", displayName = "Oauth Token"),
                    @YamlProperty(name = "password", type = "string", description = "Sets the password for authentication when using client lookup", displayName = "Password"),
                    @YamlProperty(name = "port-name", type = "string", description = "Sets the Port Name to use for DNS/DNSSRV lookup.", displayName = "Port Name"),
                    @YamlProperty(name = "port-protocol", type = "string", description = "Sets the Port Protocol to use for DNS/DNSSRV lookup.", displayName = "Port Protocol"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "trust-certs", type = "boolean", description = "Sets whether to turn on trust certificate check when using client lookup", displayName = "Trust Certs"),
                    @YamlProperty(name = "username", type = "string", description = "Sets the username for authentication when using client lookup", displayName = "Username")
            }
    )
    public static class KubernetesServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<KubernetesServiceCallServiceDiscoveryConfiguration> {
        public KubernetesServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(KubernetesServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected KubernetesServiceCallServiceDiscoveryConfiguration newInstance() {
            return new KubernetesServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(KubernetesServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "api-version": {
                    String val = asText(node);
                    target.setApiVersion(val);
                    break;
                }
                case "ca-cert-data": {
                    String val = asText(node);
                    target.setCaCertData(val);
                    break;
                }
                case "ca-cert-file": {
                    String val = asText(node);
                    target.setCaCertFile(val);
                    break;
                }
                case "client-cert-data": {
                    String val = asText(node);
                    target.setClientCertData(val);
                    break;
                }
                case "client-cert-file": {
                    String val = asText(node);
                    target.setClientCertFile(val);
                    break;
                }
                case "client-key-algo": {
                    String val = asText(node);
                    target.setClientKeyAlgo(val);
                    break;
                }
                case "client-key-data": {
                    String val = asText(node);
                    target.setClientKeyData(val);
                    break;
                }
                case "client-key-file": {
                    String val = asText(node);
                    target.setClientKeyFile(val);
                    break;
                }
                case "client-key-passphrase": {
                    String val = asText(node);
                    target.setClientKeyPassphrase(val);
                    break;
                }
                case "dns-domain": {
                    String val = asText(node);
                    target.setDnsDomain(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "lookup": {
                    String val = asText(node);
                    target.setLookup(val);
                    break;
                }
                case "master-url": {
                    String val = asText(node);
                    target.setMasterUrl(val);
                    break;
                }
                case "namespace": {
                    String val = asText(node);
                    target.setNamespace(val);
                    break;
                }
                case "oauth-token": {
                    String val = asText(node);
                    target.setOauthToken(val);
                    break;
                }
                case "password": {
                    String val = asText(node);
                    target.setPassword(val);
                    break;
                }
                case "port-name": {
                    String val = asText(node);
                    target.setPortName(val);
                    break;
                }
                case "port-protocol": {
                    String val = asText(node);
                    target.setPortProtocol(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "trust-certs": {
                    String val = asText(node);
                    target.setTrustCerts(val);
                    break;
                }
                case "username": {
                    String val = asText(node);
                    target.setUsername(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "lzf",
            types = org.apache.camel.model.dataformat.LZFDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "LZF Deflate Compression",
            description = "Compress and decompress streams using LZF deflate algorithm.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "using-parallel-compression", type = "boolean", description = "Enable encoding (compress) using multiple processing cores.", displayName = "Using Parallel Compression")
            }
    )
    public static class LZFDataFormatDeserializer extends YamlDeserializerBase<LZFDataFormat> {
        public LZFDataFormatDeserializer() {
            super(LZFDataFormat.class);
        }

        @Override
        protected LZFDataFormat newInstance() {
            return new LZFDataFormat();
        }

        @Override
        protected boolean setProperty(LZFDataFormat target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "using-parallel-compression": {
                    String val = asText(node);
                    target.setUsingParallelCompression(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "language",
            types = org.apache.camel.model.language.LanguageExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Language",
            description = "Evaluates a custom language.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "language", type = "string", required = true, description = "The name of the language to use", displayName = "Language"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class LanguageExpressionDeserializer extends YamlDeserializerBase<LanguageExpression> {
        public LanguageExpressionDeserializer() {
            super(LanguageExpression.class);
        }

        @Override
        protected LanguageExpression newInstance() {
            return new LanguageExpression();
        }

        @Override
        protected boolean setProperty(LanguageExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "language": {
                    String val = asText(node);
                    target.setLanguage(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "load-balance",
                    "loadBalance"
            },
            types = org.apache.camel.model.LoadBalanceDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Load Balance",
            description = "Balances message processing among a number of nodes",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "custom-load-balancer", type = "object:org.apache.camel.model.loadbalancer.CustomLoadBalancerDefinition", oneOf = "loadBalancerType"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "failover", type = "object:org.apache.camel.model.loadbalancer.FailoverLoadBalancerDefinition", oneOf = "loadBalancerType"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean", description = "Sets whether or not to inherit the configured error handler. The default value is true. You can use this to disable using the inherited error handler for a given DSL such as a load balancer where you want to use a custom error handler strategy.", displayName = "Inherit Error Handler"),
                    @YamlProperty(name = "random", type = "object:org.apache.camel.model.loadbalancer.RandomLoadBalancerDefinition", oneOf = "loadBalancerType"),
                    @YamlProperty(name = "round-robin", type = "object:org.apache.camel.model.loadbalancer.RoundRobinLoadBalancerDefinition", oneOf = "loadBalancerType"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "sticky", type = "object:org.apache.camel.model.loadbalancer.StickyLoadBalancerDefinition", oneOf = "loadBalancerType"),
                    @YamlProperty(name = "topic", type = "object:org.apache.camel.model.loadbalancer.TopicLoadBalancerDefinition", oneOf = "loadBalancerType"),
                    @YamlProperty(name = "weighted", type = "object:org.apache.camel.model.loadbalancer.WeightedLoadBalancerDefinition", oneOf = "loadBalancerType")
            }
    )
    public static class LoadBalanceDefinitionDeserializer extends YamlDeserializerBase<LoadBalanceDefinition> {
        public LoadBalanceDefinitionDeserializer() {
            super(LoadBalanceDefinition.class);
        }

        @Override
        protected LoadBalanceDefinition newInstance() {
            return new LoadBalanceDefinition();
        }

        @Override
        protected boolean setProperty(LoadBalanceDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "load-balancer-type": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "custom-load-balancer": {
                    org.apache.camel.model.loadbalancer.CustomLoadBalancerDefinition val = asType(node, org.apache.camel.model.loadbalancer.CustomLoadBalancerDefinition.class);
                    target.setLoadBalancerType(val);
                    break;
                }
                case "failover": {
                    org.apache.camel.model.loadbalancer.FailoverLoadBalancerDefinition val = asType(node, org.apache.camel.model.loadbalancer.FailoverLoadBalancerDefinition.class);
                    target.setLoadBalancerType(val);
                    break;
                }
                case "random": {
                    org.apache.camel.model.loadbalancer.RandomLoadBalancerDefinition val = asType(node, org.apache.camel.model.loadbalancer.RandomLoadBalancerDefinition.class);
                    target.setLoadBalancerType(val);
                    break;
                }
                case "round-robin": {
                    org.apache.camel.model.loadbalancer.RoundRobinLoadBalancerDefinition val = asType(node, org.apache.camel.model.loadbalancer.RoundRobinLoadBalancerDefinition.class);
                    target.setLoadBalancerType(val);
                    break;
                }
                case "sticky": {
                    org.apache.camel.model.loadbalancer.StickyLoadBalancerDefinition val = asType(node, org.apache.camel.model.loadbalancer.StickyLoadBalancerDefinition.class);
                    target.setLoadBalancerType(val);
                    break;
                }
                case "topic": {
                    org.apache.camel.model.loadbalancer.TopicLoadBalancerDefinition val = asType(node, org.apache.camel.model.loadbalancer.TopicLoadBalancerDefinition.class);
                    target.setLoadBalancerType(val);
                    break;
                }
                case "weighted": {
                    org.apache.camel.model.loadbalancer.WeightedLoadBalancerDefinition val = asType(node, org.apache.camel.model.loadbalancer.WeightedLoadBalancerDefinition.class);
                    target.setLoadBalancerType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.transformer.LoadTransformerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "defaults", type = "boolean"),
                    @YamlProperty(name = "from-type", type = "string"),
                    @YamlProperty(name = "name", type = "string"),
                    @YamlProperty(name = "package-scan", type = "string"),
                    @YamlProperty(name = "scheme", type = "string"),
                    @YamlProperty(name = "to-type", type = "string")
            }
    )
    public static class LoadTransformerDefinitionDeserializer extends YamlDeserializerBase<LoadTransformerDefinition> {
        public LoadTransformerDefinitionDeserializer() {
            super(LoadTransformerDefinition.class);
        }

        @Override
        protected LoadTransformerDefinition newInstance() {
            return new LoadTransformerDefinition();
        }

        @Override
        protected boolean setProperty(LoadTransformerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "defaults": {
                    String val = asText(node);
                    target.setDefaults(val);
                    break;
                }
                case "from-type": {
                    String val = asText(node);
                    target.setFromType(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "package-scan": {
                    String val = asText(node);
                    target.setPackageScan(val);
                    break;
                }
                case "scheme": {
                    String val = asText(node);
                    target.setScheme(val);
                    break;
                }
                case "to-type": {
                    String val = asText(node);
                    target.setToType(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "log",
            inline = true,
            types = org.apache.camel.model.LogDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Log",
            description = "Logs the defined message to the logger",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "log-name", type = "string", description = "Sets the name of the logger", displayName = "Log Name"),
                    @YamlProperty(name = "logger", type = "string", description = "To refer to a custom logger instance to lookup from the registry.", displayName = "Logger"),
                    @YamlProperty(name = "logging-level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "INFO", description = "Sets the logging level. The default value is INFO", displayName = "Logging Level"),
                    @YamlProperty(name = "marker", type = "string", description = "To use slf4j marker", displayName = "Marker"),
                    @YamlProperty(name = "message", type = "string", required = true, description = "Sets the log message (uses simple language)", displayName = "Message")
            }
    )
    public static class LogDefinitionDeserializer extends YamlDeserializerBase<LogDefinition> {
        public LogDefinitionDeserializer() {
            super(LogDefinition.class);
        }

        @Override
        protected LogDefinition newInstance() {
            return new LogDefinition();
        }

        @Override
        protected LogDefinition newInstance(String value) {
            return new LogDefinition(value);
        }

        @Override
        protected boolean setProperty(LogDefinition target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "log-name": {
                    String val = asText(node);
                    target.setLogName(val);
                    break;
                }
                case "logger": {
                    String val = asText(node);
                    target.setLogger(val);
                    break;
                }
                case "logging-level": {
                    String val = asText(node);
                    target.setLoggingLevel(val);
                    break;
                }
                case "marker": {
                    String val = asText(node);
                    target.setMarker(val);
                    break;
                }
                case "message": {
                    String val = asText(node);
                    target.setMessage(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "loop",
            types = org.apache.camel.model.LoopDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Loop",
            description = "Processes a message multiple times",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "break-on-shutdown", type = "boolean", description = "If the breakOnShutdown attribute is true, then the loop will not iterate until it reaches the end when Camel is shut down.", displayName = "Break On Shutdown"),
                    @YamlProperty(name = "copy", type = "boolean", description = "If the copy attribute is true, a copy of the input Exchange is used for each iteration. That means each iteration will start from a copy of the same message. By default loop will loop the same exchange all over, so each iteration may have different message content.", displayName = "Copy"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "do-while", type = "boolean", description = "Enables the while loop that loops until the predicate evaluates to false or null.", displayName = "Do While"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to define how many times we should loop. Notice the expression is only evaluated once, and should return a number as how many times to loop. A value of zero or negative means no looping. The loop is like a for-loop fashion, if you want a while loop, then the dynamic router may be a better choice.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class LoopDefinitionDeserializer extends YamlDeserializerBase<LoopDefinition> {
        public LoopDefinitionDeserializer() {
            super(LoopDefinition.class);
        }

        @Override
        protected LoopDefinition newInstance() {
            return new LoopDefinition();
        }

        @Override
        protected boolean setProperty(LoopDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "break-on-shutdown": {
                    String val = asText(node);
                    target.setBreakOnShutdown(val);
                    break;
                }
                case "copy": {
                    String val = asText(node);
                    target.setCopy(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "do-while": {
                    String val = asText(node);
                    target.setDoWhile(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "marshal",
            types = org.apache.camel.model.MarshalDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Marshal",
            description = "Marshals data into a specified format for transmission over a transport or component",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "asn1", type = "object:org.apache.camel.model.dataformat.ASN1DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "avro", type = "object:org.apache.camel.model.dataformat.AvroDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "barcode", type = "object:org.apache.camel.model.dataformat.BarcodeDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "base64", type = "object:org.apache.camel.model.dataformat.Base64DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "bindy", type = "object:org.apache.camel.model.dataformat.BindyDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "cbor", type = "object:org.apache.camel.model.dataformat.CBORDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "crypto", type = "object:org.apache.camel.model.dataformat.CryptoDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "csv", type = "object:org.apache.camel.model.dataformat.CsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "custom", type = "object:org.apache.camel.model.dataformat.CustomDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "fhir-json", type = "object:org.apache.camel.model.dataformat.FhirJsonDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "fhir-xml", type = "object:org.apache.camel.model.dataformat.FhirXmlDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "flatpack", type = "object:org.apache.camel.model.dataformat.FlatpackDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "grok", type = "object:org.apache.camel.model.dataformat.GrokDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "gzip-deflater", type = "object:org.apache.camel.model.dataformat.GzipDeflaterDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "hl7", type = "object:org.apache.camel.model.dataformat.HL7DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "ical", type = "object:org.apache.camel.model.dataformat.IcalDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "jackson-xml", type = "object:org.apache.camel.model.dataformat.JacksonXMLDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "jaxb", type = "object:org.apache.camel.model.dataformat.JaxbDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "json", type = "object:org.apache.camel.model.dataformat.JsonDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "json-api", type = "object:org.apache.camel.model.dataformat.JsonApiDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "lzf", type = "object:org.apache.camel.model.dataformat.LZFDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "mime-multipart", type = "object:org.apache.camel.model.dataformat.MimeMultipartDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "parquet-avro", type = "object:org.apache.camel.model.dataformat.ParquetAvroDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "pgp", type = "object:org.apache.camel.model.dataformat.PGPDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "protobuf", type = "object:org.apache.camel.model.dataformat.ProtobufDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "rss", type = "object:org.apache.camel.model.dataformat.RssDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "soap", type = "object:org.apache.camel.model.dataformat.SoapDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "swift-mt", type = "object:org.apache.camel.model.dataformat.SwiftMtDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "swift-mx", type = "object:org.apache.camel.model.dataformat.SwiftMxDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "syslog", type = "object:org.apache.camel.model.dataformat.SyslogDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "tar-file", type = "object:org.apache.camel.model.dataformat.TarFileDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "thrift", type = "object:org.apache.camel.model.dataformat.ThriftDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "tidy-markup", type = "object:org.apache.camel.model.dataformat.TidyMarkupDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-csv", type = "object:org.apache.camel.model.dataformat.UniVocityCsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-fixed", type = "object:org.apache.camel.model.dataformat.UniVocityFixedDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-tsv", type = "object:org.apache.camel.model.dataformat.UniVocityTsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "xml-security", type = "object:org.apache.camel.model.dataformat.XMLSecurityDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "yaml", type = "object:org.apache.camel.model.dataformat.YAMLDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "zip-deflater", type = "object:org.apache.camel.model.dataformat.ZipDeflaterDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "zip-file", type = "object:org.apache.camel.model.dataformat.ZipFileDataFormat", oneOf = "dataFormatType")
            }
    )
    public static class MarshalDefinitionDeserializer extends YamlDeserializerBase<MarshalDefinition> {
        public MarshalDefinitionDeserializer() {
            super(MarshalDefinition.class);
        }

        @Override
        protected MarshalDefinition newInstance() {
            return new MarshalDefinition();
        }

        @Override
        protected boolean setProperty(MarshalDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "data-format-type": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "asn1": {
                    org.apache.camel.model.dataformat.ASN1DataFormat val = asType(node, org.apache.camel.model.dataformat.ASN1DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "avro": {
                    org.apache.camel.model.dataformat.AvroDataFormat val = asType(node, org.apache.camel.model.dataformat.AvroDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "barcode": {
                    org.apache.camel.model.dataformat.BarcodeDataFormat val = asType(node, org.apache.camel.model.dataformat.BarcodeDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "base64": {
                    org.apache.camel.model.dataformat.Base64DataFormat val = asType(node, org.apache.camel.model.dataformat.Base64DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "bindy": {
                    org.apache.camel.model.dataformat.BindyDataFormat val = asType(node, org.apache.camel.model.dataformat.BindyDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "cbor": {
                    org.apache.camel.model.dataformat.CBORDataFormat val = asType(node, org.apache.camel.model.dataformat.CBORDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "crypto": {
                    org.apache.camel.model.dataformat.CryptoDataFormat val = asType(node, org.apache.camel.model.dataformat.CryptoDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "csv": {
                    org.apache.camel.model.dataformat.CsvDataFormat val = asType(node, org.apache.camel.model.dataformat.CsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "custom": {
                    org.apache.camel.model.dataformat.CustomDataFormat val = asType(node, org.apache.camel.model.dataformat.CustomDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "fhir-json": {
                    org.apache.camel.model.dataformat.FhirJsonDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirJsonDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "fhir-xml": {
                    org.apache.camel.model.dataformat.FhirXmlDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirXmlDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "flatpack": {
                    org.apache.camel.model.dataformat.FlatpackDataFormat val = asType(node, org.apache.camel.model.dataformat.FlatpackDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "grok": {
                    org.apache.camel.model.dataformat.GrokDataFormat val = asType(node, org.apache.camel.model.dataformat.GrokDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "gzip-deflater": {
                    org.apache.camel.model.dataformat.GzipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.GzipDeflaterDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "hl7": {
                    org.apache.camel.model.dataformat.HL7DataFormat val = asType(node, org.apache.camel.model.dataformat.HL7DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "ical": {
                    org.apache.camel.model.dataformat.IcalDataFormat val = asType(node, org.apache.camel.model.dataformat.IcalDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "jackson-xml": {
                    org.apache.camel.model.dataformat.JacksonXMLDataFormat val = asType(node, org.apache.camel.model.dataformat.JacksonXMLDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "jaxb": {
                    org.apache.camel.model.dataformat.JaxbDataFormat val = asType(node, org.apache.camel.model.dataformat.JaxbDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "json": {
                    org.apache.camel.model.dataformat.JsonDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "json-api": {
                    org.apache.camel.model.dataformat.JsonApiDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonApiDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "lzf": {
                    org.apache.camel.model.dataformat.LZFDataFormat val = asType(node, org.apache.camel.model.dataformat.LZFDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "mime-multipart": {
                    org.apache.camel.model.dataformat.MimeMultipartDataFormat val = asType(node, org.apache.camel.model.dataformat.MimeMultipartDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "parquet-avro": {
                    org.apache.camel.model.dataformat.ParquetAvroDataFormat val = asType(node, org.apache.camel.model.dataformat.ParquetAvroDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "protobuf": {
                    org.apache.camel.model.dataformat.ProtobufDataFormat val = asType(node, org.apache.camel.model.dataformat.ProtobufDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "rss": {
                    org.apache.camel.model.dataformat.RssDataFormat val = asType(node, org.apache.camel.model.dataformat.RssDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "soap": {
                    org.apache.camel.model.dataformat.SoapDataFormat val = asType(node, org.apache.camel.model.dataformat.SoapDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "swift-mt": {
                    org.apache.camel.model.dataformat.SwiftMtDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMtDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "swift-mx": {
                    org.apache.camel.model.dataformat.SwiftMxDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMxDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "syslog": {
                    org.apache.camel.model.dataformat.SyslogDataFormat val = asType(node, org.apache.camel.model.dataformat.SyslogDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "tar-file": {
                    org.apache.camel.model.dataformat.TarFileDataFormat val = asType(node, org.apache.camel.model.dataformat.TarFileDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "thrift": {
                    org.apache.camel.model.dataformat.ThriftDataFormat val = asType(node, org.apache.camel.model.dataformat.ThriftDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "tidy-markup": {
                    org.apache.camel.model.dataformat.TidyMarkupDataFormat val = asType(node, org.apache.camel.model.dataformat.TidyMarkupDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-csv": {
                    org.apache.camel.model.dataformat.UniVocityCsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityCsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-fixed": {
                    org.apache.camel.model.dataformat.UniVocityFixedDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityFixedDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-tsv": {
                    org.apache.camel.model.dataformat.UniVocityTsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityTsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "xml-security": {
                    org.apache.camel.model.dataformat.XMLSecurityDataFormat val = asType(node, org.apache.camel.model.dataformat.XMLSecurityDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "pgp": {
                    org.apache.camel.model.dataformat.PGPDataFormat val = asType(node, org.apache.camel.model.dataformat.PGPDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "yaml": {
                    org.apache.camel.model.dataformat.YAMLDataFormat val = asType(node, org.apache.camel.model.dataformat.YAMLDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "zip-deflater": {
                    org.apache.camel.model.dataformat.ZipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipDeflaterDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "zip-file": {
                    org.apache.camel.model.dataformat.ZipFileDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipFileDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "method",
            inline = true,
            types = org.apache.camel.model.language.MethodCallExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Bean Method",
            description = "Calls a Java bean method.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "bean-type", type = "string", description = "Class name (fully qualified) of the bean to use Will lookup in registry and if there is a single instance of the same type, then the existing bean is used, otherwise a new bean is created (requires a default no-arg constructor).", displayName = "Bean Type"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "method", type = "string", description = "Name of method to call", displayName = "Method"),
                    @YamlProperty(name = "ref", type = "string", description = "Reference to an existing bean (bean id) to lookup in the registry", displayName = "Ref"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "scope", type = "enum:Singleton,Request,Prototype", defaultValue = "Singleton", description = "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. So when using prototype scope then this depends on the bean registry implementation.", displayName = "Scope"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class MethodCallExpressionDeserializer extends YamlDeserializerBase<MethodCallExpression> {
        public MethodCallExpressionDeserializer() {
            super(MethodCallExpression.class);
        }

        @Override
        protected MethodCallExpression newInstance() {
            return new MethodCallExpression();
        }

        @Override
        protected MethodCallExpression newInstance(String value) {
            return new MethodCallExpression(value);
        }

        @Override
        protected boolean setProperty(MethodCallExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "bean-type": {
                    String val = asText(node);
                    target.setBeanTypeName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "method": {
                    String val = asText(node);
                    target.setMethod(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "scope": {
                    String val = asText(node);
                    target.setScope(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "mime-multipart",
                    "mimeMultipart"
            },
            types = org.apache.camel.model.dataformat.MimeMultipartDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "MIME Multipart",
            description = "Marshal Camel messages with attachments into MIME-Multipart messages and back.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "binary-content", type = "boolean", description = "Defines whether the content of binary parts in the MIME multipart is binary (true) or Base-64 encoded (false) Default is false.", displayName = "Binary Content"),
                    @YamlProperty(name = "headers-inline", type = "boolean", description = "Defines whether the MIME-Multipart headers are part of the message body (true) or are set as Camel headers (false). Default is false.", displayName = "Headers Inline"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "include-headers", type = "string", description = "A regex that defines which Camel headers are also included as MIME headers into the MIME multipart. This will only work if headersInline is set to true. Default is to include no headers", displayName = "Include Headers"),
                    @YamlProperty(name = "multipart-sub-type", type = "string", defaultValue = "mixed", description = "Specify the subtype of the MIME Multipart. Default is mixed.", displayName = "Multipart Sub Type"),
                    @YamlProperty(name = "multipart-without-attachment", type = "boolean", description = "Defines whether a message without attachment is also marshaled into a MIME Multipart (with only one body part). Default is false.", displayName = "Multipart Without Attachment")
            }
    )
    public static class MimeMultipartDataFormatDeserializer extends YamlDeserializerBase<MimeMultipartDataFormat> {
        public MimeMultipartDataFormatDeserializer() {
            super(MimeMultipartDataFormat.class);
        }

        @Override
        protected MimeMultipartDataFormat newInstance() {
            return new MimeMultipartDataFormat();
        }

        @Override
        protected boolean setProperty(MimeMultipartDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "binary-content": {
                    String val = asText(node);
                    target.setBinaryContent(val);
                    break;
                }
                case "headers-inline": {
                    String val = asText(node);
                    target.setHeadersInline(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "include-headers": {
                    String val = asText(node);
                    target.setIncludeHeaders(val);
                    break;
                }
                case "multipart-sub-type": {
                    String val = asText(node);
                    target.setMultipartSubType(val);
                    break;
                }
                case "multipart-without-attachment": {
                    String val = asText(node);
                    target.setMultipartWithoutAttachment(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "multicast",
            types = org.apache.camel.model.MulticastDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Multicast",
            description = "Routes the same message to multiple paths either sequentially or in parallel.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "aggregation-strategy", type = "string", description = "Refers to an AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy", displayName = "Aggregation Strategy"),
                    @YamlProperty(name = "aggregation-strategy-method-allow-null", type = "boolean", description = "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy", displayName = "Aggregation Strategy Method Allow Null"),
                    @YamlProperty(name = "aggregation-strategy-method-name", type = "string", description = "This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Name"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "executor-service", type = "string", description = "Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.", displayName = "Executor Service"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "on-prepare", type = "string", description = "Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send, or any custom logic needed before the exchange is send.", displayName = "On Prepare"),
                    @YamlProperty(name = "parallel-aggregate", type = "boolean", description = "If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.", displayName = "Parallel Aggregate"),
                    @YamlProperty(name = "parallel-processing", type = "boolean", description = "If enabled then sending messages to the multicasts occurs concurrently. Note the caller thread will still wait until all messages has been fully processed, before it continues. Its only the sending and processing the replies from the multicasts which happens concurrently. When parallel processing is enabled, then the Camel routing engin will continue processing using last used thread from the parallel thread pool. However, if you want to use the original thread that called the multicast, then make sure to enable the synchronous option as well.", displayName = "Parallel Processing"),
                    @YamlProperty(name = "share-unit-of-work", type = "boolean", description = "Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Multicast will by default not share unit of work between the parent exchange and each multicasted exchange. This means each sub exchange has its own individual unit of work.", displayName = "Share Unit Of Work"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "stop-on-exception", type = "boolean", description = "Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the multicast will stop further processing. This is the same behavior as in pipeline, which is used by the routing engine. The default behavior is to not stop but continue processing till the end", displayName = "Stop On Exception"),
                    @YamlProperty(name = "streaming", type = "boolean", description = "If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as defined by the multicast.", displayName = "Streaming"),
                    @YamlProperty(name = "synchronous", type = "boolean", description = "Sets whether synchronous processing should be strictly used. When enabled then the same thread is used to continue routing after the multicast is complete, even if parallel processing is enabled.", displayName = "Synchronous"),
                    @YamlProperty(name = "timeout", type = "string", defaultValue = "0", description = "Sets a total timeout specified in millis, when using parallel processing. If the Multicast hasn't been able to send and process all replies within the given timeframe, then the timeout triggers and the Multicast breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.", displayName = "Timeout")
            }
    )
    public static class MulticastDefinitionDeserializer extends YamlDeserializerBase<MulticastDefinition> {
        public MulticastDefinitionDeserializer() {
            super(MulticastDefinition.class);
        }

        @Override
        protected MulticastDefinition newInstance() {
            return new MulticastDefinition();
        }

        @Override
        protected boolean setProperty(MulticastDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "aggregation-strategy": {
                    String val = asText(node);
                    target.setAggregationStrategy(val);
                    break;
                }
                case "aggregation-strategy-method-allow-null": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodAllowNull(val);
                    break;
                }
                case "aggregation-strategy-method-name": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodName(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "on-prepare": {
                    String val = asText(node);
                    target.setOnPrepare(val);
                    break;
                }
                case "parallel-aggregate": {
                    String val = asText(node);
                    target.setParallelAggregate(val);
                    break;
                }
                case "parallel-processing": {
                    String val = asText(node);
                    target.setParallelProcessing(val);
                    break;
                }
                case "share-unit-of-work": {
                    String val = asText(node);
                    target.setShareUnitOfWork(val);
                    break;
                }
                case "stop-on-exception": {
                    String val = asText(node);
                    target.setStopOnException(val);
                    break;
                }
                case "streaming": {
                    String val = asText(node);
                    target.setStreaming(val);
                    break;
                }
                case "synchronous": {
                    String val = asText(node);
                    target.setSynchronous(val);
                    break;
                }
                case "timeout": {
                    String val = asText(node);
                    target.setTimeout(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "mutual-tls",
                    "mutualTLS"
            },
            types = org.apache.camel.model.rest.MutualTLSDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Mutual TLS",
            description = "Rest security mutual TLS authentication definition",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "A short description for security scheme.", displayName = "Description"),
                    @YamlProperty(name = "key", type = "string", required = true, description = "Key used to refer to this security definition", displayName = "Key")
            }
    )
    public static class MutualTLSDefinitionDeserializer extends YamlDeserializerBase<MutualTLSDefinition> {
        public MutualTLSDefinitionDeserializer() {
            super(MutualTLSDefinition.class);
        }

        @Override
        protected MutualTLSDefinition newInstance() {
            return new MutualTLSDefinition();
        }

        @Override
        protected boolean setProperty(MutualTLSDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "mvel",
            inline = true,
            types = org.apache.camel.model.language.MvelExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "MVEL",
            description = "Evaluates a MVEL template.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class MvelExpressionDeserializer extends YamlDeserializerBase<MvelExpression> {
        public MvelExpressionDeserializer() {
            super(MvelExpression.class);
        }

        @Override
        protected MvelExpression newInstance() {
            return new MvelExpression();
        }

        @Override
        protected MvelExpression newInstance(String value) {
            return new MvelExpression(value);
        }

        @Override
        protected boolean setProperty(MvelExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "no-error-handler",
                    "noErrorHandler"
            },
            types = org.apache.camel.model.errorhandler.NoErrorHandlerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "No Error Handler",
            description = "To not use an error handler.",
            deprecated = false,
            properties = @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
    )
    public static class NoErrorHandlerDefinitionDeserializer extends YamlDeserializerBase<NoErrorHandlerDefinition> {
        public NoErrorHandlerDefinitionDeserializer() {
            super(NoErrorHandlerDefinition.class);
        }

        @Override
        protected NoErrorHandlerDefinition newInstance() {
            return new NoErrorHandlerDefinition();
        }

        @Override
        protected boolean setProperty(NoErrorHandlerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "oauth2",
            types = org.apache.camel.model.rest.OAuth2Definition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Oauth2",
            description = "Rest security OAuth2 definition",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "authorization-url", type = "string", description = "The authorization URL to be used for this flow. This SHOULD be in the form of a URL. Required for implicit and access code flows", displayName = "Authorization Url"),
                    @YamlProperty(name = "description", type = "string", description = "A short description for security scheme.", displayName = "Description"),
                    @YamlProperty(name = "flow", type = "enum:implicit,password,application,clientCredentials,accessCode,authorizationCode", description = "The flow used by the OAuth2 security scheme. Valid values are implicit, password, application or accessCode.", displayName = "Flow"),
                    @YamlProperty(name = "key", type = "string", required = true, description = "Key used to refer to this security definition", displayName = "Key"),
                    @YamlProperty(name = "refresh-url", type = "string", description = "The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL.", displayName = "Refresh Url"),
                    @YamlProperty(name = "scopes", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "The available scopes for an OAuth2 security scheme", displayName = "Scopes"),
                    @YamlProperty(name = "token-url", type = "string", description = "The token URL to be used for this flow. This SHOULD be in the form of a URL. Required for password, application, and access code flows.", displayName = "Token Url")
            }
    )
    public static class OAuth2DefinitionDeserializer extends YamlDeserializerBase<OAuth2Definition> {
        public OAuth2DefinitionDeserializer() {
            super(OAuth2Definition.class);
        }

        @Override
        protected OAuth2Definition newInstance() {
            return new OAuth2Definition();
        }

        @Override
        protected boolean setProperty(OAuth2Definition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "authorization-url": {
                    String val = asText(node);
                    target.setAuthorizationUrl(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "flow": {
                    String val = asText(node);
                    target.setFlow(val);
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "refresh-url": {
                    String val = asText(node);
                    target.setRefreshUrl(val);
                    break;
                }
                case "scopes": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setScopes(val);
                    break;
                }
                case "token-url": {
                    String val = asText(node);
                    target.setTokenUrl(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "ognl",
            inline = true,
            types = org.apache.camel.model.language.OgnlExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "OGNL",
            description = "Evaluates an OGNL expression (Apache Commons OGNL).",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class OgnlExpressionDeserializer extends YamlDeserializerBase<OgnlExpression> {
        public OgnlExpressionDeserializer() {
            super(OgnlExpression.class);
        }

        @Override
        protected OgnlExpression newInstance() {
            return new OgnlExpression();
        }

        @Override
        protected OgnlExpression newInstance(String value) {
            return new OgnlExpression(value);
        }

        @Override
        protected boolean setProperty(OgnlExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlIn
    @YamlType(
            nodes = {
                    "on-completion",
                    "onCompletion"
            },
            types = org.apache.camel.model.OnCompletionDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "On Completion",
            description = "Route to be executed when normal route processing completes",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "executor-service", type = "string", description = "To use a custom Thread Pool to be used for parallel processing. Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.", displayName = "Executor Service"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "mode", type = "enum:AfterConsumer,BeforeConsumer", defaultValue = "AfterConsumer", description = "Sets the on completion mode. The default value is AfterConsumer", displayName = "Mode"),
                    @YamlProperty(name = "on-complete-only", type = "boolean", description = "Will only synchronize when the org.apache.camel.Exchange completed successfully (no errors).", displayName = "On Complete Only"),
                    @YamlProperty(name = "on-failure-only", type = "boolean", description = "Will only synchronize when the org.apache.camel.Exchange ended with failure (exception or FAULT message).", displayName = "On Failure Only"),
                    @YamlProperty(name = "on-when", type = "object:org.apache.camel.model.WhenDefinition", description = "Sets an additional predicate that should be true before the onCompletion is triggered. To be used for fine grained controlling whether a completion callback should be invoked or not", displayName = "On When"),
                    @YamlProperty(name = "parallel-processing", type = "boolean", description = "If enabled then the on completion process will run asynchronously by a separate thread from a thread pool. By default this is false, meaning the on completion process will run synchronously using the same caller thread as from the route.", displayName = "Parallel Processing"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "use-original-message", type = "boolean", description = "Will use the original input message body when an org.apache.camel.Exchange for this on completion. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the split message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Message")
            }
    )
    public static class OnCompletionDefinitionDeserializer extends YamlDeserializerBase<OnCompletionDefinition> {
        public OnCompletionDefinitionDeserializer() {
            super(OnCompletionDefinition.class);
        }

        @Override
        protected OnCompletionDefinition newInstance() {
            return new OnCompletionDefinition();
        }

        @Override
        protected boolean setProperty(OnCompletionDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "mode": {
                    String val = asText(node);
                    target.setMode(val);
                    break;
                }
                case "on-complete-only": {
                    String val = asText(node);
                    target.setOnCompleteOnly(val);
                    break;
                }
                case "on-failure-only": {
                    String val = asText(node);
                    target.setOnFailureOnly(val);
                    break;
                }
                case "on-when": {
                    org.apache.camel.model.WhenDefinition val = asType(node, org.apache.camel.model.WhenDefinition.class);
                    target.setOnWhen(val);
                    break;
                }
                case "parallel-processing": {
                    String val = asText(node);
                    target.setParallelProcessing(val);
                    break;
                }
                case "use-original-message": {
                    String val = asText(node);
                    target.setUseOriginalMessage(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlIn
    @YamlType(
            nodes = {
                    "on-exception",
                    "onException"
            },
            types = org.apache.camel.model.OnExceptionDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "On Exception",
            description = "Route to be executed when an exception is thrown",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "continued", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "Sets whether the exchange should handle and continue routing from the point of failure. If this option is enabled then its considered handled as well.", displayName = "Continued"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "exception", type = "array:string", description = "A set of exceptions to react upon.", displayName = "Exception"),
                    @YamlProperty(name = "handled", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "Sets whether the exchange should be marked as handled or not.", displayName = "Handled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "on-exception-occurred-ref", type = "string", description = "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.", displayName = "On Exception Occurred Ref"),
                    @YamlProperty(name = "on-redelivery-ref", type = "string", description = "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.", displayName = "On Redelivery Ref"),
                    @YamlProperty(name = "on-when", type = "object:org.apache.camel.model.WhenDefinition", description = "Sets an additional predicate that should be true before the onException is triggered. To be used for fine grained controlling whether a thrown exception should be intercepted by this exception type or not.", displayName = "On When"),
                    @YamlProperty(name = "redelivery-policy", type = "object:org.apache.camel.model.RedeliveryPolicyDefinition", description = "Used for configuring redelivery options", displayName = "Redelivery Policy"),
                    @YamlProperty(name = "redelivery-policy-ref", type = "string", description = "Sets a reference to a redelivery policy to lookup in the org.apache.camel.spi.Registry to be used.", displayName = "Redelivery Policy Ref"),
                    @YamlProperty(name = "retry-while", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "Sets the retry while predicate. Will continue retrying until predicate returns false.", displayName = "Retry While"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "use-original-body", type = "boolean", description = "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the split message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Body"),
                    @YamlProperty(name = "use-original-message", type = "boolean", description = "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the split message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Message")
            }
    )
    public static class OnExceptionDefinitionDeserializer extends YamlDeserializerBase<OnExceptionDefinition> {
        public OnExceptionDefinitionDeserializer() {
            super(OnExceptionDefinition.class);
        }

        @Override
        protected OnExceptionDefinition newInstance() {
            return new OnExceptionDefinition();
        }

        @Override
        protected boolean setProperty(OnExceptionDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "continued": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setContinued(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "exception": {
                    java.util.List<String> val = asStringList(node);
                    target.setExceptions(val);
                    break;
                }
                case "handled": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setHandled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "on-exception-occurred-ref": {
                    String val = asText(node);
                    target.setOnExceptionOccurredRef(val);
                    break;
                }
                case "on-redelivery-ref": {
                    String val = asText(node);
                    target.setOnRedeliveryRef(val);
                    break;
                }
                case "on-when": {
                    org.apache.camel.model.WhenDefinition val = asType(node, org.apache.camel.model.WhenDefinition.class);
                    target.setOnWhen(val);
                    break;
                }
                case "redelivery-policy-ref": {
                    String val = asText(node);
                    target.setRedeliveryPolicyRef(val);
                    break;
                }
                case "redelivery-policy": {
                    org.apache.camel.model.RedeliveryPolicyDefinition val = asType(node, org.apache.camel.model.RedeliveryPolicyDefinition.class);
                    target.setRedeliveryPolicyType(val);
                    break;
                }
                case "retry-while": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setRetryWhile(val);
                    break;
                }
                case "use-original-body": {
                    String val = asText(node);
                    target.setUseOriginalBody(val);
                    break;
                }
                case "use-original-message": {
                    String val = asText(node);
                    target.setUseOriginalMessage(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "on-fallback",
                    "onFallback"
            },
            types = org.apache.camel.model.OnFallbackDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "On Fallback",
            description = "Route to be executed when Circuit Breaker EIP executes fallback",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "fallback-via-network", type = "boolean", description = "Whether the fallback goes over the network. If the fallback will go over the network it is another possible point of failure. It is important to execute the fallback command on a separate thread-pool, otherwise if the main command were to become latent and fill the thread-pool this would prevent the fallback from running if the two commands share the same pool.", displayName = "Fallback Via Network"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class OnFallbackDefinitionDeserializer extends YamlDeserializerBase<OnFallbackDefinition> {
        public OnFallbackDefinitionDeserializer() {
            super(OnFallbackDefinition.class);
        }

        @Override
        protected OnFallbackDefinition newInstance() {
            return new OnFallbackDefinition();
        }

        @Override
        protected boolean setProperty(OnFallbackDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "fallback-via-network": {
                    String val = asText(node);
                    target.setFallbackViaNetwork(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "open-id-connect",
                    "openIdConnect"
            },
            types = org.apache.camel.model.rest.OpenIdConnectDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Open Id Connect",
            description = "Rest security OpenID Connect definition",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "A short description for security scheme.", displayName = "Description"),
                    @YamlProperty(name = "key", type = "string", required = true, description = "Key used to refer to this security definition", displayName = "Key"),
                    @YamlProperty(name = "url", type = "string", required = true, description = "OpenId Connect URL to discover OAuth2 configuration values.", displayName = "Url")
            }
    )
    public static class OpenIdConnectDefinitionDeserializer extends YamlDeserializerBase<OpenIdConnectDefinition> {
        public OpenIdConnectDefinitionDeserializer() {
            super(OpenIdConnectDefinition.class);
        }

        @Override
        protected OpenIdConnectDefinition newInstance() {
            return new OpenIdConnectDefinition();
        }

        @Override
        protected boolean setProperty(OpenIdConnectDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "url": {
                    String val = asText(node);
                    target.setUrl(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "optimistic-lock-retry-policy",
                    "optimisticLockRetryPolicy"
            },
            types = org.apache.camel.model.OptimisticLockRetryPolicyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Optimistic Lock Retry Policy",
            description = "To configure optimistic locking",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "exponential-back-off", type = "boolean", description = "Enable exponential backoff", displayName = "Exponential Back Off"),
                    @YamlProperty(name = "maximum-retries", type = "number", description = "Sets the maximum number of retries", displayName = "Maximum Retries"),
                    @YamlProperty(name = "maximum-retry-delay", type = "string", defaultValue = "1000", description = "Sets the upper value of retry in millis between retries, when using exponential or random backoff", displayName = "Maximum Retry Delay"),
                    @YamlProperty(name = "random-back-off", type = "boolean", description = "Enables random backoff", displayName = "Random Back Off"),
                    @YamlProperty(name = "retry-delay", type = "string", defaultValue = "50", description = "Sets the delay in millis between retries", displayName = "Retry Delay")
            }
    )
    public static class OptimisticLockRetryPolicyDefinitionDeserializer extends YamlDeserializerBase<OptimisticLockRetryPolicyDefinition> {
        public OptimisticLockRetryPolicyDefinitionDeserializer() {
            super(OptimisticLockRetryPolicyDefinition.class);
        }

        @Override
        protected OptimisticLockRetryPolicyDefinition newInstance() {
            return new OptimisticLockRetryPolicyDefinition();
        }

        @Override
        protected boolean setProperty(OptimisticLockRetryPolicyDefinition target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "exponential-back-off": {
                    String val = asText(node);
                    target.setExponentialBackOff(val);
                    break;
                }
                case "maximum-retries": {
                    String val = asText(node);
                    target.setMaximumRetries(val);
                    break;
                }
                case "maximum-retry-delay": {
                    String val = asText(node);
                    target.setMaximumRetryDelay(val);
                    break;
                }
                case "random-back-off": {
                    String val = asText(node);
                    target.setRandomBackOff(val);
                    break;
                }
                case "retry-delay": {
                    String val = asText(node);
                    target.setRetryDelay(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "otherwise",
            types = org.apache.camel.model.OtherwiseDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Otherwise",
            description = "Route to be executed when all other choices evaluate to false",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class OtherwiseDefinitionDeserializer extends YamlDeserializerBase<OtherwiseDefinition> {
        public OtherwiseDefinitionDeserializer() {
            super(OtherwiseDefinition.class);
        }

        @Override
        protected OtherwiseDefinition newInstance() {
            return new OtherwiseDefinition();
        }

        @Override
        protected boolean setProperty(OtherwiseDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.OutputDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "description", type = "string"),
                    @YamlProperty(name = "disabled", type = "boolean"),
                    @YamlProperty(name = "id", type = "string"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class OutputDefinitionDeserializer extends YamlDeserializerBase<OutputDefinition> {
        public OutputDefinitionDeserializer() {
            super(OutputDefinition.class);
        }

        @Override
        protected OutputDefinition newInstance() {
            return new OutputDefinition();
        }

        @Override
        protected boolean setProperty(OutputDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "output-type",
                    "outputType"
            },
            types = org.apache.camel.model.OutputTypeDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Output Type",
            description = "Set the expected data type of the output message. If the actual message type is different at runtime, camel look for a required Transformer and apply if exists. If validate attribute is true then camel applies Validator as well. Type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name' is a fully qualified class name. For example {code java:java.lang.String} , {code json:ABCOrder} . It's also possible to specify only scheme part, so that it works like a wildcard. If only 'xml' is specified, all the XML message matches. It's handy to add only one transformer/validator for all the XML-Java transformation.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "urn", type = "string", required = true, description = "Set output type URN.", displayName = "Urn"),
                    @YamlProperty(name = "validate", type = "boolean", description = "Whether if validation is required for this output type.", displayName = "Validate")
            }
    )
    public static class OutputTypeDefinitionDeserializer extends YamlDeserializerBase<OutputTypeDefinition> {
        public OutputTypeDefinitionDeserializer() {
            super(OutputTypeDefinition.class);
        }

        @Override
        protected OutputTypeDefinition newInstance() {
            return new OutputTypeDefinition();
        }

        @Override
        protected boolean setProperty(OutputTypeDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "urn": {
                    String val = asText(node);
                    target.setUrn(val);
                    break;
                }
                case "validate": {
                    String val = asText(node);
                    target.setValidate(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "pgp",
            types = org.apache.camel.model.dataformat.PGPDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "PGP",
            description = "Encrypt and decrypt messages using Java Cryptographic Extension (JCE) and PGP.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "algorithm", type = "number", description = "Symmetric key encryption algorithm; possible values are defined in org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags; for example 2 (= TRIPLE DES), 3 (= CAST5), 4 (= BLOWFISH), 6 (= DES), 7 (= AES_128). Only relevant for encrypting.", displayName = "Algorithm"),
                    @YamlProperty(name = "armored", type = "boolean", description = "This option will cause PGP to base64 encode the encrypted text, making it available for copy/paste, etc.", displayName = "Armored"),
                    @YamlProperty(name = "compression-algorithm", type = "number", description = "Compression algorithm; possible values are defined in org.bouncycastle.bcpg.CompressionAlgorithmTags; for example 0 (= UNCOMPRESSED), 1 (= ZIP), 2 (= ZLIB), 3 (= BZIP2). Only relevant for encrypting.", displayName = "Compression Algorithm"),
                    @YamlProperty(name = "hash-algorithm", type = "number", description = "Signature hash algorithm; possible values are defined in org.bouncycastle.bcpg.HashAlgorithmTags; for example 2 (= SHA1), 8 (= SHA256), 9 (= SHA384), 10 (= SHA512), 11 (=SHA224). Only relevant for signing.", displayName = "Hash Algorithm"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "integrity", type = "boolean", description = "Adds an integrity check/sign into the encryption file. The default value is true.", displayName = "Integrity"),
                    @YamlProperty(name = "key-file-name", type = "string", description = "Filename of the keyring; must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).", displayName = "Key File Name"),
                    @YamlProperty(name = "key-userid", type = "string", description = "The user ID of the key in the PGP keyring used during encryption. Can also be only a part of a user ID. For example, if the user ID is Test User then you can use the part Test User or to address the user ID.", displayName = "Key Userid"),
                    @YamlProperty(name = "password", type = "string", description = "Password used when opening the private key (not used for encryption).", displayName = "Password"),
                    @YamlProperty(name = "provider", type = "string", description = "Java Cryptography Extension (JCE) provider, default is Bouncy Castle (BC). Alternatively you can use, for example, the IAIK JCE provider; in this case the provider must be registered beforehand and the Bouncy Castle provider must not be registered beforehand. The Sun JCE provider does not work.", displayName = "Provider"),
                    @YamlProperty(name = "signature-key-file-name", type = "string", description = "Filename of the keyring to use for signing (during encryption) or for signature verification (during decryption); must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).", displayName = "Signature Key File Name"),
                    @YamlProperty(name = "signature-key-ring", type = "string", description = "Keyring used for signing/verifying as byte array. You can not set the signatureKeyFileName and signatureKeyRing at the same time.", displayName = "Signature Key Ring"),
                    @YamlProperty(name = "signature-key-userid", type = "string", description = "User ID of the key in the PGP keyring used for signing (during encryption) or signature verification (during decryption). During the signature verification process the specified User ID restricts the public keys from the public keyring which can be used for the verification. If no User ID is specified for the signature verficiation then any public key in the public keyring can be used for the verification. Can also be only a part of a user ID. For example, if the user ID is Test User then you can use the part Test User or to address the User ID.", displayName = "Signature Key Userid"),
                    @YamlProperty(name = "signature-password", type = "string", description = "Password used when opening the private key used for signing (during encryption).", displayName = "Signature Password"),
                    @YamlProperty(name = "signature-verification-option", type = "string", description = "Controls the behavior for verifying the signature during unmarshaling. There are 4 values possible: optional: The PGP message may or may not contain signatures; if it does contain signatures, then a signature verification is executed. required: The PGP message must contain at least one signature; if this is not the case an exception (PGPException) is thrown. A signature verification is executed. ignore: Contained signatures in the PGP message are ignored; no signature verification is executed. no_signature_allowed: The PGP message must not contain a signature; otherwise an exception (PGPException) is thrown.", displayName = "Signature Verification Option")
            }
    )
    public static class PGPDataFormatDeserializer extends YamlDeserializerBase<PGPDataFormat> {
        public PGPDataFormatDeserializer() {
            super(PGPDataFormat.class);
        }

        @Override
        protected PGPDataFormat newInstance() {
            return new PGPDataFormat();
        }

        @Override
        protected boolean setProperty(PGPDataFormat target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "algorithm": {
                    String val = asText(node);
                    target.setAlgorithm(val);
                    break;
                }
                case "armored": {
                    String val = asText(node);
                    target.setArmored(val);
                    break;
                }
                case "compression-algorithm": {
                    String val = asText(node);
                    target.setCompressionAlgorithm(val);
                    break;
                }
                case "hash-algorithm": {
                    String val = asText(node);
                    target.setHashAlgorithm(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "integrity": {
                    String val = asText(node);
                    target.setIntegrity(val);
                    break;
                }
                case "key-file-name": {
                    String val = asText(node);
                    target.setKeyFileName(val);
                    break;
                }
                case "key-userid": {
                    String val = asText(node);
                    target.setKeyUserid(val);
                    break;
                }
                case "password": {
                    String val = asText(node);
                    target.setPassword(val);
                    break;
                }
                case "provider": {
                    String val = asText(node);
                    target.setProvider(val);
                    break;
                }
                case "signature-key-file-name": {
                    String val = asText(node);
                    target.setSignatureKeyFileName(val);
                    break;
                }
                case "signature-key-ring": {
                    String val = asText(node);
                    target.setSignatureKeyRing(val);
                    break;
                }
                case "signature-key-userid": {
                    String val = asText(node);
                    target.setSignatureKeyUserid(val);
                    break;
                }
                case "signature-password": {
                    String val = asText(node);
                    target.setSignaturePassword(val);
                    break;
                }
                case "signature-verification-option": {
                    String val = asText(node);
                    target.setSignatureVerificationOption(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "package-scan",
                    "packageScan"
            },
            types = org.apache.camel.model.PackageScanDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Package Scan",
            description = "Scans for Java org.apache.camel.builder.RouteBuilder classes in java packages",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "excludes", type = "array:string", description = "Exclude finding route builder from these java package names.", displayName = "Excludes"),
                    @YamlProperty(name = "includes", type = "array:string", description = "Include finding route builder from these java package names.", displayName = "Includes"),
                    @YamlProperty(name = "package", type = "array:string", description = "Sets the java package names to use for scanning for route builder classes", displayName = "Package")
            }
    )
    public static class PackageScanDefinitionDeserializer extends YamlDeserializerBase<PackageScanDefinition> {
        public PackageScanDefinitionDeserializer() {
            super(PackageScanDefinition.class);
        }

        @Override
        protected PackageScanDefinition newInstance() {
            return new PackageScanDefinition();
        }

        @Override
        protected boolean setProperty(PackageScanDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "excludes": {
                    java.util.List<String> val = asStringList(node);
                    target.setExcludes(val);
                    break;
                }
                case "includes": {
                    java.util.List<String> val = asStringList(node);
                    target.setIncludes(val);
                    break;
                }
                case "package": {
                    java.util.List<String> val = asStringList(node);
                    target.setPackages(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "param",
            types = org.apache.camel.model.rest.ParamDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Param",
            description = "To specify the rest operation parameters.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allowable-values", type = "array:org.apache.camel.model.ValueDefinition", description = "Sets the parameter list of allowable values (enum).", displayName = "Allowable Values"),
                    @YamlProperty(name = "array-type", type = "string", defaultValue = "string", description = "Sets the parameter array type. Required if data type is array. Describes the type of items in the array.", displayName = "Array Type"),
                    @YamlProperty(name = "collection-format", type = "enum:csv,multi,pipes,ssv,tsv", defaultValue = "csv", description = "Sets the parameter collection format.", displayName = "Collection Format"),
                    @YamlProperty(name = "data-format", type = "string", description = "Sets the parameter data format.", displayName = "Data Format"),
                    @YamlProperty(name = "data-type", type = "string", defaultValue = "string", description = "Sets the parameter data type.", displayName = "Data Type"),
                    @YamlProperty(name = "default-value", type = "string", description = "Sets the parameter default value.", displayName = "Default Value"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the parameter description.", displayName = "Description"),
                    @YamlProperty(name = "examples", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Sets the parameter examples.", displayName = "Examples"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "Sets the parameter name.", displayName = "Name"),
                    @YamlProperty(name = "required", type = "boolean", description = "Sets the parameter required flag.", displayName = "Required"),
                    @YamlProperty(name = "type", type = "enum:body,formData,header,path,query", defaultValue = "path", description = "Sets the parameter type.", displayName = "Type")
            }
    )
    public static class ParamDefinitionDeserializer extends YamlDeserializerBase<ParamDefinition> {
        public ParamDefinitionDeserializer() {
            super(ParamDefinition.class);
        }

        @Override
        protected ParamDefinition newInstance() {
            return new ParamDefinition();
        }

        @Override
        protected boolean setProperty(ParamDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allowable-values": {
                    java.util.List<org.apache.camel.model.ValueDefinition> val = asFlatList(node, org.apache.camel.model.ValueDefinition.class);
                    target.setAllowableValues(val);
                    break;
                }
                case "array-type": {
                    String val = asText(node);
                    target.setArrayType(val);
                    break;
                }
                case "collection-format": {
                    target.setCollectionFormat(asEnum(node, org.apache.camel.model.rest.CollectionFormat.class));
                    break;
                }
                case "data-format": {
                    String val = asText(node);
                    target.setDataFormat(val);
                    break;
                }
                case "data-type": {
                    String val = asText(node);
                    target.setDataType(val);
                    break;
                }
                case "default-value": {
                    String val = asText(node);
                    target.setDefaultValue(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "examples": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setExamples(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "required": {
                    String val = asText(node);
                    target.setRequired(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "type": {
                    target.setType(asEnum(node, org.apache.camel.model.rest.RestParamType.class));
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "parquet-avro",
                    "parquetAvro"
            },
            inline = true,
            types = org.apache.camel.model.dataformat.ParquetAvroDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Parquet File",
            description = "Parquet Avro serialization and de-serialization.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "compression-codec-name", type = "string", defaultValue = "GZIP", description = "Compression codec to use when marshalling.", displayName = "Compression Codec Name"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class to use when (un)marshalling. If omitted, parquet files are converted into Avro's GenericRecords for unmarshalling and input objects are assumed as GenericRecords for marshalling.", displayName = "Unmarshal Type")
            }
    )
    public static class ParquetAvroDataFormatDeserializer extends YamlDeserializerBase<ParquetAvroDataFormat> {
        public ParquetAvroDataFormatDeserializer() {
            super(ParquetAvroDataFormat.class);
        }

        @Override
        protected ParquetAvroDataFormat newInstance() {
            return new ParquetAvroDataFormat();
        }

        @Override
        protected ParquetAvroDataFormat newInstance(String value) {
            return new ParquetAvroDataFormat(value);
        }

        @Override
        protected boolean setProperty(ParquetAvroDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "compression-codec-name": {
                    String val = asText(node);
                    target.setCompressionCodecName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "pass-through-service-filter",
                    "passThroughServiceFilter"
            },
            types = org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Pass Through Service Filter",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class PassThroughServiceCallServiceFilterConfigurationDeserializer extends YamlDeserializerBase<PassThroughServiceCallServiceFilterConfiguration> {
        public PassThroughServiceCallServiceFilterConfigurationDeserializer() {
            super(PassThroughServiceCallServiceFilterConfiguration.class);
        }

        @Override
        protected PassThroughServiceCallServiceFilterConfiguration newInstance() {
            return new PassThroughServiceCallServiceFilterConfiguration();
        }

        @Override
        protected boolean setProperty(PassThroughServiceCallServiceFilterConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "patch",
            types = org.apache.camel.model.rest.PatchDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Patch",
            description = "Rest PATCH command",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-docs", type = "boolean", description = "Whether to include or exclude this rest operation in API documentation. The default value is true.", displayName = "Api Docs"),
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json. This option will override what may be configured on a parent level", displayName = "Consumes"),
                    @YamlProperty(name = "deprecated", type = "boolean", description = "Marks this rest operation as deprecated in OpenApi documentation.", displayName = "Deprecated"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this REST service from the route during build time. Once an REST service has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "out-type", type = "string", description = "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Out Type"),
                    @YamlProperty(name = "param", type = "array:org.apache.camel.model.rest.ParamDefinition"),
                    @YamlProperty(name = "path", type = "string", description = "The path mapping URIs of this REST operation such as /{id}.", displayName = "Path"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json This option will override what may be configured on a parent level", displayName = "Produces"),
                    @YamlProperty(name = "response-message", type = "array:org.apache.camel.model.rest.ResponseMessageDefinition"),
                    @YamlProperty(name = "route-id", type = "string", description = "Sets the id of the route", displayName = "Route Id"),
                    @YamlProperty(name = "security", type = "array:org.apache.camel.model.rest.SecurityDefinition"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do. This option will override what may be configured on a parent level", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "to", type = "object:org.apache.camel.model.ToDefinition", description = "The Camel endpoint this REST service will call, such as a direct endpoint to link to an existing route that handles this REST call.", displayName = "To"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level. The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Type")
            }
    )
    public static class PatchDefinitionDeserializer extends YamlDeserializerBase<PatchDefinition> {
        public PatchDefinitionDeserializer() {
            super(PatchDefinition.class);
        }

        @Override
        protected PatchDefinition newInstance() {
            return new PatchDefinition();
        }

        @Override
        protected boolean setProperty(PatchDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "api-docs": {
                    String val = asText(node);
                    target.setApiDocs(val);
                    break;
                }
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "deprecated": {
                    String val = asText(node);
                    target.setDeprecated(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "out-type": {
                    String val = asText(node);
                    target.setOutType(val);
                    break;
                }
                case "param": {
                    java.util.List<org.apache.camel.model.rest.ParamDefinition> val = asFlatList(node, org.apache.camel.model.rest.ParamDefinition.class);
                    target.setParams(val);
                    break;
                }
                case "path": {
                    String val = asText(node);
                    target.setPath(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "response-message": {
                    java.util.List<org.apache.camel.model.rest.ResponseMessageDefinition> val = asFlatList(node, org.apache.camel.model.rest.ResponseMessageDefinition.class);
                    target.setResponseMsgs(val);
                    break;
                }
                case "route-id": {
                    String val = asText(node);
                    target.setRouteId(val);
                    break;
                }
                case "security": {
                    java.util.List<org.apache.camel.model.rest.SecurityDefinition> val = asFlatList(node, org.apache.camel.model.rest.SecurityDefinition.class);
                    target.setSecurity(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "to": {
                    org.apache.camel.model.ToDefinition val = asType(node, org.apache.camel.model.ToDefinition.class);
                    target.setTo(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "pausable",
            types = org.apache.camel.model.PausableDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Pausable",
            description = "Pausable EIP to support resuming processing from last known offset.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "consumer-listener", type = "string", required = true, description = "Sets the consumer listener to use", displayName = "Consumer Listener"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "until-check", type = "string", required = true, description = "References to a java.util.function.Predicate to use for until checks. The predicate is responsible for evaluating whether the processing can resume or not. Such predicate should return true if the consumption can resume, or false otherwise. The exact point of when the predicate is called is dependent on the component, and it may be called on either one of the available events. Implementations should not assume the predicate to be called at any specific point.", displayName = "Until Check")
            }
    )
    public static class PausableDefinitionDeserializer extends YamlDeserializerBase<PausableDefinition> {
        public PausableDefinitionDeserializer() {
            super(PausableDefinition.class);
        }

        @Override
        protected PausableDefinition newInstance() {
            return new PausableDefinition();
        }

        @Override
        protected boolean setProperty(PausableDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "consumer-listener": {
                    String val = asText(node);
                    target.setConsumerListener(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "until-check": {
                    String val = asText(node);
                    target.setUntilCheck(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "pipeline",
            types = org.apache.camel.model.PipelineDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Pipeline",
            description = "Routes the message to a sequence of processors.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class PipelineDefinitionDeserializer extends YamlDeserializerBase<PipelineDefinition> {
        public PipelineDefinitionDeserializer() {
            super(PipelineDefinition.class);
        }

        @Override
        protected PipelineDefinition newInstance() {
            return new PipelineDefinition();
        }

        @Override
        protected boolean setProperty(PipelineDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "policy",
            types = org.apache.camel.model.PolicyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Policy",
            description = "Defines a policy the route will use",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "ref", type = "string", required = true, description = "Sets a reference to use for lookup the policy in the registry.", displayName = "Ref"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class PolicyDefinitionDeserializer extends YamlDeserializerBase<PolicyDefinition> {
        public PolicyDefinitionDeserializer() {
            super(PolicyDefinition.class);
        }

        @Override
        protected PolicyDefinition newInstance() {
            return new PolicyDefinition();
        }

        @Override
        protected boolean setProperty(PolicyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "poll-enrich",
                    "pollEnrich"
            },
            types = org.apache.camel.model.PollEnrichDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Poll Enrich",
            description = "Enriches messages with data polled from a secondary resource",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "aggregate-on-exception", type = "boolean", description = "If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.", displayName = "Aggregate On Exception"),
                    @YamlProperty(name = "aggregation-strategy", type = "string", description = "Sets the AggregationStrategy to be used to merge the reply from the external service, into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.", displayName = "Aggregation Strategy"),
                    @YamlProperty(name = "aggregation-strategy-method-allow-null", type = "string", description = "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Allow Null"),
                    @YamlProperty(name = "aggregation-strategy-method-name", type = "string", description = "This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Name"),
                    @YamlProperty(name = "cache-size", type = "number", description = "Sets the maximum size used by the org.apache.camel.spi.ConsumerCache which is used to cache and reuse consumers when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.", displayName = "Cache Size"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression that computes the endpoint uri to use as the resource endpoint to enrich from", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-endpoint", type = "boolean", description = "Ignore the invalidate endpoint exception when try to create a producer with that endpoint", displayName = "Ignore Invalid Endpoint"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "timeout", type = "string", defaultValue = "-1", description = "Timeout in millis when polling from the external service. The timeout has influence about the poll enrich behavior. It basically operations in three different modes: negative value - Waits until a message is available and then returns it. Warning that this method could block indefinitely if no messages are available. 0 - Attempts to receive a message exchange immediately without waiting and returning null if a message exchange is not available yet. positive value - Attempts to receive a message exchange, waiting up to the given timeout to expire if a message is not yet available. Returns null if timed out The default value is -1 and therefore the method could block indefinitely, and therefore its recommended to use a timeout value", displayName = "Timeout")
            }
    )
    public static class PollEnrichDefinitionDeserializer extends YamlDeserializerBase<PollEnrichDefinition> {
        public PollEnrichDefinitionDeserializer() {
            super(PollEnrichDefinition.class);
        }

        @Override
        protected PollEnrichDefinition newInstance() {
            return new PollEnrichDefinition();
        }

        @Override
        protected boolean setProperty(PollEnrichDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "aggregate-on-exception": {
                    String val = asText(node);
                    target.setAggregateOnException(val);
                    break;
                }
                case "aggregation-strategy": {
                    String val = asText(node);
                    target.setAggregationStrategy(val);
                    break;
                }
                case "aggregation-strategy-method-allow-null": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodAllowNull(val);
                    break;
                }
                case "aggregation-strategy-method-name": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodName(val);
                    break;
                }
                case "cache-size": {
                    String val = asText(node);
                    target.setCacheSize(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "ignore-invalid-endpoint": {
                    String val = asText(node);
                    target.setIgnoreInvalidEndpoint(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "timeout": {
                    String val = asText(node);
                    target.setTimeout(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "post",
            types = org.apache.camel.model.rest.PostDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Post",
            description = "Rest POST command",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-docs", type = "boolean", description = "Whether to include or exclude this rest operation in API documentation. The default value is true.", displayName = "Api Docs"),
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json. This option will override what may be configured on a parent level", displayName = "Consumes"),
                    @YamlProperty(name = "deprecated", type = "boolean", description = "Marks this rest operation as deprecated in OpenApi documentation.", displayName = "Deprecated"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this REST service from the route during build time. Once an REST service has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "out-type", type = "string", description = "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Out Type"),
                    @YamlProperty(name = "param", type = "array:org.apache.camel.model.rest.ParamDefinition"),
                    @YamlProperty(name = "path", type = "string", description = "The path mapping URIs of this REST operation such as /{id}.", displayName = "Path"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json This option will override what may be configured on a parent level", displayName = "Produces"),
                    @YamlProperty(name = "response-message", type = "array:org.apache.camel.model.rest.ResponseMessageDefinition"),
                    @YamlProperty(name = "route-id", type = "string", description = "Sets the id of the route", displayName = "Route Id"),
                    @YamlProperty(name = "security", type = "array:org.apache.camel.model.rest.SecurityDefinition"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do. This option will override what may be configured on a parent level", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "to", type = "object:org.apache.camel.model.ToDefinition", description = "The Camel endpoint this REST service will call, such as a direct endpoint to link to an existing route that handles this REST call.", displayName = "To"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level. The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Type")
            }
    )
    public static class PostDefinitionDeserializer extends YamlDeserializerBase<PostDefinition> {
        public PostDefinitionDeserializer() {
            super(PostDefinition.class);
        }

        @Override
        protected PostDefinition newInstance() {
            return new PostDefinition();
        }

        @Override
        protected boolean setProperty(PostDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "api-docs": {
                    String val = asText(node);
                    target.setApiDocs(val);
                    break;
                }
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "deprecated": {
                    String val = asText(node);
                    target.setDeprecated(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "out-type": {
                    String val = asText(node);
                    target.setOutType(val);
                    break;
                }
                case "param": {
                    java.util.List<org.apache.camel.model.rest.ParamDefinition> val = asFlatList(node, org.apache.camel.model.rest.ParamDefinition.class);
                    target.setParams(val);
                    break;
                }
                case "path": {
                    String val = asText(node);
                    target.setPath(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "response-message": {
                    java.util.List<org.apache.camel.model.rest.ResponseMessageDefinition> val = asFlatList(node, org.apache.camel.model.rest.ResponseMessageDefinition.class);
                    target.setResponseMsgs(val);
                    break;
                }
                case "route-id": {
                    String val = asText(node);
                    target.setRouteId(val);
                    break;
                }
                case "security": {
                    java.util.List<org.apache.camel.model.rest.SecurityDefinition> val = asFlatList(node, org.apache.camel.model.rest.SecurityDefinition.class);
                    target.setSecurity(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "to": {
                    org.apache.camel.model.ToDefinition val = asType(node, org.apache.camel.model.ToDefinition.class);
                    target.setTo(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.validator.PredicateValidatorDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "type", type = "string")
            }
    )
    public static class PredicateValidatorDefinitionDeserializer extends YamlDeserializerBase<PredicateValidatorDefinition> {
        public PredicateValidatorDefinitionDeserializer() {
            super(PredicateValidatorDefinition.class);
        }

        @Override
        protected PredicateValidatorDefinition newInstance() {
            return new PredicateValidatorDefinition();
        }

        @Override
        protected boolean setProperty(PredicateValidatorDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "process",
            types = org.apache.camel.model.ProcessDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Process",
            description = "Calls a Camel processor",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "ref", type = "string", required = true, description = "Reference to the Processor to lookup in the registry to use. Can also be used for creating new beans by their class name by prefixing with #class, eg #class:com.foo.MyClassType. And it is also possible to refer to singleton beans by their type in the registry by prefixing with #type: syntax, eg #type:com.foo.MyClassType", displayName = "Ref")
            }
    )
    public static class ProcessDefinitionDeserializer extends YamlDeserializerBase<ProcessDefinition> {
        public ProcessDefinitionDeserializer() {
            super(ProcessDefinition.class);
        }

        @Override
        protected ProcessDefinition newInstance() {
            return new ProcessDefinition();
        }

        @Override
        protected boolean setProperty(ProcessDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "property",
            types = org.apache.camel.model.PropertyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Property",
            description = "A key value pair where the value is a literal value",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "key", type = "string", required = true, description = "Property key", displayName = "Key"),
                    @YamlProperty(name = "value", type = "string", required = true, description = "Property value", displayName = "Value")
            }
    )
    public static class PropertyDefinitionDeserializer extends YamlDeserializerBase<PropertyDefinition> {
        public PropertyDefinitionDeserializer() {
            super(PropertyDefinition.class);
        }

        @Override
        protected PropertyDefinition newInstance() {
            return new PropertyDefinition();
        }

        @Override
        protected boolean setProperty(PropertyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "property-expression",
                    "propertyExpression"
            },
            types = org.apache.camel.model.PropertyExpressionDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Property Expression",
            description = "A key value pair where the value is an expression.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Property values as an expression", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "key", type = "string", required = true, description = "Property key", displayName = "Key")
            }
    )
    public static class PropertyExpressionDefinitionDeserializer extends YamlDeserializerBase<PropertyExpressionDefinition> {
        public PropertyExpressionDefinitionDeserializer() {
            super(PropertyExpressionDefinition.class);
        }

        @Override
        protected PropertyExpressionDefinition newInstance() {
            return new PropertyExpressionDefinition();
        }

        @Override
        protected boolean setProperty(PropertyExpressionDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "protobuf",
            inline = true,
            types = org.apache.camel.model.dataformat.ProtobufDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Protobuf",
            description = "Serialize and deserialize Java objects using Google's Protocol buffers.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-jms-type", type = "boolean", description = "Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.", displayName = "Allow Jms Type"),
                    @YamlProperty(name = "allow-unmarshall-type", type = "boolean", description = "If enabled then Jackson is allowed to attempt to use the CamelJacksonUnmarshalType header during the unmarshalling. This should only be enabled when desired to be used.", displayName = "Allow Unmarshall Type"),
                    @YamlProperty(name = "auto-discover-object-mapper", type = "boolean", description = "If set to true then Jackson will lookup for an objectMapper into the registry", displayName = "Auto Discover Object Mapper"),
                    @YamlProperty(name = "auto-discover-schema-resolver", type = "boolean", description = "When not disabled, the SchemaResolver will be looked up into the registry", displayName = "Auto Discover Schema Resolver"),
                    @YamlProperty(name = "collection-type", type = "string", description = "Refers to a custom collection type to lookup in the registry to use. This option should rarely be used, but allows to use different collection types than java.util.Collection based as default.", displayName = "Collection Type"),
                    @YamlProperty(name = "content-type-format", type = "enum:native,json", defaultValue = "native", description = "Defines a content type format in which protobuf message will be serialized/deserialized from(to) the Java been. The format can either be native or json for either native protobuf or json fields representation. The default value is native.", displayName = "Content Type Format"),
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "disable-features", type = "string", description = "Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Disable Features"),
                    @YamlProperty(name = "enable-features", type = "string", description = "Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature, com.fasterxml.jackson.databind.DeserializationFeature, or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma", displayName = "Enable Features"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "include", type = "string", description = "If you want to marshal a pojo to JSON, and the pojo has some fields with null values. And you want to skip these null values, you can set this option to NON_NULL", displayName = "Include"),
                    @YamlProperty(name = "instance-class", type = "string", description = "Name of class to use when unmarshalling", displayName = "Instance Class"),
                    @YamlProperty(name = "json-view", type = "string", description = "When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations", displayName = "Json View"),
                    @YamlProperty(name = "library", type = "enum:GoogleProtobuf,Jackson", defaultValue = "GoogleProtobuf", description = "Which Protobuf library to use.", displayName = "Library"),
                    @YamlProperty(name = "module-class-names", type = "string", description = "To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.", displayName = "Module Class Names"),
                    @YamlProperty(name = "module-refs", type = "string", description = "To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.", displayName = "Module Refs"),
                    @YamlProperty(name = "object-mapper", type = "string", description = "Lookup and use the existing ObjectMapper with the given id when using Jackson.", displayName = "Object Mapper"),
                    @YamlProperty(name = "schema-resolver", type = "string", description = "Optional schema resolver used to lookup schemas for the data in transit.", displayName = "Schema Resolver"),
                    @YamlProperty(name = "timezone", type = "string", description = "If set then Jackson will use the Timezone when marshalling/unmarshalling.", displayName = "Timezone"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class name of the java type to use when unmarshalling", displayName = "Unmarshal Type"),
                    @YamlProperty(name = "use-default-object-mapper", type = "boolean", description = "Whether to lookup and use default Jackson ObjectMapper from the registry.", displayName = "Use Default Object Mapper"),
                    @YamlProperty(name = "use-list", type = "boolean", description = "To unmarshal to a List of Map or a List of Pojo.", displayName = "Use List")
            }
    )
    public static class ProtobufDataFormatDeserializer extends YamlDeserializerBase<ProtobufDataFormat> {
        public ProtobufDataFormatDeserializer() {
            super(ProtobufDataFormat.class);
        }

        @Override
        protected ProtobufDataFormat newInstance() {
            return new ProtobufDataFormat();
        }

        @Override
        protected ProtobufDataFormat newInstance(String value) {
            return new ProtobufDataFormat(value);
        }

        @Override
        protected boolean setProperty(ProtobufDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-jms-type": {
                    String val = asText(node);
                    target.setAllowJmsType(val);
                    break;
                }
                case "allow-unmarshall-type": {
                    String val = asText(node);
                    target.setAllowUnmarshallType(val);
                    break;
                }
                case "auto-discover-object-mapper": {
                    String val = asText(node);
                    target.setAutoDiscoverObjectMapper(val);
                    break;
                }
                case "auto-discover-schema-resolver": {
                    String val = asText(node);
                    target.setAutoDiscoverSchemaResolver(val);
                    break;
                }
                case "collection-type": {
                    String val = asText(node);
                    target.setCollectionTypeName(val);
                    break;
                }
                case "content-type-format": {
                    String val = asText(node);
                    target.setContentTypeFormat(val);
                    break;
                }
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "disable-features": {
                    String val = asText(node);
                    target.setDisableFeatures(val);
                    break;
                }
                case "enable-features": {
                    String val = asText(node);
                    target.setEnableFeatures(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "include": {
                    String val = asText(node);
                    target.setInclude(val);
                    break;
                }
                case "instance-class": {
                    String val = asText(node);
                    target.setInstanceClass(val);
                    break;
                }
                case "json-view": {
                    String val = asText(node);
                    target.setJsonViewTypeName(val);
                    break;
                }
                case "library": {
                    target.setLibrary(asEnum(node, org.apache.camel.model.dataformat.ProtobufLibrary.class));
                    break;
                }
                case "module-class-names": {
                    String val = asText(node);
                    target.setModuleClassNames(val);
                    break;
                }
                case "module-refs": {
                    String val = asText(node);
                    target.setModuleRefs(val);
                    break;
                }
                case "object-mapper": {
                    String val = asText(node);
                    target.setObjectMapper(val);
                    break;
                }
                case "schema-resolver": {
                    String val = asText(node);
                    target.setSchemaResolver(val);
                    break;
                }
                case "timezone": {
                    String val = asText(node);
                    target.setTimezone(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                case "use-default-object-mapper": {
                    String val = asText(node);
                    target.setUseDefaultObjectMapper(val);
                    break;
                }
                case "use-list": {
                    String val = asText(node);
                    target.setUseList(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "put",
            types = org.apache.camel.model.rest.PutDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Put",
            description = "Rest PUT command",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-docs", type = "boolean", description = "Whether to include or exclude this rest operation in API documentation. The default value is true.", displayName = "Api Docs"),
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json. This option will override what may be configured on a parent level", displayName = "Consumes"),
                    @YamlProperty(name = "deprecated", type = "boolean", description = "Marks this rest operation as deprecated in OpenApi documentation.", displayName = "Deprecated"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this REST service from the route during build time. Once an REST service has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "out-type", type = "string", description = "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Out Type"),
                    @YamlProperty(name = "param", type = "array:org.apache.camel.model.rest.ParamDefinition"),
                    @YamlProperty(name = "path", type = "string", description = "The path mapping URIs of this REST operation such as /{id}.", displayName = "Path"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json This option will override what may be configured on a parent level", displayName = "Produces"),
                    @YamlProperty(name = "response-message", type = "array:org.apache.camel.model.rest.ResponseMessageDefinition"),
                    @YamlProperty(name = "route-id", type = "string", description = "Sets the id of the route", displayName = "Route Id"),
                    @YamlProperty(name = "security", type = "array:org.apache.camel.model.rest.SecurityDefinition"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do. This option will override what may be configured on a parent level", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "to", type = "object:org.apache.camel.model.ToDefinition", description = "The Camel endpoint this REST service will call, such as a direct endpoint to link to an existing route that handles this REST call.", displayName = "To"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level. The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Type")
            }
    )
    public static class PutDefinitionDeserializer extends YamlDeserializerBase<PutDefinition> {
        public PutDefinitionDeserializer() {
            super(PutDefinition.class);
        }

        @Override
        protected PutDefinition newInstance() {
            return new PutDefinition();
        }

        @Override
        protected boolean setProperty(PutDefinition target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "api-docs": {
                    String val = asText(node);
                    target.setApiDocs(val);
                    break;
                }
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "deprecated": {
                    String val = asText(node);
                    target.setDeprecated(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "out-type": {
                    String val = asText(node);
                    target.setOutType(val);
                    break;
                }
                case "param": {
                    java.util.List<org.apache.camel.model.rest.ParamDefinition> val = asFlatList(node, org.apache.camel.model.rest.ParamDefinition.class);
                    target.setParams(val);
                    break;
                }
                case "path": {
                    String val = asText(node);
                    target.setPath(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "response-message": {
                    java.util.List<org.apache.camel.model.rest.ResponseMessageDefinition> val = asFlatList(node, org.apache.camel.model.rest.ResponseMessageDefinition.class);
                    target.setResponseMsgs(val);
                    break;
                }
                case "route-id": {
                    String val = asText(node);
                    target.setRouteId(val);
                    break;
                }
                case "security": {
                    java.util.List<org.apache.camel.model.rest.SecurityDefinition> val = asFlatList(node, org.apache.camel.model.rest.SecurityDefinition.class);
                    target.setSecurity(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "to": {
                    org.apache.camel.model.ToDefinition val = asType(node, org.apache.camel.model.ToDefinition.class);
                    target.setTo(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "python",
            inline = true,
            types = org.apache.camel.model.language.PythonExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Python",
            description = "Evaluates a Python expression.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class PythonExpressionDeserializer extends YamlDeserializerBase<PythonExpression> {
        public PythonExpressionDeserializer() {
            super(PythonExpression.class);
        }

        @Override
        protected PythonExpression newInstance() {
            return new PythonExpression();
        }

        @Override
        protected PythonExpression newInstance(String value) {
            return new PythonExpression(value);
        }

        @Override
        protected boolean setProperty(PythonExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "random",
            types = org.apache.camel.model.loadbalancer.RandomLoadBalancerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Random",
            description = "The destination endpoints are selected by random.",
            deprecated = false,
            properties = @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
    )
    public static class RandomLoadBalancerDefinitionDeserializer extends YamlDeserializerBase<RandomLoadBalancerDefinition> {
        public RandomLoadBalancerDefinitionDeserializer() {
            super(RandomLoadBalancerDefinition.class);
        }

        @Override
        protected RandomLoadBalancerDefinition newInstance() {
            return new RandomLoadBalancerDefinition();
        }

        @Override
        protected boolean setProperty(RandomLoadBalancerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "recipient-list",
                    "recipientList"
            },
            types = org.apache.camel.model.RecipientListDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Recipient List",
            description = "Route messages to a number of dynamically specified recipients",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "aggregation-strategy", type = "string", description = "Sets the AggregationStrategy to be used to assemble the replies from the recipients, into a single outgoing message from the RecipientList. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy", displayName = "Aggregation Strategy"),
                    @YamlProperty(name = "aggregation-strategy-method-allow-null", type = "boolean", description = "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy", displayName = "Aggregation Strategy Method Allow Null"),
                    @YamlProperty(name = "aggregation-strategy-method-name", type = "string", description = "This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Name"),
                    @YamlProperty(name = "cache-size", type = "number", description = "Sets the maximum size used by the org.apache.camel.spi.ProducerCache which is used to cache and reuse producers when using this recipient list, when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.", displayName = "Cache Size"),
                    @YamlProperty(name = "delimiter", type = "string", defaultValue = ",", description = "Delimiter used if the Expression returned multiple endpoints. Can be turned off using the value false. The default value is ,", displayName = "Delimiter"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "executor-service", type = "string", description = "To use a custom Thread Pool to be used for parallel processing. Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.", displayName = "Executor Service"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression that returns which endpoints (url) to send the message to (the recipients). If the expression return an empty value then the message is not sent to any recipients.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-endpoints", type = "boolean", description = "Ignore the invalidate endpoint exception when try to create a producer with that endpoint", displayName = "Ignore Invalid Endpoints"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "on-prepare", type = "string", description = "Uses the Processor when preparing the org.apache.camel.Exchange to be used send. This can be used to deep-clone messages that should be send, or any custom logic needed before the exchange is send.", displayName = "On Prepare"),
                    @YamlProperty(name = "parallel-aggregate", type = "boolean", description = "If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.", displayName = "Parallel Aggregate"),
                    @YamlProperty(name = "parallel-processing", type = "boolean", description = "If enabled then sending messages to the recipients occurs concurrently. Note the caller thread will still wait until all messages has been fully processed, before it continues. Its only the sending and processing the replies from the recipients which happens concurrently. When parallel processing is enabled, then the Camel routing engin will continue processing using last used thread from the parallel thread pool. However, if you want to use the original thread that called the recipient list, then make sure to enable the synchronous option as well.", displayName = "Parallel Processing"),
                    @YamlProperty(name = "share-unit-of-work", type = "boolean", description = "Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Recipient List will by default not share unit of work between the parent exchange and each recipient exchange. This means each sub exchange has its own individual unit of work.", displayName = "Share Unit Of Work"),
                    @YamlProperty(name = "stop-on-exception", type = "boolean", description = "Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the recipient list will stop further processing. This is the same behavior as in pipeline, which is used by the routing engine. The default behavior is to not stop but continue processing till the end", displayName = "Stop On Exception"),
                    @YamlProperty(name = "streaming", type = "boolean", description = "If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as defined by the recipient list.", displayName = "Streaming"),
                    @YamlProperty(name = "synchronous", type = "boolean", description = "Sets whether synchronous processing should be strictly used. When enabled then the same thread is used to continue routing after the recipient list is complete, even if parallel processing is enabled.", displayName = "Synchronous"),
                    @YamlProperty(name = "timeout", type = "string", defaultValue = "0", description = "Sets a total timeout specified in millis, when using parallel processing. If the Recipient List hasn't been able to send and process all replies within the given timeframe, then the timeout triggers and the Recipient List breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.", displayName = "Timeout")
            }
    )
    public static class RecipientListDefinitionDeserializer extends YamlDeserializerBase<RecipientListDefinition> {
        public RecipientListDefinitionDeserializer() {
            super(RecipientListDefinition.class);
        }

        @Override
        protected RecipientListDefinition newInstance() {
            return new RecipientListDefinition();
        }

        @Override
        protected boolean setProperty(RecipientListDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "aggregation-strategy": {
                    String val = asText(node);
                    target.setAggregationStrategy(val);
                    break;
                }
                case "aggregation-strategy-method-allow-null": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodAllowNull(val);
                    break;
                }
                case "aggregation-strategy-method-name": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodName(val);
                    break;
                }
                case "cache-size": {
                    String val = asText(node);
                    target.setCacheSize(val);
                    break;
                }
                case "delimiter": {
                    String val = asText(node);
                    target.setDelimiter(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "ignore-invalid-endpoints": {
                    String val = asText(node);
                    target.setIgnoreInvalidEndpoints(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "on-prepare": {
                    String val = asText(node);
                    target.setOnPrepare(val);
                    break;
                }
                case "parallel-aggregate": {
                    String val = asText(node);
                    target.setParallelAggregate(val);
                    break;
                }
                case "parallel-processing": {
                    String val = asText(node);
                    target.setParallelProcessing(val);
                    break;
                }
                case "share-unit-of-work": {
                    String val = asText(node);
                    target.setShareUnitOfWork(val);
                    break;
                }
                case "stop-on-exception": {
                    String val = asText(node);
                    target.setStopOnException(val);
                    break;
                }
                case "streaming": {
                    String val = asText(node);
                    target.setStreaming(val);
                    break;
                }
                case "synchronous": {
                    String val = asText(node);
                    target.setSynchronous(val);
                    break;
                }
                case "timeout": {
                    String val = asText(node);
                    target.setTimeout(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "redelivery-policy",
                    "redeliveryPolicy"
            },
            types = org.apache.camel.model.RedeliveryPolicyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Redelivery Policy",
            description = "To configure re-delivery for error handling",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-redelivery-while-stopping", type = "boolean", description = "Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.", displayName = "Allow Redelivery While Stopping"),
                    @YamlProperty(name = "async-delayed-redelivery", type = "boolean", description = "Allow asynchronous delayed redelivery. The route, in particular the consumer's component, must support the Asynchronous Routing Engine (e.g. seda).", displayName = "Async Delayed Redelivery"),
                    @YamlProperty(name = "back-off-multiplier", type = "number", defaultValue = "2.0", description = "Sets the back off multiplier", displayName = "Back Off Multiplier"),
                    @YamlProperty(name = "collision-avoidance-factor", type = "number", defaultValue = "0.15", description = "Sets the collision avoidance factor", displayName = "Collision Avoidance Factor"),
                    @YamlProperty(name = "delay-pattern", type = "string", description = "Sets the delay pattern with delay intervals.", displayName = "Delay Pattern"),
                    @YamlProperty(name = "disable-redelivery", type = "boolean", description = "Disables redelivery (same as setting maximum redeliveries to 0)", displayName = "Disable Redelivery"),
                    @YamlProperty(name = "exchange-formatter-ref", type = "string", description = "Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to generate the log message from exchange.", displayName = "Exchange Formatter Ref"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "log-continued", type = "boolean", description = "Sets whether continued exceptions should be logged or not. Can be used to include or reduce verbose.", displayName = "Log Continued"),
                    @YamlProperty(name = "log-exhausted", type = "boolean", description = "Sets whether exhausted exceptions should be logged or not. Can be used to include or reduce verbose.", displayName = "Log Exhausted"),
                    @YamlProperty(name = "log-exhausted-message-body", type = "boolean", description = "Sets whether exhausted message body should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose. Requires logExhaustedMessageHistory to be enabled.", displayName = "Log Exhausted Message Body"),
                    @YamlProperty(name = "log-exhausted-message-history", type = "boolean", description = "Sets whether exhausted exceptions should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose.", displayName = "Log Exhausted Message History"),
                    @YamlProperty(name = "log-handled", type = "boolean", description = "Sets whether handled exceptions should be logged or not. Can be used to include or reduce verbose.", displayName = "Log Handled"),
                    @YamlProperty(name = "log-new-exception", type = "boolean", description = "Sets whether new exceptions should be logged or not. Can be used to include or reduce verbose. A new exception is an exception that was thrown while handling a previous exception.", displayName = "Log New Exception"),
                    @YamlProperty(name = "log-retry-attempted", type = "boolean", description = "Sets whether retry attempts should be logged or not. Can be used to include or reduce verbose.", displayName = "Log Retry Attempted"),
                    @YamlProperty(name = "log-retry-stack-trace", type = "boolean", description = "Sets whether stack traces should be logged when an retry attempt failed. Can be used to include or reduce verbose.", displayName = "Log Retry Stack Trace"),
                    @YamlProperty(name = "log-stack-trace", type = "boolean", description = "Sets whether stack traces should be logged. Can be used to include or reduce verbose.", displayName = "Log Stack Trace"),
                    @YamlProperty(name = "maximum-redeliveries", type = "number", description = "Sets the maximum redeliveries x = redeliver at most x times 0 = no redeliveries -1 = redeliver forever", displayName = "Maximum Redeliveries"),
                    @YamlProperty(name = "maximum-redelivery-delay", type = "string", defaultValue = "60000", description = "Sets the maximum delay between redelivery", displayName = "Maximum Redelivery Delay"),
                    @YamlProperty(name = "redelivery-delay", type = "string", defaultValue = "1000", description = "Sets the initial redelivery delay", displayName = "Redelivery Delay"),
                    @YamlProperty(name = "retries-exhausted-log-level", type = "string", defaultValue = "ERROR", description = "Sets the logging level to use when retries have been exhausted", displayName = "Retries Exhausted Log Level"),
                    @YamlProperty(name = "retry-attempted-log-interval", type = "number", defaultValue = "1", description = "Sets the interval to use for logging retry attempts", displayName = "Retry Attempted Log Interval"),
                    @YamlProperty(name = "retry-attempted-log-level", type = "string", defaultValue = "DEBUG", description = "Sets the logging level to use for logging retry attempts", displayName = "Retry Attempted Log Level"),
                    @YamlProperty(name = "use-collision-avoidance", type = "boolean", description = "Turn on collision avoidance.", displayName = "Use Collision Avoidance"),
                    @YamlProperty(name = "use-exponential-back-off", type = "boolean", description = "Turn on exponential backk off", displayName = "Use Exponential Back Off")
            }
    )
    public static class RedeliveryPolicyDefinitionDeserializer extends YamlDeserializerBase<RedeliveryPolicyDefinition> {
        public RedeliveryPolicyDefinitionDeserializer() {
            super(RedeliveryPolicyDefinition.class);
        }

        @Override
        protected RedeliveryPolicyDefinition newInstance() {
            return new RedeliveryPolicyDefinition();
        }

        @Override
        protected boolean setProperty(RedeliveryPolicyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-redelivery-while-stopping": {
                    String val = asText(node);
                    target.setAllowRedeliveryWhileStopping(val);
                    break;
                }
                case "async-delayed-redelivery": {
                    String val = asText(node);
                    target.setAsyncDelayedRedelivery(val);
                    break;
                }
                case "back-off-multiplier": {
                    String val = asText(node);
                    target.setBackOffMultiplier(val);
                    break;
                }
                case "collision-avoidance-factor": {
                    String val = asText(node);
                    target.setCollisionAvoidanceFactor(val);
                    break;
                }
                case "delay-pattern": {
                    String val = asText(node);
                    target.setDelayPattern(val);
                    break;
                }
                case "disable-redelivery": {
                    String val = asText(node);
                    target.setDisableRedelivery(val);
                    break;
                }
                case "exchange-formatter-ref": {
                    String val = asText(node);
                    target.setExchangeFormatterRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "log-continued": {
                    String val = asText(node);
                    target.setLogContinued(val);
                    break;
                }
                case "log-exhausted": {
                    String val = asText(node);
                    target.setLogExhausted(val);
                    break;
                }
                case "log-exhausted-message-body": {
                    String val = asText(node);
                    target.setLogExhaustedMessageBody(val);
                    break;
                }
                case "log-exhausted-message-history": {
                    String val = asText(node);
                    target.setLogExhaustedMessageHistory(val);
                    break;
                }
                case "log-handled": {
                    String val = asText(node);
                    target.setLogHandled(val);
                    break;
                }
                case "log-new-exception": {
                    String val = asText(node);
                    target.setLogNewException(val);
                    break;
                }
                case "log-retry-attempted": {
                    String val = asText(node);
                    target.setLogRetryAttempted(val);
                    break;
                }
                case "log-retry-stack-trace": {
                    String val = asText(node);
                    target.setLogRetryStackTrace(val);
                    break;
                }
                case "log-stack-trace": {
                    String val = asText(node);
                    target.setLogStackTrace(val);
                    break;
                }
                case "maximum-redeliveries": {
                    String val = asText(node);
                    target.setMaximumRedeliveries(val);
                    break;
                }
                case "maximum-redelivery-delay": {
                    String val = asText(node);
                    target.setMaximumRedeliveryDelay(val);
                    break;
                }
                case "redelivery-delay": {
                    String val = asText(node);
                    target.setRedeliveryDelay(val);
                    break;
                }
                case "retries-exhausted-log-level": {
                    String val = asText(node);
                    target.setRetriesExhaustedLogLevel(val);
                    break;
                }
                case "retry-attempted-log-interval": {
                    String val = asText(node);
                    target.setRetryAttemptedLogInterval(val);
                    break;
                }
                case "retry-attempted-log-level": {
                    String val = asText(node);
                    target.setRetryAttemptedLogLevel(val);
                    break;
                }
                case "use-collision-avoidance": {
                    String val = asText(node);
                    target.setUseCollisionAvoidance(val);
                    break;
                }
                case "use-exponential-back-off": {
                    String val = asText(node);
                    target.setUseExponentialBackOff(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "ref-error-handler",
                    "refErrorHandler"
            },
            inline = true,
            types = org.apache.camel.model.errorhandler.RefErrorHandlerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Ref Error Handler",
            description = "References to an existing or custom error handler.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ref", type = "string", required = true, description = "References to an existing or custom error handler.", displayName = "Ref")
            }
    )
    public static class RefErrorHandlerDefinitionDeserializer extends YamlDeserializerBase<RefErrorHandlerDefinition> {
        public RefErrorHandlerDefinitionDeserializer() {
            super(RefErrorHandlerDefinition.class);
        }

        @Override
        protected RefErrorHandlerDefinition newInstance() {
            return new RefErrorHandlerDefinition();
        }

        @Override
        protected RefErrorHandlerDefinition newInstance(String value) {
            return new RefErrorHandlerDefinition(value);
        }

        @Override
        protected boolean setProperty(RefErrorHandlerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "ref",
            inline = true,
            types = org.apache.camel.model.language.RefExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Ref",
            description = "Uses an existing expression from the registry.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class RefExpressionDeserializer extends YamlDeserializerBase<RefExpression> {
        public RefExpressionDeserializer() {
            super(RefExpression.class);
        }

        @Override
        protected RefExpression newInstance() {
            return new RefExpression();
        }

        @Override
        protected RefExpression newInstance(String value) {
            return new RefExpression(value);
        }

        @Override
        protected boolean setProperty(RefExpression target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            types = org.apache.camel.model.app.RegistryBeanDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "constructors", type = "object"),
                    @YamlProperty(name = "destroy-method", type = "string"),
                    @YamlProperty(name = "factory-bean", type = "string"),
                    @YamlProperty(name = "factory-method", type = "string"),
                    @YamlProperty(name = "init-method", type = "string"),
                    @YamlProperty(name = "name", type = "string", required = true),
                    @YamlProperty(name = "properties", type = "object"),
                    @YamlProperty(name = "type", type = "string", required = true)
            }
    )
    public static class RegistryBeanDefinitionDeserializer extends YamlDeserializerBase<RegistryBeanDefinition> {
        public RegistryBeanDefinitionDeserializer() {
            super(RegistryBeanDefinition.class);
        }

        @Override
        protected RegistryBeanDefinition newInstance() {
            return new RegistryBeanDefinition();
        }

        @Override
        protected boolean setProperty(RegistryBeanDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "constructors": {
                    java.util.Map val = asMap(node);
                    target.setConstructors(val);
                    break;
                }
                case "destroy-method": {
                    String val = asText(node);
                    target.setDestroyMethod(val);
                    break;
                }
                case "factory-bean": {
                    String val = asText(node);
                    target.setFactoryBean(val);
                    break;
                }
                case "factory-method": {
                    String val = asText(node);
                    target.setFactoryMethod(val);
                    break;
                }
                case "init-method": {
                    String val = asText(node);
                    target.setInitMethod(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "properties": {
                    java.util.Map val = asMap(node);
                    target.setProperties(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "remove-header",
                    "removeHeader"
            },
            inline = true,
            types = org.apache.camel.model.RemoveHeaderDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Remove Header",
            description = "Removes a named header from the message",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "Name of header to remove", displayName = "Name")
            }
    )
    public static class RemoveHeaderDefinitionDeserializer extends YamlDeserializerBase<RemoveHeaderDefinition> {
        public RemoveHeaderDefinitionDeserializer() {
            super(RemoveHeaderDefinition.class);
        }

        @Override
        protected RemoveHeaderDefinition newInstance() {
            return new RemoveHeaderDefinition();
        }

        @Override
        protected RemoveHeaderDefinition newInstance(String value) {
            return new RemoveHeaderDefinition(value);
        }

        @Override
        protected boolean setProperty(RemoveHeaderDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "remove-headers",
                    "removeHeaders"
            },
            inline = true,
            types = org.apache.camel.model.RemoveHeadersDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Remove Headers",
            description = "Removes message headers whose name matches a specified pattern",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "exclude-pattern", type = "string", description = "Name or patter of headers to not remove. The pattern is matched in the following order: 1 = exact match 2 = wildcard (pattern ends with a and the name starts with the pattern) 3 = regular expression (all of above is case in-sensitive).", displayName = "Exclude Pattern"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "pattern", type = "string", required = true, description = "Name or pattern of headers to remove. The pattern is matched in the following order: 1 = exact match 2 = wildcard (pattern ends with a and the name starts with the pattern) 3 = regular expression (all of above is case in-sensitive).", displayName = "Pattern")
            }
    )
    public static class RemoveHeadersDefinitionDeserializer extends YamlDeserializerBase<RemoveHeadersDefinition> {
        public RemoveHeadersDefinitionDeserializer() {
            super(RemoveHeadersDefinition.class);
        }

        @Override
        protected RemoveHeadersDefinition newInstance() {
            return new RemoveHeadersDefinition();
        }

        @Override
        protected RemoveHeadersDefinition newInstance(String value) {
            return new RemoveHeadersDefinition(value);
        }

        @Override
        protected boolean setProperty(RemoveHeadersDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "exclude-pattern": {
                    String val = asText(node);
                    target.setExcludePattern(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "remove-properties",
                    "removeProperties"
            },
            inline = true,
            types = org.apache.camel.model.RemovePropertiesDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Remove Properties",
            description = "Removes message exchange properties whose name matches a specified pattern",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "exclude-pattern", type = "string", description = "Name or pattern of properties to not remove. The pattern is matched in the following order: 1 = exact match 2 = wildcard (pattern ends with a and the name starts with the pattern) 3 = regular expression (all of above is case in-sensitive).", displayName = "Exclude Pattern"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "pattern", type = "string", required = true, description = "Name or pattern of properties to remove. The pattern is matched in the following order: 1 = exact match 2 = wildcard (pattern ends with a and the name starts with the pattern) 3 = regular expression (all of above is case in-sensitive).", displayName = "Pattern")
            }
    )
    public static class RemovePropertiesDefinitionDeserializer extends YamlDeserializerBase<RemovePropertiesDefinition> {
        public RemovePropertiesDefinitionDeserializer() {
            super(RemovePropertiesDefinition.class);
        }

        @Override
        protected RemovePropertiesDefinition newInstance() {
            return new RemovePropertiesDefinition();
        }

        @Override
        protected RemovePropertiesDefinition newInstance(String value) {
            return new RemovePropertiesDefinition(value);
        }

        @Override
        protected boolean setProperty(RemovePropertiesDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "exclude-pattern": {
                    String val = asText(node);
                    target.setExcludePattern(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "remove-property",
                    "removeProperty"
            },
            inline = true,
            types = org.apache.camel.model.RemovePropertyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Remove Property",
            description = "Removes a named property from the message exchange",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "Name of property to remove.", displayName = "Name")
            }
    )
    public static class RemovePropertyDefinitionDeserializer extends YamlDeserializerBase<RemovePropertyDefinition> {
        public RemovePropertyDefinitionDeserializer() {
            super(RemovePropertyDefinition.class);
        }

        @Override
        protected RemovePropertyDefinition newInstance() {
            return new RemovePropertyDefinition();
        }

        @Override
        protected RemovePropertyDefinition newInstance(String value) {
            return new RemovePropertyDefinition(value);
        }

        @Override
        protected boolean setProperty(RemovePropertyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "resequence",
            types = org.apache.camel.model.ResequenceDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Resequence",
            description = "Resequences (re-order) messages based on an expression",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "batch-config", type = "object:org.apache.camel.model.config.BatchResequencerConfig", oneOf = "resequencerConfig"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to use for re-ordering the messages, such as a header with a sequence number", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "stream-config", type = "object:org.apache.camel.model.config.StreamResequencerConfig", oneOf = "resequencerConfig")
            }
    )
    public static class ResequenceDefinitionDeserializer extends YamlDeserializerBase<ResequenceDefinition> {
        public ResequenceDefinitionDeserializer() {
            super(ResequenceDefinition.class);
        }

        @Override
        protected ResequenceDefinition newInstance() {
            return new ResequenceDefinition();
        }

        @Override
        protected boolean setProperty(ResequenceDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "resequencer-config": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "batch-config": {
                    org.apache.camel.model.config.BatchResequencerConfig val = asType(node, org.apache.camel.model.config.BatchResequencerConfig.class);
                    target.setResequencerConfig(val);
                    break;
                }
                case "stream-config": {
                    org.apache.camel.model.config.StreamResequencerConfig val = asType(node, org.apache.camel.model.config.StreamResequencerConfig.class);
                    target.setResequencerConfig(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "resilience4j-configuration",
                    "resilience4jConfiguration"
            },
            types = org.apache.camel.model.Resilience4jConfigurationDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Resilience4j Configuration",
            description = "Resilience4j Circuit Breaker EIP configuration",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "automatic-transition-from-open-to-half-open-enabled", type = "boolean", description = "Enables automatic transition from OPEN to HALF_OPEN state once the waitDurationInOpenState has passed.", displayName = "Automatic Transition From Open To Half Open Enabled"),
                    @YamlProperty(name = "bulkhead-enabled", type = "boolean", description = "Whether bulkhead is enabled or not on the circuit breaker. Default is false.", displayName = "Bulkhead Enabled"),
                    @YamlProperty(name = "bulkhead-max-concurrent-calls", type = "number", defaultValue = "25", description = "Configures the max amount of concurrent calls the bulkhead will support.", displayName = "Bulkhead Max Concurrent Calls"),
                    @YamlProperty(name = "bulkhead-max-wait-duration", type = "number", defaultValue = "0", description = "Configures a maximum amount of time which the calling thread will wait to enter the bulkhead. If bulkhead has space available, entry is guaranteed and immediate. If bulkhead is full, calling threads will contest for space, if it becomes available. maxWaitDuration can be set to 0. Note: for threads running on an event-loop or equivalent (rx computation pool, etc), setting maxWaitDuration to 0 is highly recommended. Blocking an event-loop thread will most likely have a negative effect on application throughput.", displayName = "Bulkhead Max Wait Duration"),
                    @YamlProperty(name = "circuit-breaker", type = "string", description = "Refers to an existing io.github.resilience4j.circuitbreaker.CircuitBreaker instance to lookup and use from the registry. When using this, then any other circuit breaker options are not in use.", displayName = "Circuit Breaker"),
                    @YamlProperty(name = "config", type = "string", description = "Refers to an existing io.github.resilience4j.circuitbreaker.CircuitBreakerConfig instance to lookup and use from the registry.", displayName = "Config"),
                    @YamlProperty(name = "failure-rate-threshold", type = "number", defaultValue = "50", description = "Configures the failure rate threshold in percentage. If the failure rate is equal or greater than the threshold the CircuitBreaker transitions to open and starts short-circuiting calls. The threshold must be greater than 0 and not greater than 100. Default value is 50 percentage.", displayName = "Failure Rate Threshold"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "minimum-number-of-calls", type = "number", defaultValue = "100", description = "Configures the minimum number of calls which are required (per sliding window period) before the CircuitBreaker can calculate the error rate. For example, if minimumNumberOfCalls is 10, then at least 10 calls must be recorded, before the failure rate can be calculated. If only 9 calls have been recorded the CircuitBreaker will not transition to open even if all 9 calls have failed. Default minimumNumberOfCalls is 100", displayName = "Minimum Number Of Calls"),
                    @YamlProperty(name = "permitted-number-of-calls-in-half-open-state", type = "number", defaultValue = "10", description = "Configures the number of permitted calls when the CircuitBreaker is half open. The size must be greater than 0. Default size is 10.", displayName = "Permitted Number Of Calls In Half Open State"),
                    @YamlProperty(name = "sliding-window-size", type = "number", defaultValue = "100", description = "Configures the size of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed. slidingWindowSize configures the size of the sliding window. Sliding window can either be count-based or time-based. If slidingWindowType is COUNT_BASED, the last slidingWindowSize calls are recorded and aggregated. If slidingWindowType is TIME_BASED, the calls of the last slidingWindowSize seconds are recorded and aggregated. The slidingWindowSize must be greater than 0. The minimumNumberOfCalls must be greater than 0. If the slidingWindowType is COUNT_BASED, the minimumNumberOfCalls cannot be greater than slidingWindowSize . If the slidingWindowType is TIME_BASED, you can pick whatever you want. Default slidingWindowSize is 100.", displayName = "Sliding Window Size"),
                    @YamlProperty(name = "sliding-window-type", type = "enum:TIME_BASED,COUNT_BASED", defaultValue = "COUNT_BASED", description = "Configures the type of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed. Sliding window can either be count-based or time-based. If slidingWindowType is COUNT_BASED, the last slidingWindowSize calls are recorded and aggregated. If slidingWindowType is TIME_BASED, the calls of the last slidingWindowSize seconds are recorded and aggregated. Default slidingWindowType is COUNT_BASED.", displayName = "Sliding Window Type"),
                    @YamlProperty(name = "slow-call-duration-threshold", type = "number", defaultValue = "60", description = "Configures the duration threshold (seconds) above which calls are considered as slow and increase the slow calls percentage. Default value is 60 seconds.", displayName = "Slow Call Duration Threshold"),
                    @YamlProperty(name = "slow-call-rate-threshold", type = "number", defaultValue = "100", description = "Configures a threshold in percentage. The CircuitBreaker considers a call as slow when the call duration is greater than slowCallDurationThreshold Duration. When the percentage of slow calls is equal or greater the threshold, the CircuitBreaker transitions to open and starts short-circuiting calls. The threshold must be greater than 0 and not greater than 100. Default value is 100 percentage which means that all recorded calls must be slower than slowCallDurationThreshold.", displayName = "Slow Call Rate Threshold"),
                    @YamlProperty(name = "throw-exception-when-half-open-or-open-state", type = "boolean", description = "Whether to throw io.github.resilience4j.circuitbreaker.CallNotPermittedException when the call is rejected due circuit breaker is half open or open.", displayName = "Throw Exception When Half Open Or Open State"),
                    @YamlProperty(name = "timeout-cancel-running-future", type = "boolean", description = "Configures whether cancel is called on the running future. Defaults to true.", displayName = "Timeout Cancel Running Future"),
                    @YamlProperty(name = "timeout-duration", type = "number", defaultValue = "1000", description = "Configures the thread execution timeout. Default value is 1 second.", displayName = "Timeout Duration"),
                    @YamlProperty(name = "timeout-enabled", type = "boolean", description = "Whether timeout is enabled or not on the circuit breaker. Default is false.", displayName = "Timeout Enabled"),
                    @YamlProperty(name = "timeout-executor-service", type = "string", description = "References to a custom thread pool to use when timeout is enabled (uses ForkJoinPool#commonPool() by default)", displayName = "Timeout Executor Service"),
                    @YamlProperty(name = "wait-duration-in-open-state", type = "number", defaultValue = "60", description = "Configures the wait duration (in seconds) which specifies how long the CircuitBreaker should stay open, before it switches to half open. Default value is 60 seconds.", displayName = "Wait Duration In Open State"),
                    @YamlProperty(name = "writable-stack-trace-enabled", type = "boolean", description = "Enables writable stack traces. When set to false, Exception.getStackTrace returns a zero length array. This may be used to reduce log spam when the circuit breaker is open as the cause of the exceptions is already known (the circuit breaker is short-circuiting calls).", displayName = "Writable Stack Trace Enabled")
            }
    )
    public static class Resilience4jConfigurationDefinitionDeserializer extends YamlDeserializerBase<Resilience4jConfigurationDefinition> {
        public Resilience4jConfigurationDefinitionDeserializer() {
            super(Resilience4jConfigurationDefinition.class);
        }

        @Override
        protected Resilience4jConfigurationDefinition newInstance() {
            return new Resilience4jConfigurationDefinition();
        }

        @Override
        protected boolean setProperty(Resilience4jConfigurationDefinition target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "automatic-transition-from-open-to-half-open-enabled": {
                    String val = asText(node);
                    target.setAutomaticTransitionFromOpenToHalfOpenEnabled(val);
                    break;
                }
                case "bulkhead-enabled": {
                    String val = asText(node);
                    target.setBulkheadEnabled(val);
                    break;
                }
                case "bulkhead-max-concurrent-calls": {
                    String val = asText(node);
                    target.setBulkheadMaxConcurrentCalls(val);
                    break;
                }
                case "bulkhead-max-wait-duration": {
                    String val = asText(node);
                    target.setBulkheadMaxWaitDuration(val);
                    break;
                }
                case "circuit-breaker": {
                    String val = asText(node);
                    target.setCircuitBreaker(val);
                    break;
                }
                case "config": {
                    String val = asText(node);
                    target.setConfig(val);
                    break;
                }
                case "failure-rate-threshold": {
                    String val = asText(node);
                    target.setFailureRateThreshold(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "minimum-number-of-calls": {
                    String val = asText(node);
                    target.setMinimumNumberOfCalls(val);
                    break;
                }
                case "permitted-number-of-calls-in-half-open-state": {
                    String val = asText(node);
                    target.setPermittedNumberOfCallsInHalfOpenState(val);
                    break;
                }
                case "sliding-window-size": {
                    String val = asText(node);
                    target.setSlidingWindowSize(val);
                    break;
                }
                case "sliding-window-type": {
                    String val = asText(node);
                    target.setSlidingWindowType(val);
                    break;
                }
                case "slow-call-duration-threshold": {
                    String val = asText(node);
                    target.setSlowCallDurationThreshold(val);
                    break;
                }
                case "slow-call-rate-threshold": {
                    String val = asText(node);
                    target.setSlowCallRateThreshold(val);
                    break;
                }
                case "throw-exception-when-half-open-or-open-state": {
                    String val = asText(node);
                    target.setThrowExceptionWhenHalfOpenOrOpenState(val);
                    break;
                }
                case "timeout-cancel-running-future": {
                    String val = asText(node);
                    target.setTimeoutCancelRunningFuture(val);
                    break;
                }
                case "timeout-duration": {
                    String val = asText(node);
                    target.setTimeoutDuration(val);
                    break;
                }
                case "timeout-enabled": {
                    String val = asText(node);
                    target.setTimeoutEnabled(val);
                    break;
                }
                case "timeout-executor-service": {
                    String val = asText(node);
                    target.setTimeoutExecutorService(val);
                    break;
                }
                case "wait-duration-in-open-state": {
                    String val = asText(node);
                    target.setWaitDurationInOpenState(val);
                    break;
                }
                case "writable-stack-trace-enabled": {
                    String val = asText(node);
                    target.setWritableStackTraceEnabled(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "response-header",
                    "responseHeader"
            },
            types = org.apache.camel.model.rest.ResponseHeaderDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Response Header",
            description = "To specify the rest operation response headers.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allowable-values", type = "array:org.apache.camel.model.ValueDefinition", description = "Sets the parameter list of allowable values.", displayName = "Allowable Values"),
                    @YamlProperty(name = "array-type", type = "string", defaultValue = "string", description = "Sets the parameter array type. Required if data type is array. Describes the type of items in the array.", displayName = "Array Type"),
                    @YamlProperty(name = "collection-format", type = "enum:csv,multi,pipes,ssv,tsv", defaultValue = "csv", description = "Sets the parameter collection format.", displayName = "Collection Format"),
                    @YamlProperty(name = "data-format", type = "string", description = "Sets the parameter data format.", displayName = "Data Format"),
                    @YamlProperty(name = "data-type", type = "string", defaultValue = "string", description = "Sets the header data type.", displayName = "Data Type"),
                    @YamlProperty(name = "description", type = "string", description = "Description of the parameter.", displayName = "Description"),
                    @YamlProperty(name = "example", type = "string", description = "Sets the example", displayName = "Example"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "Name of the parameter. This option is mandatory.", displayName = "Name")
            }
    )
    public static class ResponseHeaderDefinitionDeserializer extends YamlDeserializerBase<ResponseHeaderDefinition> {
        public ResponseHeaderDefinitionDeserializer() {
            super(ResponseHeaderDefinition.class);
        }

        @Override
        protected ResponseHeaderDefinition newInstance() {
            return new ResponseHeaderDefinition();
        }

        @Override
        protected boolean setProperty(ResponseHeaderDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allowable-values": {
                    java.util.List<org.apache.camel.model.ValueDefinition> val = asFlatList(node, org.apache.camel.model.ValueDefinition.class);
                    target.setAllowableValues(val);
                    break;
                }
                case "array-type": {
                    String val = asText(node);
                    target.setArrayType(val);
                    break;
                }
                case "collection-format": {
                    target.setCollectionFormat(asEnum(node, org.apache.camel.model.rest.CollectionFormat.class));
                    break;
                }
                case "data-format": {
                    String val = asText(node);
                    target.setDataFormat(val);
                    break;
                }
                case "data-type": {
                    String val = asText(node);
                    target.setDataType(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "example": {
                    String val = asText(node);
                    target.setExample(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "response-message",
                    "responseMessage"
            },
            types = org.apache.camel.model.rest.ResponseMessageDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Response Message",
            description = "To specify the rest operation response messages.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "code", type = "string", defaultValue = "200", description = "The response code such as a HTTP status code", displayName = "Code"),
                    @YamlProperty(name = "examples", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Examples of response messages", displayName = "Examples"),
                    @YamlProperty(name = "header", type = "array:org.apache.camel.model.rest.ResponseHeaderDefinition", description = "Adds a response header", displayName = "Header"),
                    @YamlProperty(name = "message", type = "string", required = true, description = "The response message (description)", displayName = "Message"),
                    @YamlProperty(name = "response-model", type = "string", description = "The response model", displayName = "Response Model")
            }
    )
    public static class ResponseMessageDefinitionDeserializer extends YamlDeserializerBase<ResponseMessageDefinition> {
        public ResponseMessageDefinitionDeserializer() {
            super(ResponseMessageDefinition.class);
        }

        @Override
        protected ResponseMessageDefinition newInstance() {
            return new ResponseMessageDefinition();
        }

        @Override
        protected boolean setProperty(ResponseMessageDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "code": {
                    String val = asText(node);
                    target.setCode(val);
                    break;
                }
                case "examples": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setExamples(val);
                    break;
                }
                case "header": {
                    java.util.List<org.apache.camel.model.rest.ResponseHeaderDefinition> val = asFlatList(node, org.apache.camel.model.rest.ResponseHeaderDefinition.class);
                    target.setHeaders(val);
                    break;
                }
                case "message": {
                    String val = asText(node);
                    target.setMessage(val);
                    break;
                }
                case "response-model": {
                    String val = asText(node);
                    target.setResponseModel(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "rest-binding",
                    "restBinding"
            },
            types = org.apache.camel.model.rest.RestBindingDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rest Binding",
            description = "To configure rest binding",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "component", type = "string", description = "Sets the component name that this definition will apply to", displayName = "Component"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json", displayName = "Consumes"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "out-type", type = "string", description = "Sets the class name to use for binding from POJO to output for the outgoing data The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Out Type"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json", displayName = "Produces"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do.", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name to use for binding from input to POJO for the incoming data The name of the class of the input data. Append a to the end of the name if you want the input to be an array type.", displayName = "Type")
            }
    )
    public static class RestBindingDefinitionDeserializer extends YamlDeserializerBase<RestBindingDefinition> {
        public RestBindingDefinitionDeserializer() {
            super(RestBindingDefinition.class);
        }

        @Override
        protected RestBindingDefinition newInstance() {
            return new RestBindingDefinition();
        }

        @Override
        protected boolean setProperty(RestBindingDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "component": {
                    String val = asText(node);
                    target.setComponent(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "out-type": {
                    String val = asText(node);
                    target.setOutType(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlIn
    @YamlType(
            nodes = {
                    "rest-configuration",
                    "restConfiguration"
            },
            types = org.apache.camel.model.rest.RestConfigurationDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rest Configuration",
            description = "To configure rest",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-component", type = "enum:openapi,swagger", description = "The name of the Camel component to use as the REST API. If no API Component has been explicit configured, then Camel will lookup if there is a Camel component responsible for servicing and generating the REST API documentation, or if a org.apache.camel.spi.RestApiProcessorFactory is registered in the registry. If either one is found, then that is being used.", displayName = "Api Component"),
                    @YamlProperty(name = "api-context-path", type = "string", description = "Sets a leading API context-path the REST API services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path.", displayName = "Api Context Path"),
                    @YamlProperty(name = "api-context-route-id", type = "string", description = "Sets the route id to use for the route that services the REST API. The route will by default use an auto assigned route id.", displayName = "Api Context Route Id"),
                    @YamlProperty(name = "api-host", type = "string", description = "To use a specific hostname for the API documentation (such as swagger or openapi) This can be used to override the generated host with this configured hostname", displayName = "Api Host"),
                    @YamlProperty(name = "api-property", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Allows to configure as many additional properties for the api documentation. For example set property api.title to my cool stuff", displayName = "Api Property"),
                    @YamlProperty(name = "api-vendor-extension", type = "boolean", description = "Whether vendor extension is enabled in the Rest APIs. If enabled then Camel will include additional information as vendor extension (eg keys starting with x-) such as route ids, class names etc. Not all 3rd party API gateways and tools supports vendor-extensions when importing your API docs.", displayName = "Api Vendor Extension"),
                    @YamlProperty(name = "binding-mode", type = "enum:auto,json,json_xml,off,xml", defaultValue = "off", description = "Sets the binding mode to use. The default value is off", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "component", type = "enum:platform-http,servlet,jetty,undertow,netty-http,coap", description = "The Camel Rest component to use for the REST transport (consumer), such as netty-http, jetty, servlet, undertow. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used.", displayName = "Component"),
                    @YamlProperty(name = "component-property", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Allows to configure as many additional properties for the rest component in use.", displayName = "Component Property"),
                    @YamlProperty(name = "consumer-property", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Allows to configure as many additional properties for the rest consumer in use.", displayName = "Consumer Property"),
                    @YamlProperty(name = "context-path", type = "string", description = "Sets a leading context-path the REST services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path. Or for components such as camel-jetty or camel-netty-http that includes a HTTP server.", displayName = "Context Path"),
                    @YamlProperty(name = "cors-headers", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Allows to configure custom CORS headers.", displayName = "Cors Headers"),
                    @YamlProperty(name = "data-format-property", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Allows to configure as many additional properties for the data formats in use. For example set property prettyPrint to true to have json outputted in pretty mode. The properties can be prefixed to denote the option is only for either JSON or XML and for either the IN or the OUT. The prefixes are: json.in. json.out. xml.in. xml.out. For example a key with value xml.out.mustBeJAXBElement is only for the XML data format for the outgoing. A key without a prefix is a common key for all situations.", displayName = "Data Format Property"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "endpoint-property", type = "array:org.apache.camel.model.rest.RestPropertyDefinition", description = "Allows to configure as many additional properties for the rest endpoint in use.", displayName = "Endpoint Property"),
                    @YamlProperty(name = "host", type = "string", description = "The hostname to use for exposing the REST service.", displayName = "Host"),
                    @YamlProperty(name = "host-name-resolver", type = "enum:allLocalIp,localHostName,localIp", defaultValue = "allLocalIp", description = "If no hostname has been explicit configured, then this resolver is used to compute the hostname the REST service will be using.", displayName = "Host Name Resolver"),
                    @YamlProperty(name = "inline-routes", type = "boolean", description = "Inline routes in rest-dsl which are linked using direct endpoints. By default, each service in Rest DSL is an individual route, meaning that you would have at least two routes per service (rest-dsl, and the route linked from rest-dsl). Enabling this allows Camel to optimize and inline this as a single route, however this requires to use direct endpoints, which must be unique per service. This option is default false.", displayName = "Inline Routes"),
                    @YamlProperty(name = "json-data-format", type = "string", description = "Name of specific json data format to use. By default jackson will be used. Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.", displayName = "Json Data Format"),
                    @YamlProperty(name = "port", type = "string", description = "The port number to use for exposing the REST service. Notice if you use servlet component then the port number configured here does not apply, as the port number in use is the actual port number the servlet component is using. eg if using Apache Tomcat its the tomcat http port, if using Apache Karaf its the HTTP service in Karaf that uses port 8181 by default etc. Though in those situations setting the port number here, allows tooling and JMX to know the port number, so its recommended to set the port number to the number that the servlet engine uses.", displayName = "Port"),
                    @YamlProperty(name = "producer-api-doc", type = "string", description = "Sets the location of the api document the REST producer will use to validate the REST uri and query parameters are valid accordingly to the api document. The location of the api document is loaded from classpath by default, but you can use file: or http: to refer to resources to load from file or http url.", displayName = "Producer Api Doc"),
                    @YamlProperty(name = "producer-component", type = "enum:vertx-http,http,undertow,netty-http", description = "Sets the name of the Camel component to use as the REST producer", displayName = "Producer Component"),
                    @YamlProperty(name = "scheme", type = "string", description = "The scheme to use for exposing the REST service. Usually http or https is supported. The default value is http", displayName = "Scheme"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do.", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "use-x-forward-headers", type = "boolean", description = "Whether to use X-Forward headers for Host and related setting. The default value is true.", displayName = "Use XForward Headers"),
                    @YamlProperty(name = "xml-data-format", type = "string", description = "Name of specific XML data format to use. By default jaxb will be used. Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance.", displayName = "Xml Data Format")
            }
    )
    public static class RestConfigurationDefinitionDeserializer extends YamlDeserializerBase<RestConfigurationDefinition> {
        public RestConfigurationDefinitionDeserializer() {
            super(RestConfigurationDefinition.class);
        }

        @Override
        protected RestConfigurationDefinition newInstance() {
            return new RestConfigurationDefinition();
        }

        @Override
        protected boolean setProperty(RestConfigurationDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "api-component": {
                    String val = asText(node);
                    target.setApiComponent(val);
                    break;
                }
                case "api-context-path": {
                    String val = asText(node);
                    target.setApiContextPath(val);
                    break;
                }
                case "api-context-route-id": {
                    String val = asText(node);
                    target.setApiContextRouteId(val);
                    break;
                }
                case "api-host": {
                    String val = asText(node);
                    target.setApiHost(val);
                    break;
                }
                case "api-property": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setApiProperties(val);
                    break;
                }
                case "api-vendor-extension": {
                    String val = asText(node);
                    target.setApiVendorExtension(val);
                    break;
                }
                case "binding-mode": {
                    target.setBindingMode(asEnum(node, org.apache.camel.model.rest.RestBindingMode.class));
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "component": {
                    String val = asText(node);
                    target.setComponent(val);
                    break;
                }
                case "component-property": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setComponentProperties(val);
                    break;
                }
                case "consumer-property": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setConsumerProperties(val);
                    break;
                }
                case "context-path": {
                    String val = asText(node);
                    target.setContextPath(val);
                    break;
                }
                case "cors-headers": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setCorsHeaders(val);
                    break;
                }
                case "data-format-property": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setDataFormatProperties(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "endpoint-property": {
                    java.util.List<org.apache.camel.model.rest.RestPropertyDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestPropertyDefinition.class);
                    target.setEndpointProperties(val);
                    break;
                }
                case "host": {
                    String val = asText(node);
                    target.setHost(val);
                    break;
                }
                case "host-name-resolver": {
                    target.setHostNameResolver(asEnum(node, org.apache.camel.model.rest.RestHostNameResolver.class));
                    break;
                }
                case "inline-routes": {
                    String val = asText(node);
                    target.setInlineRoutes(val);
                    break;
                }
                case "json-data-format": {
                    String val = asText(node);
                    target.setJsonDataFormat(val);
                    break;
                }
                case "port": {
                    String val = asText(node);
                    target.setPort(val);
                    break;
                }
                case "producer-api-doc": {
                    String val = asText(node);
                    target.setProducerApiDoc(val);
                    break;
                }
                case "producer-component": {
                    String val = asText(node);
                    target.setProducerComponent(val);
                    break;
                }
                case "scheme": {
                    String val = asText(node);
                    target.setScheme(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "use-x-forward-headers": {
                    String val = asText(node);
                    target.setUseXForwardHeaders(val);
                    break;
                }
                case "xml-data-format": {
                    String val = asText(node);
                    target.setXmlDataFormat(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "rest-context-ref",
                    "restContextRef"
            },
            inline = true,
            types = org.apache.camel.model.RestContextRefDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rest Context Ref",
            description = "To refer to an XML file with rest services defined using the rest-dsl",
            deprecated = false,
            properties = @YamlProperty(name = "ref", type = "string", required = true, description = "Reference to the rest-dsl", displayName = "Ref")
    )
    public static class RestContextRefDefinitionDeserializer extends YamlDeserializerBase<RestContextRefDefinition> {
        public RestContextRefDefinitionDeserializer() {
            super(RestContextRefDefinition.class);
        }

        @Override
        protected RestContextRefDefinition newInstance() {
            return new RestContextRefDefinition();
        }

        @Override
        protected RestContextRefDefinition newInstance(String value) {
            return new RestContextRefDefinition(value);
        }

        @Override
        protected boolean setProperty(RestContextRefDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlIn
    @YamlType(
            nodes = "rest",
            types = org.apache.camel.model.rest.RestDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rest",
            description = "Defines a rest service using the rest-dsl",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-docs", type = "boolean", description = "Whether to include or exclude this rest operation in API documentation. This option will override what may be configured on a parent level. The default value is true.", displayName = "Api Docs"),
                    @YamlProperty(name = "binding-mode", type = "enum:off,auto,json,xml,json_xml", defaultValue = "off", description = "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto", displayName = "Binding Mode"),
                    @YamlProperty(name = "client-request-validation", type = "boolean", description = "Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSon, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error.", displayName = "Client Request Validation"),
                    @YamlProperty(name = "consumes", type = "string", description = "To define the content type what the REST service consumes (accept as input), such as application/xml or application/json. This option will override what may be configured on a parent level", displayName = "Consumes"),
                    @YamlProperty(name = "delete", type = "array:org.apache.camel.model.rest.DeleteDefinition"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this REST service from the route during build time. Once an REST service has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "enable-cors", type = "boolean"),
                    @YamlProperty(name = "get", type = "array:org.apache.camel.model.rest.GetDefinition"),
                    @YamlProperty(name = "head", type = "array:org.apache.camel.model.rest.HeadDefinition"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "patch", type = "array:org.apache.camel.model.rest.PatchDefinition"),
                    @YamlProperty(name = "path", type = "string", description = "Path of the rest service, such as /foo", displayName = "Path"),
                    @YamlProperty(name = "post", type = "array:org.apache.camel.model.rest.PostDefinition"),
                    @YamlProperty(name = "produces", type = "string", description = "To define the content type what the REST service produces (uses for output), such as application/xml or application/json This option will override what may be configured on a parent level", displayName = "Produces"),
                    @YamlProperty(name = "put", type = "array:org.apache.camel.model.rest.PutDefinition"),
                    @YamlProperty(name = "security-definitions", type = "object:org.apache.camel.model.rest.RestSecuritiesDefinition", description = "Sets the security definitions such as Basic, OAuth2 etc.", displayName = "Security Definitions"),
                    @YamlProperty(name = "security-requirements", type = "array:org.apache.camel.model.rest.SecurityDefinition", description = "Sets the security requirement(s) for all endpoints.", displayName = "Security Requirements"),
                    @YamlProperty(name = "skip-binding-on-error-code", type = "boolean", description = "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc, as success messages otherwise will do. This option will override what may be configured on a parent level", displayName = "Skip Binding On Error Code"),
                    @YamlProperty(name = "tag", type = "string", description = "To configure a special tag for the operations within this rest definition.", displayName = "Tag")
            }
    )
    public static class RestDefinitionDeserializer extends YamlDeserializerBase<RestDefinition> {
        public RestDefinitionDeserializer() {
            super(RestDefinition.class);
        }

        @Override
        protected RestDefinition newInstance() {
            return new RestDefinition();
        }

        @Override
        protected boolean setProperty(RestDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "api-docs": {
                    String val = asText(node);
                    target.setApiDocs(val);
                    break;
                }
                case "binding-mode": {
                    String val = asText(node);
                    target.setBindingMode(val);
                    break;
                }
                case "client-request-validation": {
                    String val = asText(node);
                    target.setClientRequestValidation(val);
                    break;
                }
                case "consumes": {
                    String val = asText(node);
                    target.setConsumes(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "enable-cors": {
                    String val = asText(node);
                    target.setEnableCORS(val);
                    break;
                }
                case "path": {
                    String val = asText(node);
                    target.setPath(val);
                    break;
                }
                case "produces": {
                    String val = asText(node);
                    target.setProduces(val);
                    break;
                }
                case "security-definitions": {
                    org.apache.camel.model.rest.RestSecuritiesDefinition val = asType(node, org.apache.camel.model.rest.RestSecuritiesDefinition.class);
                    target.setSecurityDefinitions(val);
                    break;
                }
                case "security-requirements": {
                    java.util.List<org.apache.camel.model.rest.SecurityDefinition> val = asFlatList(node, org.apache.camel.model.rest.SecurityDefinition.class);
                    target.setSecurityRequirements(val);
                    break;
                }
                case "skip-binding-on-error-code": {
                    String val = asText(node);
                    target.setSkipBindingOnErrorCode(val);
                    break;
                }
                case "tag": {
                    String val = asText(node);
                    target.setTag(val);
                    break;
                }
                case "delete": {
                    java.util.List<org.apache.camel.model.rest.VerbDefinition> existing = target.getVerbs();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    java.util.List val = asFlatList(node, org.apache.camel.model.rest.DeleteDefinition.class);
                    existing.addAll(val);
                    target.setVerbs(existing);
                    break;
                }
                case "get": {
                    java.util.List<org.apache.camel.model.rest.VerbDefinition> existing = target.getVerbs();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    java.util.List val = asFlatList(node, org.apache.camel.model.rest.GetDefinition.class);
                    existing.addAll(val);
                    target.setVerbs(existing);
                    break;
                }
                case "head": {
                    java.util.List<org.apache.camel.model.rest.VerbDefinition> existing = target.getVerbs();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    java.util.List val = asFlatList(node, org.apache.camel.model.rest.HeadDefinition.class);
                    existing.addAll(val);
                    target.setVerbs(existing);
                    break;
                }
                case "patch": {
                    java.util.List<org.apache.camel.model.rest.VerbDefinition> existing = target.getVerbs();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    java.util.List val = asFlatList(node, org.apache.camel.model.rest.PatchDefinition.class);
                    existing.addAll(val);
                    target.setVerbs(existing);
                    break;
                }
                case "post": {
                    java.util.List<org.apache.camel.model.rest.VerbDefinition> existing = target.getVerbs();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    java.util.List val = asFlatList(node, org.apache.camel.model.rest.PostDefinition.class);
                    existing.addAll(val);
                    target.setVerbs(existing);
                    break;
                }
                case "put": {
                    java.util.List<org.apache.camel.model.rest.VerbDefinition> existing = target.getVerbs();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    java.util.List val = asFlatList(node, org.apache.camel.model.rest.PutDefinition.class);
                    existing.addAll(val);
                    target.setVerbs(existing);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "rest-property",
                    "restProperty"
            },
            types = org.apache.camel.model.rest.RestPropertyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rest Property",
            description = "A key value pair",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "key", type = "string", required = true, description = "Property key", displayName = "Key"),
                    @YamlProperty(name = "value", type = "string", required = true, description = "Property value", displayName = "Value")
            }
    )
    public static class RestPropertyDefinitionDeserializer extends YamlDeserializerBase<RestPropertyDefinition> {
        public RestPropertyDefinitionDeserializer() {
            super(RestPropertyDefinition.class);
        }

        @Override
        protected RestPropertyDefinition newInstance() {
            return new RestPropertyDefinition();
        }

        @Override
        protected boolean setProperty(RestPropertyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "security-definitions",
                    "securityDefinitions"
            },
            types = org.apache.camel.model.rest.RestSecuritiesDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rest Security Definitions",
            description = "To configure rest security definitions.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "api-key", type = "object:org.apache.camel.model.rest.ApiKeyDefinition"),
                    @YamlProperty(name = "basic-auth", type = "object:org.apache.camel.model.rest.BasicAuthDefinition"),
                    @YamlProperty(name = "bearer", type = "object:org.apache.camel.model.rest.BearerTokenDefinition"),
                    @YamlProperty(name = "mutual-tls", type = "object:org.apache.camel.model.rest.MutualTLSDefinition"),
                    @YamlProperty(name = "oauth2", type = "object:org.apache.camel.model.rest.OAuth2Definition"),
                    @YamlProperty(name = "open-id-connect", type = "object:org.apache.camel.model.rest.OpenIdConnectDefinition")
            }
    )
    public static class RestSecuritiesDefinitionDeserializer extends YamlDeserializerBase<RestSecuritiesDefinition> {
        public RestSecuritiesDefinitionDeserializer() {
            super(RestSecuritiesDefinition.class);
        }

        @Override
        protected RestSecuritiesDefinition newInstance() {
            return new RestSecuritiesDefinition();
        }

        @Override
        protected boolean setProperty(RestSecuritiesDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "security-definitions": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "api-key": {
                    org.apache.camel.model.rest.ApiKeyDefinition val = asType(node, org.apache.camel.model.rest.ApiKeyDefinition.class);
                    java.util.List<org.apache.camel.model.rest.RestSecurityDefinition> existing = target.getSecurityDefinitions();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setSecurityDefinitions(existing);
                    break;
                }
                case "basic-auth": {
                    org.apache.camel.model.rest.BasicAuthDefinition val = asType(node, org.apache.camel.model.rest.BasicAuthDefinition.class);
                    java.util.List<org.apache.camel.model.rest.RestSecurityDefinition> existing = target.getSecurityDefinitions();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setSecurityDefinitions(existing);
                    break;
                }
                case "bearer": {
                    org.apache.camel.model.rest.BearerTokenDefinition val = asType(node, org.apache.camel.model.rest.BearerTokenDefinition.class);
                    java.util.List<org.apache.camel.model.rest.RestSecurityDefinition> existing = target.getSecurityDefinitions();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setSecurityDefinitions(existing);
                    break;
                }
                case "oauth2": {
                    org.apache.camel.model.rest.OAuth2Definition val = asType(node, org.apache.camel.model.rest.OAuth2Definition.class);
                    java.util.List<org.apache.camel.model.rest.RestSecurityDefinition> existing = target.getSecurityDefinitions();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setSecurityDefinitions(existing);
                    break;
                }
                case "open-id-connect": {
                    org.apache.camel.model.rest.OpenIdConnectDefinition val = asType(node, org.apache.camel.model.rest.OpenIdConnectDefinition.class);
                    java.util.List<org.apache.camel.model.rest.RestSecurityDefinition> existing = target.getSecurityDefinitions();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setSecurityDefinitions(existing);
                    break;
                }
                case "mutual-tls": {
                    org.apache.camel.model.rest.MutualTLSDefinition val = asType(node, org.apache.camel.model.rest.MutualTLSDefinition.class);
                    java.util.List<org.apache.camel.model.rest.RestSecurityDefinition> existing = target.getSecurityDefinitions();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setSecurityDefinitions(existing);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "rests",
            types = org.apache.camel.model.rest.RestsDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rests",
            description = "A series of rest services defined using the rest-dsl",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "rest", type = "array:org.apache.camel.model.rest.RestDefinition")
            }
    )
    public static class RestsDefinitionDeserializer extends YamlDeserializerBase<RestsDefinition> {
        public RestsDefinitionDeserializer() {
            super(RestsDefinition.class);
        }

        @Override
        protected RestsDefinition newInstance() {
            return new RestsDefinition();
        }

        @Override
        protected boolean setProperty(RestsDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "rest": {
                    java.util.List<org.apache.camel.model.rest.RestDefinition> val = asFlatList(node, org.apache.camel.model.rest.RestDefinition.class);
                    target.setRests(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "resumable",
            types = org.apache.camel.model.ResumableDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Resumable",
            description = "Resume EIP to support resuming processing from last known offset.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "intermittent", type = "boolean", description = "Sets whether the offsets will be intermittently present or whether they must be present in every exchange", displayName = "Intermittent"),
                    @YamlProperty(name = "logging-level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "ERROR", displayName = "Logging Level"),
                    @YamlProperty(name = "resume-strategy", type = "string", required = true, description = "Sets the resume strategy to use", displayName = "Resume Strategy")
            }
    )
    public static class ResumableDefinitionDeserializer extends YamlDeserializerBase<ResumableDefinition> {
        public ResumableDefinitionDeserializer() {
            super(ResumableDefinition.class);
        }

        @Override
        protected ResumableDefinition newInstance() {
            return new ResumableDefinition();
        }

        @Override
        protected boolean setProperty(ResumableDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "intermittent": {
                    String val = asText(node);
                    target.setIntermittent(val);
                    break;
                }
                case "logging-level": {
                    String val = asText(node);
                    target.setLoggingLevel(val);
                    break;
                }
                case "resume-strategy": {
                    String val = asText(node);
                    target.setResumeStrategy(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "rollback",
            inline = true,
            types = org.apache.camel.model.RollbackDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rollback",
            description = "Forces a rollback by stopping routing the message",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "mark-rollback-only", type = "boolean", description = "Mark the transaction for rollback only (cannot be overruled to commit)", displayName = "Mark Rollback Only"),
                    @YamlProperty(name = "mark-rollback-only-last", type = "boolean", description = "Mark only last sub transaction for rollback only. When using sub transactions (if the transaction manager support this)", displayName = "Mark Rollback Only Last"),
                    @YamlProperty(name = "message", type = "string", description = "Message to use in rollback exception", displayName = "Message")
            }
    )
    public static class RollbackDefinitionDeserializer extends YamlDeserializerBase<RollbackDefinition> {
        public RollbackDefinitionDeserializer() {
            super(RollbackDefinition.class);
        }

        @Override
        protected RollbackDefinition newInstance() {
            return new RollbackDefinition();
        }

        @Override
        protected RollbackDefinition newInstance(String value) {
            return new RollbackDefinition(value);
        }

        @Override
        protected boolean setProperty(RollbackDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "mark-rollback-only": {
                    String val = asText(node);
                    target.setMarkRollbackOnly(val);
                    break;
                }
                case "mark-rollback-only-last": {
                    String val = asText(node);
                    target.setMarkRollbackOnlyLast(val);
                    break;
                }
                case "message": {
                    String val = asText(node);
                    target.setMessage(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "round-robin",
                    "roundRobin"
            },
            types = org.apache.camel.model.loadbalancer.RoundRobinLoadBalancerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Round Robin",
            description = "The destination endpoints are selected in a round-robin fashion. This is a well known and classic policy, which spreads the load evenly.",
            deprecated = false,
            properties = @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
    )
    public static class RoundRobinLoadBalancerDefinitionDeserializer extends YamlDeserializerBase<RoundRobinLoadBalancerDefinition> {
        public RoundRobinLoadBalancerDefinitionDeserializer() {
            super(RoundRobinLoadBalancerDefinition.class);
        }

        @Override
        protected RoundRobinLoadBalancerDefinition newInstance() {
            return new RoundRobinLoadBalancerDefinition();
        }

        @Override
        protected boolean setProperty(RoundRobinLoadBalancerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "route-builder",
                    "routeBuilder"
            },
            inline = true,
            types = org.apache.camel.model.RouteBuilderDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Route Builder",
            description = "To refer to a Java org.apache.camel.builder.RouteBuilder instance to use.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ref", type = "string", required = true, description = "Reference to the route builder instance", displayName = "Ref")
            }
    )
    public static class RouteBuilderDefinitionDeserializer extends YamlDeserializerBase<RouteBuilderDefinition> {
        public RouteBuilderDefinitionDeserializer() {
            super(RouteBuilderDefinition.class);
        }

        @Override
        protected RouteBuilderDefinition newInstance() {
            return new RouteBuilderDefinition();
        }

        @Override
        protected RouteBuilderDefinition newInstance(String value) {
            return new RouteBuilderDefinition(value);
        }

        @Override
        protected boolean setProperty(RouteBuilderDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "route-configuration-context-ref",
                    "routeConfigurationContextRef"
            },
            inline = true,
            types = org.apache.camel.model.RouteConfigurationContextRefDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Route Configuration Context Ref",
            description = "To refer to an XML file with route configuration defined using the xml-dsl",
            deprecated = false,
            properties = @YamlProperty(name = "ref", type = "string", required = true, description = "Reference to the route templates in the xml dsl", displayName = "Ref")
    )
    public static class RouteConfigurationContextRefDefinitionDeserializer extends YamlDeserializerBase<RouteConfigurationContextRefDefinition> {
        public RouteConfigurationContextRefDefinitionDeserializer() {
            super(RouteConfigurationContextRefDefinition.class);
        }

        @Override
        protected RouteConfigurationContextRefDefinition newInstance() {
            return new RouteConfigurationContextRefDefinition();
        }

        @Override
        protected RouteConfigurationContextRefDefinition newInstance(String value) {
            return new RouteConfigurationContextRefDefinition(value);
        }

        @Override
        protected boolean setProperty(RouteConfigurationContextRefDefinition target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "route-context-ref",
                    "routeContextRef"
            },
            inline = true,
            types = org.apache.camel.model.RouteContextRefDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Route Context Ref",
            description = "To refer to an XML file with routes defined using the xml-dsl",
            deprecated = false,
            properties = @YamlProperty(name = "ref", type = "string", required = true, description = "Reference to the routes in the xml dsl", displayName = "Ref")
    )
    public static class RouteContextRefDefinitionDeserializer extends YamlDeserializerBase<RouteContextRefDefinition> {
        public RouteContextRefDefinitionDeserializer() {
            super(RouteContextRefDefinition.class);
        }

        @Override
        protected RouteContextRefDefinition newInstance() {
            return new RouteContextRefDefinition();
        }

        @Override
        protected RouteContextRefDefinition newInstance(String value) {
            return new RouteContextRefDefinition(value);
        }

        @Override
        protected boolean setProperty(RouteContextRefDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "route",
            inline = true,
            types = org.apache.camel.model.RouteDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Route",
            description = "A Camel route",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class RouteDefinitionDeserializer extends YamlDeserializerBase<RouteDefinition> {
        public RouteDefinitionDeserializer() {
            super(RouteDefinition.class);
        }

        @Override
        protected RouteDefinition newInstance() {
            return new RouteDefinition();
        }

        @Override
        protected RouteDefinition newInstance(String value) {
            return new RouteDefinition(value);
        }

        @Override
        protected boolean setProperty(RouteDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "template-parameter",
                    "templateParameter"
            },
            types = org.apache.camel.model.RouteTemplateParameterDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Template Parameter",
            description = "A route template parameter",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "default-value", type = "string", description = "Default value of the parameter. If a default value is provided then the parameter is implied not to be required.", displayName = "Default Value"),
                    @YamlProperty(name = "description", type = "string", description = "Description of the parameter", displayName = "Description"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "The name of the parameter", displayName = "Name"),
                    @YamlProperty(name = "required", type = "boolean", description = "Whether the parameter is required or not. A parameter is required unless this option is set to false or a default value has been configured.", displayName = "Required")
            }
    )
    public static class RouteTemplateParameterDefinitionDeserializer extends YamlDeserializerBase<RouteTemplateParameterDefinition> {
        public RouteTemplateParameterDefinitionDeserializer() {
            super(RouteTemplateParameterDefinition.class);
        }

        @Override
        protected RouteTemplateParameterDefinition newInstance() {
            return new RouteTemplateParameterDefinition();
        }

        @Override
        protected boolean setProperty(RouteTemplateParameterDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "default-value": {
                    String val = asText(node);
                    target.setDefaultValue(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "required": {
                    String val = asText(node);
                    target.setRequired(java.lang.Boolean.valueOf(val));
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "routing-slip",
                    "routingSlip"
            },
            inline = true,
            types = org.apache.camel.model.RoutingSlipDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Routing Slip",
            description = "Routes a message through a series of steps that are pre-determined (the slip)",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "cache-size", type = "number", description = "Sets the maximum size used by the org.apache.camel.spi.ProducerCache which is used to cache and reuse producers when using this routing slip, when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.", displayName = "Cache Size"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to define the routing slip, which defines which endpoints to route the message in a pipeline style. Notice the expression is evaluated once, if you want a more dynamic style, then the dynamic router eip is a better choice.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-endpoints", type = "boolean", description = "Ignore the invalidate endpoint exception when try to create a producer with that endpoint", displayName = "Ignore Invalid Endpoints"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "uri-delimiter", type = "string", defaultValue = ",", description = "Sets the uri delimiter to use", displayName = "Uri Delimiter")
            }
    )
    public static class RoutingSlipDefinitionDeserializer extends YamlDeserializerBase<RoutingSlipDefinition> {
        public RoutingSlipDefinitionDeserializer() {
            super(RoutingSlipDefinition.class);
        }

        @Override
        protected RoutingSlipDefinition newInstance() {
            return new RoutingSlipDefinition();
        }

        @Override
        protected RoutingSlipDefinition newInstance(String value) {
            return new RoutingSlipDefinition(value);
        }

        @Override
        protected boolean setProperty(RoutingSlipDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "cache-size": {
                    String val = asText(node);
                    target.setCacheSize(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "ignore-invalid-endpoints": {
                    String val = asText(node);
                    target.setIgnoreInvalidEndpoints(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "uri-delimiter": {
                    String val = asText(node);
                    target.setUriDelimiter(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "rss",
            types = org.apache.camel.model.dataformat.RssDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "RSS",
            description = "Transform from ROME SyndFeed Java Objects to XML and vice-versa.",
            deprecated = false,
            properties = @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
    )
    public static class RssDataFormatDeserializer extends YamlDeserializerBase<RssDataFormat> {
        public RssDataFormatDeserializer() {
            super(RssDataFormat.class);
        }

        @Override
        protected RssDataFormat newInstance() {
            return new RssDataFormat();
        }

        @Override
        protected boolean setProperty(RssDataFormat target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            inline = true,
            types = org.apache.camel.model.SagaActionUriDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            properties = {
                    @YamlProperty(name = "description", type = "string"),
                    @YamlProperty(name = "disabled", type = "boolean"),
                    @YamlProperty(name = "id", type = "string"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "parameters", type = "object"),
                    @YamlProperty(name = "uri", type = "string", required = true)
            }
    )
    public static class SagaActionUriDefinitionDeserializer extends YamlDeserializerEndpointAwareBase<SagaActionUriDefinition> {
        public SagaActionUriDefinitionDeserializer() {
            super(SagaActionUriDefinition.class);
        }

        @Override
        protected SagaActionUriDefinition newInstance() {
            return new SagaActionUriDefinition();
        }

        @Override
        protected SagaActionUriDefinition newInstance(String value) {
            return new SagaActionUriDefinition(value);
        }

        @Override
        protected void setEndpointUri(CamelContext camelContext, Node node,
                SagaActionUriDefinition target, Map<String, Object> parameters) {
            target.setUri(org.apache.camel.dsl.yaml.common.YamlSupport.createEndpointUri(camelContext, node, target.getUri(), parameters));
        }

        @Override
        protected boolean setProperty(SagaActionUriDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "saga",
            types = org.apache.camel.model.SagaDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Saga",
            description = "Enables Sagas on the route",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "compensation", type = "object:org.apache.camel.model.SagaActionUriDefinition", description = "The compensation endpoint URI that must be called to compensate all changes done in the route. The route corresponding to the compensation URI must perform compensation and complete without error. If errors occur during compensation, the saga service may call again the compensation URI to retry.", displayName = "Compensation"),
                    @YamlProperty(name = "completion", type = "object:org.apache.camel.model.SagaActionUriDefinition", description = "The completion endpoint URI that will be called when the Saga is completed successfully. The route corresponding to the completion URI must perform completion tasks and terminate without error. If errors occur during completion, the saga service may call again the completion URI to retry.", displayName = "Completion"),
                    @YamlProperty(name = "completion-mode", type = "enum:AUTO,MANUAL", defaultValue = "AUTO", description = "Determine how the saga should be considered complete. When set to AUTO, the saga is completed when the exchange that initiates the saga is processed successfully, or compensated when it completes exceptionally. When set to MANUAL, the user must complete or compensate the saga using the saga:complete or saga:compensate endpoints.", displayName = "Completion Mode"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "option", type = "array:org.apache.camel.model.PropertyExpressionDefinition", description = "Allows to save properties of the current exchange in order to re-use them in a compensation/completion callback route. Options are usually helpful e.g. to store and retrieve identifiers of objects that should be deleted in compensating actions. Option values will be transformed into input headers of the compensation/completion exchange.", displayName = "Option"),
                    @YamlProperty(name = "propagation", type = "enum:REQUIRED,REQUIRES_NEW,MANDATORY,SUPPORTS,NOT_SUPPORTED,NEVER", defaultValue = "REQUIRED", description = "Set the Saga propagation mode (REQUIRED, REQUIRES_NEW, MANDATORY, SUPPORTS, NOT_SUPPORTED, NEVER).", displayName = "Propagation"),
                    @YamlProperty(name = "saga-service", type = "string", description = "Refers to the id to lookup in the registry for the specific CamelSagaService to use.", displayName = "Saga Service"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "timeout", type = "string", description = "Set the maximum amount of time for the Saga. After the timeout is expired, the saga will be compensated automatically (unless a different decision has been taken in the meantime).", displayName = "Timeout")
            }
    )
    public static class SagaDefinitionDeserializer extends YamlDeserializerBase<SagaDefinition> {
        public SagaDefinitionDeserializer() {
            super(SagaDefinition.class);
        }

        @Override
        protected SagaDefinition newInstance() {
            return new SagaDefinition();
        }

        @Override
        protected boolean setProperty(SagaDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "compensation": {
                    org.apache.camel.model.SagaActionUriDefinition val = asType(node, org.apache.camel.model.SagaActionUriDefinition.class);
                    target.setCompensation(val);
                    break;
                }
                case "completion": {
                    org.apache.camel.model.SagaActionUriDefinition val = asType(node, org.apache.camel.model.SagaActionUriDefinition.class);
                    target.setCompletion(val);
                    break;
                }
                case "completion-mode": {
                    String val = asText(node);
                    target.setCompletionMode(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "option": {
                    java.util.List<org.apache.camel.model.PropertyExpressionDefinition> val = asFlatList(node, org.apache.camel.model.PropertyExpressionDefinition.class);
                    target.setOptions(val);
                    break;
                }
                case "propagation": {
                    String val = asText(node);
                    target.setPropagation(val);
                    break;
                }
                case "saga-service": {
                    String val = asText(node);
                    target.setSagaService(val);
                    break;
                }
                case "timeout": {
                    String val = asText(node);
                    target.setTimeout(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "sample",
            inline = true,
            types = org.apache.camel.model.SamplingDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Sample",
            description = "Extract a sample of the messages passing through a route",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "message-frequency", type = "number", description = "Sets the sample message count which only a single Exchange will pass through after this many received.", displayName = "Message Frequency"),
                    @YamlProperty(name = "sample-period", type = "string", defaultValue = "1000", description = "Sets the sample period during which only a single Exchange will pass through.", displayName = "Sample Period")
            }
    )
    public static class SamplingDefinitionDeserializer extends YamlDeserializerBase<SamplingDefinition> {
        public SamplingDefinitionDeserializer() {
            super(SamplingDefinition.class);
        }

        @Override
        protected SamplingDefinition newInstance() {
            return new SamplingDefinition();
        }

        @Override
        protected SamplingDefinition newInstance(String value) {
            return new SamplingDefinition(value);
        }

        @Override
        protected boolean setProperty(SamplingDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "message-frequency": {
                    String val = asText(node);
                    target.setMessageFrequency(val);
                    break;
                }
                case "sample-period": {
                    String val = asText(node);
                    target.setSamplePeriod(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "script",
            types = org.apache.camel.model.ScriptDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Script",
            description = "Executes a script from a language which does not change the message body.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to return the transformed message body (the new message body to use)", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean")
            }
    )
    public static class ScriptDefinitionDeserializer extends YamlDeserializerBase<ScriptDefinition> {
        public ScriptDefinitionDeserializer() {
            super(ScriptDefinition.class);
        }

        @Override
        protected ScriptDefinition newInstance() {
            return new ScriptDefinition();
        }

        @Override
        protected boolean setProperty(ScriptDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "security",
            types = org.apache.camel.model.rest.SecurityDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Rest Security",
            description = "Rest security definition",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "key", type = "string", required = true, description = "Key used to refer to this security definition", displayName = "Key"),
                    @YamlProperty(name = "scopes", type = "string", description = "The scopes to allow (separate multiple scopes by comma)", displayName = "Scopes")
            }
    )
    public static class SecurityDefinitionDeserializer extends YamlDeserializerBase<SecurityDefinition> {
        public SecurityDefinitionDeserializer() {
            super(SecurityDefinition.class);
        }

        @Override
        protected SecurityDefinition newInstance() {
            return new SecurityDefinition();
        }

        @Override
        protected boolean setProperty(SecurityDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "key": {
                    String val = asText(node);
                    target.setKey(val);
                    break;
                }
                case "scopes": {
                    String val = asText(node);
                    target.setScopes(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "service-call-configuration",
                    "serviceCallConfiguration"
            },
            types = org.apache.camel.model.cloud.ServiceCallConfigurationDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Service Call Configuration",
            description = "Remote service call configuration",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "blacklist-service-filter", type = "object:org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "caching-service-discovery", type = "object:org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "combined-service-discovery", type = "object:org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "combined-service-filter", type = "object:org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "component", type = "string", defaultValue = "http", description = "The component to use.", displayName = "Component"),
                    @YamlProperty(name = "consul-service-discovery", type = "object:org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "custom-service-filter", type = "object:org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "default-load-balancer", type = "object:org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration", oneOf = "loadBalancerConfiguration"),
                    @YamlProperty(name = "dns-service-discovery", type = "object:org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.cloud.ServiceCallExpressionConfiguration", description = "Configures the Expression using the given configuration.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "expression-ref", type = "string", description = "Set a reference to a custom Expression to use.", displayName = "Expression Ref"),
                    @YamlProperty(name = "healthy-service-filter", type = "object:org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "kubernetes-service-discovery", type = "object:org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "load-balancer-ref", type = "string", description = "Sets a reference to a custom ServiceLoadBalancer to use.", displayName = "Load Balancer Ref"),
                    @YamlProperty(name = "pass-through-service-filter", type = "object:org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "pattern", type = "enum:InOnly,InOut", description = "Sets the optional ExchangePattern used to invoke this endpoint", displayName = "Pattern"),
                    @YamlProperty(name = "service-chooser-ref", type = "string", description = "Sets a reference to a custom ServiceChooser to use.", displayName = "Service Chooser Ref"),
                    @YamlProperty(name = "service-discovery-ref", type = "string", description = "Sets a reference to a custom ServiceDiscovery to use.", displayName = "Service Discovery Ref"),
                    @YamlProperty(name = "service-filter-ref", type = "string", description = "Sets a reference to a custom ServiceFilter to use.", displayName = "Service Filter Ref"),
                    @YamlProperty(name = "static-service-discovery", type = "object:org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "uri", type = "string", description = "The uri of the endpoint to send to. The uri can be dynamic computed using the simple language expression.", displayName = "Uri"),
                    @YamlProperty(name = "zookeeper-service-discovery", type = "object:org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration")
            }
    )
    public static class ServiceCallConfigurationDefinitionDeserializer extends YamlDeserializerBase<ServiceCallConfigurationDefinition> {
        public ServiceCallConfigurationDefinitionDeserializer() {
            super(ServiceCallConfigurationDefinition.class);
        }

        @Override
        protected ServiceCallConfigurationDefinition newInstance() {
            return new ServiceCallConfigurationDefinition();
        }

        @Override
        protected boolean setProperty(ServiceCallConfigurationDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "component": {
                    String val = asText(node);
                    target.setComponent(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.cloud.ServiceCallExpressionConfiguration val = asType(node, org.apache.camel.model.cloud.ServiceCallExpressionConfiguration.class);
                    target.setExpressionConfiguration(val);
                    break;
                }
                case "expression-ref": {
                    String val = asText(node);
                    target.setExpressionRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "default-load-balancer": {
                    org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration val = asType(node, org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration.class);
                    target.setLoadBalancerConfiguration(val);
                    break;
                }
                case "load-balancer-ref": {
                    String val = asText(node);
                    target.setLoadBalancerRef(val);
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "service-chooser-ref": {
                    String val = asText(node);
                    target.setServiceChooserRef(val);
                    break;
                }
                case "service-discovery-configuration": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "caching-service-discovery": {
                    org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "combined-service-discovery": {
                    org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "consul-service-discovery": {
                    org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "dns-service-discovery": {
                    org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "kubernetes-service-discovery": {
                    org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "static-service-discovery": {
                    org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "zookeeper-service-discovery": {
                    org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "service-discovery-ref": {
                    String val = asText(node);
                    target.setServiceDiscoveryRef(val);
                    break;
                }
                case "service-filter-configuration": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "blacklist-service-filter": {
                    org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "combined-service-filter": {
                    org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "custom-service-filter": {
                    org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "healthy-service-filter": {
                    org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "pass-through-service-filter": {
                    org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "service-filter-ref": {
                    String val = asText(node);
                    target.setServiceFilterRef(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "service-call",
                    "serviceCall"
            },
            inline = true,
            types = org.apache.camel.model.cloud.ServiceCallDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Service Call",
            description = "To call remote services",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "blacklist-service-filter", type = "object:org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "caching-service-discovery", type = "object:org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "combined-service-discovery", type = "object:org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "combined-service-filter", type = "object:org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "component", type = "string", defaultValue = "http", description = "The component to use.", displayName = "Component"),
                    @YamlProperty(name = "configuration-ref", type = "string", description = "Refers to a ServiceCall configuration to use", displayName = "Configuration Ref"),
                    @YamlProperty(name = "consul-service-discovery", type = "object:org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "custom-service-filter", type = "object:org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "default-load-balancer", type = "object:org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration", oneOf = "loadBalancerConfiguration"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "dns-service-discovery", type = "object:org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.cloud.ServiceCallExpressionConfiguration", description = "Configures the Expression using the given configuration.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "expression-ref", type = "string", description = "Set a reference to a custom Expression to use.", displayName = "Expression Ref"),
                    @YamlProperty(name = "healthy-service-filter", type = "object:org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "kubernetes-service-discovery", type = "object:org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "load-balancer-ref", type = "string", description = "Sets a reference to a custom ServiceLoadBalancer to use.", displayName = "Load Balancer Ref"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "Sets the name of the service to use", displayName = "Name"),
                    @YamlProperty(name = "pass-through-service-filter", type = "object:org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration", oneOf = "serviceFilterConfiguration"),
                    @YamlProperty(name = "pattern", type = "enum:InOnly,InOut", description = "Sets the optional ExchangePattern used to invoke this endpoint", displayName = "Pattern"),
                    @YamlProperty(name = "service-chooser-ref", type = "string", description = "Sets a reference to a custom ServiceChooser to use.", displayName = "Service Chooser Ref"),
                    @YamlProperty(name = "service-discovery-ref", type = "string", description = "Sets a reference to a custom ServiceDiscovery to use.", displayName = "Service Discovery Ref"),
                    @YamlProperty(name = "service-filter-ref", type = "string", description = "Sets a reference to a custom ServiceFilter to use.", displayName = "Service Filter Ref"),
                    @YamlProperty(name = "static-service-discovery", type = "object:org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration"),
                    @YamlProperty(name = "uri", type = "string", description = "The uri of the endpoint to send to. The uri can be dynamic computed using the org.apache.camel.language.simple.SimpleLanguage expression.", displayName = "Uri"),
                    @YamlProperty(name = "zookeeper-service-discovery", type = "object:org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration", oneOf = "serviceDiscoveryConfiguration")
            }
    )
    public static class ServiceCallDefinitionDeserializer extends YamlDeserializerBase<ServiceCallDefinition> {
        public ServiceCallDefinitionDeserializer() {
            super(ServiceCallDefinition.class);
        }

        @Override
        protected ServiceCallDefinition newInstance() {
            return new ServiceCallDefinition();
        }

        @Override
        protected ServiceCallDefinition newInstance(String value) {
            return new ServiceCallDefinition(value);
        }

        @Override
        protected boolean setProperty(ServiceCallDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "component": {
                    String val = asText(node);
                    target.setComponent(val);
                    break;
                }
                case "configuration-ref": {
                    String val = asText(node);
                    target.setConfigurationRef(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.cloud.ServiceCallExpressionConfiguration val = asType(node, org.apache.camel.model.cloud.ServiceCallExpressionConfiguration.class);
                    target.setExpressionConfiguration(val);
                    break;
                }
                case "expression-ref": {
                    String val = asText(node);
                    target.setExpressionRef(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "default-load-balancer": {
                    org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration val = asType(node, org.apache.camel.model.cloud.DefaultServiceCallServiceLoadBalancerConfiguration.class);
                    target.setLoadBalancerConfiguration(val);
                    break;
                }
                case "load-balancer-ref": {
                    String val = asText(node);
                    target.setLoadBalancerRef(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "service-chooser-ref": {
                    String val = asText(node);
                    target.setServiceChooserRef(val);
                    break;
                }
                case "service-discovery-configuration": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "caching-service-discovery": {
                    org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.CachingServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "combined-service-discovery": {
                    org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.CombinedServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "consul-service-discovery": {
                    org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.ConsulServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "dns-service-discovery": {
                    org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.DnsServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "kubernetes-service-discovery": {
                    org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.KubernetesServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "static-service-discovery": {
                    org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "zookeeper-service-discovery": {
                    org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration val = asType(node, org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration.class);
                    target.setServiceDiscoveryConfiguration(val);
                    break;
                }
                case "service-discovery-ref": {
                    String val = asText(node);
                    target.setServiceDiscoveryRef(val);
                    break;
                }
                case "service-filter-configuration": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "blacklist-service-filter": {
                    org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.BlacklistServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "combined-service-filter": {
                    org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.CombinedServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "custom-service-filter": {
                    org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.CustomServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "healthy-service-filter": {
                    org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.HealthyServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "pass-through-service-filter": {
                    org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration val = asType(node, org.apache.camel.model.cloud.PassThroughServiceCallServiceFilterConfiguration.class);
                    target.setServiceFilterConfiguration(val);
                    break;
                }
                case "service-filter-ref": {
                    String val = asText(node);
                    target.setServiceFilterRef(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "service-expression",
                    "serviceExpression"
            },
            types = org.apache.camel.model.cloud.ServiceCallExpressionConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Service Expression",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "expression-type", type = "object:org.apache.camel.model.language.ExpressionDefinition"),
                    @YamlProperty(name = "host-header", type = "string", defaultValue = "CamelServiceCallServiceHost", description = "The header that holds the service host information, default ServiceCallConstants.SERVICE_HOST", displayName = "Host Header"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "port-header", type = "string", defaultValue = "CamelServiceCallServicePort", description = "The header that holds the service port information, default ServiceCallConstants.SERVICE_PORT", displayName = "Port Header"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class ServiceCallExpressionConfigurationDeserializer extends YamlDeserializerBase<ServiceCallExpressionConfiguration> {
        public ServiceCallExpressionConfigurationDeserializer() {
            super(ServiceCallExpressionConfiguration.class);
        }

        @Override
        protected ServiceCallExpressionConfiguration newInstance() {
            return new ServiceCallExpressionConfiguration();
        }

        @Override
        protected boolean setProperty(ServiceCallExpressionConfiguration target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression-type": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpressionType(val);
                    break;
                }
                case "host-header": {
                    String val = asText(node);
                    target.setHostHeader(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "port-header": {
                    String val = asText(node);
                    target.setPortHeader(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "service-chooser-configuration",
                    "serviceChooserConfiguration"
            },
            types = org.apache.camel.model.cloud.ServiceCallServiceChooserConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Service Chooser Configuration",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class ServiceCallServiceChooserConfigurationDeserializer extends YamlDeserializerBase<ServiceCallServiceChooserConfiguration> {
        public ServiceCallServiceChooserConfigurationDeserializer() {
            super(ServiceCallServiceChooserConfiguration.class);
        }

        @Override
        protected ServiceCallServiceChooserConfiguration newInstance() {
            return new ServiceCallServiceChooserConfiguration();
        }

        @Override
        protected boolean setProperty(ServiceCallServiceChooserConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "service-discovery-configuration",
                    "serviceDiscoveryConfiguration"
            },
            types = org.apache.camel.model.cloud.ServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Service Discovery Configuration",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class ServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<ServiceCallServiceDiscoveryConfiguration> {
        public ServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(ServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected ServiceCallServiceDiscoveryConfiguration newInstance() {
            return new ServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(ServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "service-filter-configuration",
                    "serviceFilterConfiguration"
            },
            types = org.apache.camel.model.cloud.ServiceCallServiceFilterConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Service Filter Configuration",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class ServiceCallServiceFilterConfigurationDeserializer extends YamlDeserializerBase<ServiceCallServiceFilterConfiguration> {
        public ServiceCallServiceFilterConfigurationDeserializer() {
            super(ServiceCallServiceFilterConfiguration.class);
        }

        @Override
        protected ServiceCallServiceFilterConfiguration newInstance() {
            return new ServiceCallServiceFilterConfiguration();
        }

        @Override
        protected boolean setProperty(ServiceCallServiceFilterConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "load-balancer-configuration",
                    "loadBalancerConfiguration"
            },
            types = org.apache.camel.model.cloud.ServiceCallServiceLoadBalancerConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Load Balancer Configuration",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties")
            }
    )
    public static class ServiceCallServiceLoadBalancerConfigurationDeserializer extends YamlDeserializerBase<ServiceCallServiceLoadBalancerConfiguration> {
        public ServiceCallServiceLoadBalancerConfigurationDeserializer() {
            super(ServiceCallServiceLoadBalancerConfiguration.class);
        }

        @Override
        protected ServiceCallServiceLoadBalancerConfiguration newInstance() {
            return new ServiceCallServiceLoadBalancerConfiguration();
        }

        @Override
        protected boolean setProperty(ServiceCallServiceLoadBalancerConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "set-body",
                    "setBody"
            },
            types = org.apache.camel.model.SetBodyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Set Body",
            description = "Sets the contents of the message body",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression that returns the new body to use", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean")
            }
    )
    public static class SetBodyDefinitionDeserializer extends YamlDeserializerBase<SetBodyDefinition> {
        public SetBodyDefinitionDeserializer() {
            super(SetBodyDefinition.class);
        }

        @Override
        protected SetBodyDefinition newInstance() {
            return new SetBodyDefinition();
        }

        @Override
        protected boolean setProperty(SetBodyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "set-exchange-pattern",
                    "setExchangePattern"
            },
            inline = true,
            types = org.apache.camel.model.SetExchangePatternDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Set Exchange Pattern",
            description = "Sets the exchange pattern on the message exchange",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "pattern", type = "enum:InOnly,InOut", description = "Sets the new exchange pattern of the Exchange to be used from this point forward", displayName = "Pattern")
            }
    )
    public static class SetExchangePatternDefinitionDeserializer extends YamlDeserializerBase<SetExchangePatternDefinition> {
        public SetExchangePatternDefinitionDeserializer() {
            super(SetExchangePatternDefinition.class);
        }

        @Override
        protected SetExchangePatternDefinition newInstance() {
            return new SetExchangePatternDefinition();
        }

        @Override
        protected SetExchangePatternDefinition newInstance(String value) {
            return new SetExchangePatternDefinition(value);
        }

        @Override
        protected boolean setProperty(SetExchangePatternDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "set-header",
                    "setHeader"
            },
            types = org.apache.camel.model.SetHeaderDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Set Header",
            description = "Sets the value of a message header",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to return the value of the header", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "Name of message header to set a new value The simple language can be used to define a dynamic evaluated header name to be used. Otherwise a constant name will be used.", displayName = "Name")
            }
    )
    public static class SetHeaderDefinitionDeserializer extends YamlDeserializerBase<SetHeaderDefinition> {
        public SetHeaderDefinitionDeserializer() {
            super(SetHeaderDefinition.class);
        }

        @Override
        protected SetHeaderDefinition newInstance() {
            return new SetHeaderDefinition();
        }

        @Override
        protected boolean setProperty(SetHeaderDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "set-property",
                    "setProperty"
            },
            types = org.apache.camel.model.SetPropertyDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Set Property",
            description = "Sets a named property on the message exchange",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to return the value of the message exchange property", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "name", type = "string", required = true, description = "Name of exchange property to set a new value. The simple language can be used to define a dynamic evaluated exchange property name to be used. Otherwise a constant name will be used.", displayName = "Name")
            }
    )
    public static class SetPropertyDefinitionDeserializer extends YamlDeserializerBase<SetPropertyDefinition> {
        public SetPropertyDefinitionDeserializer() {
            super(SetPropertyDefinition.class);
        }

        @Override
        protected SetPropertyDefinition newInstance() {
            return new SetPropertyDefinition();
        }

        @Override
        protected boolean setProperty(SetPropertyDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "simple",
            inline = true,
            types = org.apache.camel.model.language.SimpleExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Simple",
            description = "Evaluates a Camel simple expression.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class SimpleExpressionDeserializer extends YamlDeserializerBase<SimpleExpression> {
        public SimpleExpressionDeserializer() {
            super(SimpleExpression.class);
        }

        @Override
        protected SimpleExpression newInstance() {
            return new SimpleExpression();
        }

        @Override
        protected SimpleExpression newInstance(String value) {
            return new SimpleExpression(value);
        }

        @Override
        protected boolean setProperty(SimpleExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "soap",
            inline = true,
            types = org.apache.camel.model.dataformat.SoapDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "SOAP",
            description = "Marshal Java objects to SOAP messages and back.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "context-path", type = "string", required = true, description = "Package name where your JAXB classes are located.", displayName = "Context Path"),
                    @YamlProperty(name = "element-name-strategy-ref", type = "string", description = "Refers to an element strategy to lookup from the registry. An element name strategy is used for two purposes. The first is to find a xml element name for a given object and soap action when marshaling the object into a SOAP message. The second is to find an Exception class for a given soap fault name. The following three element strategy class name is provided out of the box. QNameStrategy - Uses a fixed qName that is configured on instantiation. Exception lookup is not supported TypeNameStrategy - Uses the name and namespace from the XMLType annotation of the given type. If no namespace is set then package-info is used. Exception lookup is not supported ServiceInterfaceStrategy - Uses information from a webservice interface to determine the type name and to find the exception class for a SOAP fault All three classes is located in the package name org.apache.camel.dataformat.soap.name If you have generated the web service stub code with cxf-codegen or a similar tool then you probably will want to use the ServiceInterfaceStrategy. In the case you have no annotated service interface you should use QNameStrategy or TypeNameStrategy.", displayName = "Element Name Strategy Ref"),
                    @YamlProperty(name = "encoding", type = "string", description = "To overrule and use a specific encoding", displayName = "Encoding"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "namespace-prefix-ref", type = "string", description = "When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes, such as ns2, ns3, ns4 etc. To control this mapping, Camel allows you to refer to a map which contains the desired mapping.", displayName = "Namespace Prefix Ref"),
                    @YamlProperty(name = "schema", type = "string", description = "To validate against an existing schema. Your can use the prefix classpath:, file: or http: to specify how the resource should be resolved. You can separate multiple schema files by using the ',' character.", displayName = "Schema"),
                    @YamlProperty(name = "version", type = "enum:1.1,1.2", defaultValue = "1.1", description = "SOAP version should either be 1.1 or 1.2. Is by default 1.1", displayName = "Version")
            }
    )
    public static class SoapDataFormatDeserializer extends YamlDeserializerBase<SoapDataFormat> {
        public SoapDataFormatDeserializer() {
            super(SoapDataFormat.class);
        }

        @Override
        protected SoapDataFormat newInstance() {
            return new SoapDataFormat();
        }

        @Override
        protected SoapDataFormat newInstance(String value) {
            return new SoapDataFormat(value);
        }

        @Override
        protected boolean setProperty(SoapDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "context-path": {
                    String val = asText(node);
                    target.setContextPath(val);
                    break;
                }
                case "element-name-strategy-ref": {
                    String val = asText(node);
                    target.setElementNameStrategyRef(val);
                    break;
                }
                case "encoding": {
                    String val = asText(node);
                    target.setEncoding(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "namespace-prefix-ref": {
                    String val = asText(node);
                    target.setNamespacePrefixRef(val);
                    break;
                }
                case "schema": {
                    String val = asText(node);
                    target.setSchema(val);
                    break;
                }
                case "version": {
                    String val = asText(node);
                    target.setVersion(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "sort",
            types = org.apache.camel.model.SortDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Sort",
            description = "Sorts the contents of the message",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "comparator", type = "string", description = "Sets the comparator to use for sorting", displayName = "Comparator"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Optional expression to sort by something else than the message body", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean")
            }
    )
    public static class SortDefinitionDeserializer extends YamlDeserializerBase<SortDefinition> {
        public SortDefinitionDeserializer() {
            super(SortDefinition.class);
        }

        @Override
        protected SortDefinition newInstance() {
            return new SortDefinition();
        }

        @Override
        protected boolean setProperty(SortDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "comparator": {
                    String val = asText(node);
                    target.setComparator(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "spel",
            inline = true,
            types = org.apache.camel.model.language.SpELExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "SpEL",
            description = "Evaluates a Spring expression (SpEL).",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class SpELExpressionDeserializer extends YamlDeserializerBase<SpELExpression> {
        public SpELExpressionDeserializer() {
            super(SpELExpression.class);
        }

        @Override
        protected SpELExpression newInstance() {
            return new SpELExpression();
        }

        @Override
        protected SpELExpression newInstance(String value) {
            return new SpELExpression(value);
        }

        @Override
        protected boolean setProperty(SpELExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "split",
            types = org.apache.camel.model.SplitDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Split",
            description = "Splits a single message into many sub-messages.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "aggregation-strategy", type = "string", description = "Sets a reference to the AggregationStrategy to be used to assemble the replies from the split messages, into a single outgoing message from the Splitter. By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy", displayName = "Aggregation Strategy"),
                    @YamlProperty(name = "aggregation-strategy-method-allow-null", type = "boolean", description = "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy", displayName = "Aggregation Strategy Method Allow Null"),
                    @YamlProperty(name = "aggregation-strategy-method-name", type = "string", description = "This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.", displayName = "Aggregation Strategy Method Name"),
                    @YamlProperty(name = "delimiter", type = "string", defaultValue = ",", description = "Delimiter used in splitting messages. Can be turned off using the value false. The default value is ,", displayName = "Delimiter"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "executor-service", type = "string", description = "To use a custom Thread Pool to be used for parallel processing. Notice if you set this option, then parallel processing is automatically implied, and you do not have to enable that option as well.", displayName = "Executor Service"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression of how to split the message body, such as as-is, using a tokenizer, or using a xpath.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "on-prepare", type = "string", description = "Uses the Processor when preparing the org.apache.camel.Exchange to be sent. This can be used to deep-clone messages that should be sent, or any custom logic needed before the exchange is sent.", displayName = "On Prepare"),
                    @YamlProperty(name = "parallel-aggregate", type = "boolean", description = "If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.", displayName = "Parallel Aggregate"),
                    @YamlProperty(name = "parallel-processing", type = "boolean", description = "If enabled then processing each split messages occurs concurrently. Note the caller thread will still wait until all messages has been fully processed, before it continues. It's only processing the sub messages from the splitter which happens concurrently. When parallel processing is enabled, then the Camel routing engin will continue processing using last used thread from the parallel thread pool. However, if you want to use the original thread that called the splitter, then make sure to enable the synchronous option as well.", displayName = "Parallel Processing"),
                    @YamlProperty(name = "share-unit-of-work", type = "boolean", description = "Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Splitter will by default not share unit of work between the parent exchange and each split exchange. This means each split exchange has its own individual unit of work.", displayName = "Share Unit Of Work"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition"),
                    @YamlProperty(name = "stop-on-exception", type = "boolean", description = "Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the splitter will stop further processing. This is the same behavior as in pipeline, which is used by the routing engine. The default behavior is to not stop but continue processing till the end", displayName = "Stop On Exception"),
                    @YamlProperty(name = "streaming", type = "boolean", description = "When in streaming mode, then the splitter splits the original message on-demand, and each split message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the org.apache.camel.Exchange#SPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the split messages in memory and therefore requires more memory. The total size is provided in the org.apache.camel.Exchange#SPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, e.g. in the order they come back. If disabled, Camel will process replies in the same order as the messages was split.", displayName = "Streaming"),
                    @YamlProperty(name = "synchronous", type = "boolean", description = "Sets whether synchronous processing should be strictly used. When enabled then the same thread is used to continue routing after the split is complete, even if parallel processing is enabled.", displayName = "Synchronous"),
                    @YamlProperty(name = "timeout", type = "string", defaultValue = "0", description = "Sets a total timeout specified in millis, when using parallel processing. If the Splitter hasn't been able to split and process all the sub messages within the given timeframe, then the timeout triggers and the Splitter breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.", displayName = "Timeout")
            }
    )
    public static class SplitDefinitionDeserializer extends YamlDeserializerBase<SplitDefinition> {
        public SplitDefinitionDeserializer() {
            super(SplitDefinition.class);
        }

        @Override
        protected SplitDefinition newInstance() {
            return new SplitDefinition();
        }

        @Override
        protected boolean setProperty(SplitDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "aggregation-strategy": {
                    String val = asText(node);
                    target.setAggregationStrategy(val);
                    break;
                }
                case "aggregation-strategy-method-allow-null": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodAllowNull(val);
                    break;
                }
                case "aggregation-strategy-method-name": {
                    String val = asText(node);
                    target.setAggregationStrategyMethodName(val);
                    break;
                }
                case "delimiter": {
                    String val = asText(node);
                    target.setDelimiter(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "on-prepare": {
                    String val = asText(node);
                    target.setOnPrepare(val);
                    break;
                }
                case "parallel-aggregate": {
                    String val = asText(node);
                    target.setParallelAggregate(val);
                    break;
                }
                case "parallel-processing": {
                    String val = asText(node);
                    target.setParallelProcessing(val);
                    break;
                }
                case "share-unit-of-work": {
                    String val = asText(node);
                    target.setShareUnitOfWork(val);
                    break;
                }
                case "stop-on-exception": {
                    String val = asText(node);
                    target.setStopOnException(val);
                    break;
                }
                case "streaming": {
                    String val = asText(node);
                    target.setStreaming(val);
                    break;
                }
                case "synchronous": {
                    String val = asText(node);
                    target.setSynchronous(val);
                    break;
                }
                case "timeout": {
                    String val = asText(node);
                    target.setTimeout(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "spring-transaction-error-handler",
                    "springTransactionErrorHandler"
            },
            types = org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Spring Transaction Error Handler",
            description = "Spring based transactional error handler (requires camel-spring).",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "executor-service-ref", type = "string", description = "Sets a reference to a thread pool to be used by the error handler", displayName = "Executor Service Ref"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "ERROR", description = "Logging level to use by error handler", displayName = "Level"),
                    @YamlProperty(name = "log-name", type = "string", description = "Name of the logger to use by the error handler", displayName = "Log Name"),
                    @YamlProperty(name = "logger-ref", type = "string", description = "References to a logger to use as logger for the error handler", displayName = "Logger Ref"),
                    @YamlProperty(name = "on-exception-occurred-ref", type = "string", description = "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.", displayName = "On Exception Occurred Ref"),
                    @YamlProperty(name = "on-prepare-failure-ref", type = "string", description = "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.", displayName = "On Prepare Failure Ref"),
                    @YamlProperty(name = "on-redelivery-ref", type = "string", description = "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.", displayName = "On Redelivery Ref"),
                    @YamlProperty(name = "redelivery-policy", type = "object:org.apache.camel.model.RedeliveryPolicyDefinition", description = "Sets the redelivery settings", displayName = "Redelivery Policy"),
                    @YamlProperty(name = "redelivery-policy-ref", type = "string", description = "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.", displayName = "Redelivery Policy Ref"),
                    @YamlProperty(name = "retry-while-ref", type = "string", description = "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.", displayName = "Retry While Ref"),
                    @YamlProperty(name = "rollback-logging-level", type = "enum:TRACE,DEBUG,INFO,WARN,ERROR,OFF", defaultValue = "WARN", description = "Sets the logging level to use for logging transactional rollback. This option is default WARN.", displayName = "Rollback Logging Level"),
                    @YamlProperty(name = "transacted-policy-ref", type = "string", description = "The transacted policy to use that is configured for either Spring or JTA based transactions. If no policy has been configured then Camel will attempt to auto-discover.", displayName = "Transacted Policy Ref"),
                    @YamlProperty(name = "use-original-body", type = "boolean", description = "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Body"),
                    @YamlProperty(name = "use-original-message", type = "boolean", description = "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.", displayName = "Use Original Message")
            }
    )
    public static class SpringTransactionErrorHandlerDefinitionDeserializer extends YamlDeserializerBase<SpringTransactionErrorHandlerDefinition> {
        public SpringTransactionErrorHandlerDefinitionDeserializer() {
            super(SpringTransactionErrorHandlerDefinition.class);
        }

        @Override
        protected SpringTransactionErrorHandlerDefinition newInstance() {
            return new SpringTransactionErrorHandlerDefinition();
        }

        @Override
        protected boolean setProperty(SpringTransactionErrorHandlerDefinition target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "executor-service-ref": {
                    String val = asText(node);
                    target.setExecutorServiceRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "level": {
                    String val = asText(node);
                    target.setLevel(val);
                    break;
                }
                case "log-name": {
                    String val = asText(node);
                    target.setLogName(val);
                    break;
                }
                case "logger-ref": {
                    String val = asText(node);
                    target.setLoggerRef(val);
                    break;
                }
                case "on-exception-occurred-ref": {
                    String val = asText(node);
                    target.setOnExceptionOccurredRef(val);
                    break;
                }
                case "on-prepare-failure-ref": {
                    String val = asText(node);
                    target.setOnPrepareFailureRef(val);
                    break;
                }
                case "on-redelivery-ref": {
                    String val = asText(node);
                    target.setOnRedeliveryRef(val);
                    break;
                }
                case "redelivery-policy": {
                    org.apache.camel.model.RedeliveryPolicyDefinition val = asType(node, org.apache.camel.model.RedeliveryPolicyDefinition.class);
                    target.setRedeliveryPolicy(val);
                    break;
                }
                case "redelivery-policy-ref": {
                    String val = asText(node);
                    target.setRedeliveryPolicyRef(val);
                    break;
                }
                case "retry-while-ref": {
                    String val = asText(node);
                    target.setRetryWhileRef(val);
                    break;
                }
                case "rollback-logging-level": {
                    String val = asText(node);
                    target.setRollbackLoggingLevel(val);
                    break;
                }
                case "transacted-policy-ref": {
                    String val = asText(node);
                    target.setTransactedPolicyRef(val);
                    break;
                }
                case "use-original-body": {
                    String val = asText(node);
                    target.setUseOriginalBody(val);
                    break;
                }
                case "use-original-message": {
                    String val = asText(node);
                    target.setUseOriginalMessage(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "static-service-discovery",
                    "staticServiceDiscovery"
            },
            types = org.apache.camel.model.cloud.StaticServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Static Service Discovery",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "servers", type = "array:string", description = "Sets the server list. Each entry can be a list of servers separated by comma in the format: servicehost:port,servicehost2:port,servicehost3:port", displayName = "Servers")
            }
    )
    public static class StaticServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<StaticServiceCallServiceDiscoveryConfiguration> {
        public StaticServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(StaticServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected StaticServiceCallServiceDiscoveryConfiguration newInstance() {
            return new StaticServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(StaticServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "servers": {
                    java.util.List<String> val = asStringList(node);
                    target.setServers(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "step",
            types = org.apache.camel.model.StepDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Step",
            description = "Routes the message to a sequence of processors which is grouped together as one logical name",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class StepDefinitionDeserializer extends YamlDeserializerBase<StepDefinition> {
        public StepDefinitionDeserializer() {
            super(StepDefinition.class);
        }

        @Override
        protected StepDefinition newInstance() {
            return new StepDefinition();
        }

        @Override
        protected boolean setProperty(StepDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "sticky",
            types = org.apache.camel.model.loadbalancer.StickyLoadBalancerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Sticky",
            description = "Sticky load balancing using an expression to calculate a correlation key to perform the sticky load balancing.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "correlation-expression", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "The correlation expression to use to calculate the correlation key", displayName = "Correlation Expression"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
            }
    )
    public static class StickyLoadBalancerDefinitionDeserializer extends YamlDeserializerBase<StickyLoadBalancerDefinition> {
        public StickyLoadBalancerDefinitionDeserializer() {
            super(StickyLoadBalancerDefinition.class);
        }

        @Override
        protected StickyLoadBalancerDefinition newInstance() {
            return new StickyLoadBalancerDefinition();
        }

        @Override
        protected boolean setProperty(StickyLoadBalancerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "correlation-expression": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setCorrelationExpression(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "stop",
            types = org.apache.camel.model.StopDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Stop",
            description = "Stops the processing of the current message",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean")
            }
    )
    public static class StopDefinitionDeserializer extends YamlDeserializerBase<StopDefinition> {
        public StopDefinitionDeserializer() {
            super(StopDefinition.class);
        }

        @Override
        protected StopDefinition newInstance() {
            return new StopDefinition();
        }

        @Override
        protected boolean setProperty(StopDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "stream-config",
            types = org.apache.camel.model.config.StreamResequencerConfig.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Stream-config",
            description = "Configures stream-processing resequence eip.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "capacity", type = "number", defaultValue = "1000", description = "Sets the capacity of the resequencer inbound queue.", displayName = "Capacity"),
                    @YamlProperty(name = "comparator", type = "string", description = "To use a custom comparator as a org.apache.camel.processor.resequencer.ExpressionResultComparator type.", displayName = "Comparator"),
                    @YamlProperty(name = "delivery-attempt-interval", type = "string", defaultValue = "1000", description = "Sets the interval in milliseconds the stream resequencer will at most wait while waiting for condition of being able to deliver.", displayName = "Delivery Attempt Interval"),
                    @YamlProperty(name = "ignore-invalid-exchanges", type = "boolean", description = "Whether to ignore invalid exchanges", displayName = "Ignore Invalid Exchanges"),
                    @YamlProperty(name = "reject-old", type = "boolean", description = "If true, throws an exception when messages older than the last delivered message are processed", displayName = "Reject Old"),
                    @YamlProperty(name = "timeout", type = "string", defaultValue = "1000", description = "Sets minimum time (milliseconds) to wait for missing elements (messages).", displayName = "Timeout")
            }
    )
    public static class StreamResequencerConfigDeserializer extends YamlDeserializerBase<StreamResequencerConfig> {
        public StreamResequencerConfigDeserializer() {
            super(StreamResequencerConfig.class);
        }

        @Override
        protected StreamResequencerConfig newInstance() {
            return new StreamResequencerConfig();
        }

        @Override
        protected boolean setProperty(StreamResequencerConfig target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "capacity": {
                    String val = asText(node);
                    target.setCapacity(val);
                    break;
                }
                case "comparator": {
                    String val = asText(node);
                    target.setComparator(val);
                    break;
                }
                case "delivery-attempt-interval": {
                    String val = asText(node);
                    target.setDeliveryAttemptInterval(val);
                    break;
                }
                case "ignore-invalid-exchanges": {
                    String val = asText(node);
                    target.setIgnoreInvalidExchanges(val);
                    break;
                }
                case "reject-old": {
                    String val = asText(node);
                    target.setRejectOld(val);
                    break;
                }
                case "timeout": {
                    String val = asText(node);
                    target.setTimeout(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "swift-mt",
                    "swiftMt"
            },
            inline = true,
            types = org.apache.camel.model.dataformat.SwiftMtDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "SWIFT MT",
            description = "Encode and decode SWIFT MT messages.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "write-in-json", type = "boolean", description = "The flag indicating that messages must be marshalled in a JSON format.", displayName = "Write In Json")
            }
    )
    public static class SwiftMtDataFormatDeserializer extends YamlDeserializerBase<SwiftMtDataFormat> {
        public SwiftMtDataFormatDeserializer() {
            super(SwiftMtDataFormat.class);
        }

        @Override
        protected SwiftMtDataFormat newInstance() {
            return new SwiftMtDataFormat();
        }

        @Override
        protected SwiftMtDataFormat newInstance(String value) {
            return new SwiftMtDataFormat(value);
        }

        @Override
        protected boolean setProperty(SwiftMtDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "write-in-json": {
                    String val = asText(node);
                    target.setWriteInJson(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "swift-mx",
                    "swiftMx"
            },
            types = org.apache.camel.model.dataformat.SwiftMxDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "SWIFT MX",
            description = "Encode and decode SWIFT MX messages.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "read-config-ref", type = "string", description = "Refers to a specific configuration to use when unmarshalling an input stream to lookup from the registry.", displayName = "Read Config Ref"),
                    @YamlProperty(name = "read-message-id", type = "string", description = "The type of MX message to produce when unmarshalling an input stream. If not set, it will be automatically detected from the namespace used.", displayName = "Read Message Id"),
                    @YamlProperty(name = "write-config-ref", type = "string", description = "Refers to a specific configuration to use when marshalling a message to lookup from the registry.", displayName = "Write Config Ref"),
                    @YamlProperty(name = "write-in-json", type = "boolean", description = "The flag indicating that messages must be marshalled in a JSON format.", displayName = "Write In Json")
            }
    )
    public static class SwiftMxDataFormatDeserializer extends YamlDeserializerBase<SwiftMxDataFormat> {
        public SwiftMxDataFormatDeserializer() {
            super(SwiftMxDataFormat.class);
        }

        @Override
        protected SwiftMxDataFormat newInstance() {
            return new SwiftMxDataFormat();
        }

        @Override
        protected boolean setProperty(SwiftMxDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "read-config-ref": {
                    String val = asText(node);
                    target.setReadConfigRef(val);
                    break;
                }
                case "read-message-id": {
                    String val = asText(node);
                    target.setReadMessageId(val);
                    break;
                }
                case "write-config-ref": {
                    String val = asText(node);
                    target.setWriteConfigRef(val);
                    break;
                }
                case "write-in-json": {
                    String val = asText(node);
                    target.setWriteInJson(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "syslog",
            types = org.apache.camel.model.dataformat.SyslogDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Syslog",
            description = "Marshall SyslogMessages to RFC3164 and RFC5424 messages and back.",
            deprecated = false,
            properties = @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
    )
    public static class SyslogDataFormatDeserializer extends YamlDeserializerBase<SyslogDataFormat> {
        public SyslogDataFormatDeserializer() {
            super(SyslogDataFormat.class);
        }

        @Override
        protected SyslogDataFormat newInstance() {
            return new SyslogDataFormat();
        }

        @Override
        protected boolean setProperty(SyslogDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "tar-file",
                    "tarFile"
            },
            types = org.apache.camel.model.dataformat.TarFileDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Tar File",
            description = "Archive files into tarballs or extract files from tarballs.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-empty-directory", type = "boolean", description = "If the tar file has more than one entry, setting this option to true, allows to get the iterator even if the directory is empty", displayName = "Allow Empty Directory"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "max-decompressed-size", type = "number", defaultValue = "1073741824", description = "Set the maximum decompressed size of a tar file (in bytes). The default value if not specified corresponds to 1 gigabyte. An IOException will be thrown if the decompressed size exceeds this amount. Set to -1 to disable setting a maximum decompressed size.", displayName = "Max Decompressed Size"),
                    @YamlProperty(name = "preserve-path-elements", type = "boolean", description = "If the file name contains path elements, setting this option to true, allows the path to be maintained in the tar file.", displayName = "Preserve Path Elements"),
                    @YamlProperty(name = "using-iterator", type = "boolean", description = "If the tar file has more than one entry, the setting this option to true, allows working with the splitter EIP, to split the data using an iterator in a streaming mode.", displayName = "Using Iterator")
            }
    )
    public static class TarFileDataFormatDeserializer extends YamlDeserializerBase<TarFileDataFormat> {
        public TarFileDataFormatDeserializer() {
            super(TarFileDataFormat.class);
        }

        @Override
        protected TarFileDataFormat newInstance() {
            return new TarFileDataFormat();
        }

        @Override
        protected boolean setProperty(TarFileDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-empty-directory": {
                    String val = asText(node);
                    target.setAllowEmptyDirectory(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "max-decompressed-size": {
                    String val = asText(node);
                    target.setMaxDecompressedSize(val);
                    break;
                }
                case "preserve-path-elements": {
                    String val = asText(node);
                    target.setPreservePathElements(val);
                    break;
                }
                case "using-iterator": {
                    String val = asText(node);
                    target.setUsingIterator(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "templated-route-parameter",
                    "templatedRouteParameter"
            },
            types = org.apache.camel.model.TemplatedRouteParameterDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Templated Route Parameter",
            description = "An input parameter of a route template.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "name", type = "string", required = true, description = "The name of the parameter", displayName = "Name"),
                    @YamlProperty(name = "value", type = "string", required = true, description = "The value of the parameter.", displayName = "Value")
            }
    )
    public static class TemplatedRouteParameterDefinitionDeserializer extends YamlDeserializerBase<TemplatedRouteParameterDefinition> {
        public TemplatedRouteParameterDefinitionDeserializer() {
            super(TemplatedRouteParameterDefinition.class);
        }

        @Override
        protected TemplatedRouteParameterDefinition newInstance() {
            return new TemplatedRouteParameterDefinition();
        }

        @Override
        protected boolean setProperty(TemplatedRouteParameterDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "thread-pool-profile",
                    "threadPoolProfile"
            },
            types = org.apache.camel.model.ThreadPoolProfileDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Thread Pool Profile",
            description = "To configure thread pools",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-core-thread-time-out", type = "boolean", description = "Whether idle core threads is allowed to timeout and therefore can shrink the pool size below the core pool size Is by default true", displayName = "Allow Core Thread Time Out"),
                    @YamlProperty(name = "default-profile", type = "boolean", description = "Whether this profile is the default thread pool profile", displayName = "Default Profile"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "keep-alive-time", type = "number", description = "Sets the keep alive time for idle threads in the pool", displayName = "Keep Alive Time"),
                    @YamlProperty(name = "max-pool-size", type = "number", description = "Sets the maximum pool size", displayName = "Max Pool Size"),
                    @YamlProperty(name = "max-queue-size", type = "number", description = "Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue", displayName = "Max Queue Size"),
                    @YamlProperty(name = "pool-size", type = "number", description = "Sets the core pool size", displayName = "Pool Size"),
                    @YamlProperty(name = "rejected-policy", type = "enum:Abort,CallerRuns", description = "Sets the handler for tasks which cannot be executed by the thread pool.", displayName = "Rejected Policy"),
                    @YamlProperty(name = "time-unit", type = "enum:NANOSECONDS,MICROSECONDS,MILLISECONDS,SECONDS,MINUTES,HOURS,DAYS", description = "Sets the time unit to use for keep alive time By default SECONDS is used.", displayName = "Time Unit")
            }
    )
    public static class ThreadPoolProfileDefinitionDeserializer extends YamlDeserializerBase<ThreadPoolProfileDefinition> {
        public ThreadPoolProfileDefinitionDeserializer() {
            super(ThreadPoolProfileDefinition.class);
        }

        @Override
        protected ThreadPoolProfileDefinition newInstance() {
            return new ThreadPoolProfileDefinition();
        }

        @Override
        protected boolean setProperty(ThreadPoolProfileDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-core-thread-time-out": {
                    String val = asText(node);
                    target.setAllowCoreThreadTimeOut(val);
                    break;
                }
                case "default-profile": {
                    String val = asText(node);
                    target.setDefaultProfile(val);
                    break;
                }
                case "keep-alive-time": {
                    String val = asText(node);
                    target.setKeepAliveTime(val);
                    break;
                }
                case "max-pool-size": {
                    String val = asText(node);
                    target.setMaxPoolSize(val);
                    break;
                }
                case "max-queue-size": {
                    String val = asText(node);
                    target.setMaxQueueSize(val);
                    break;
                }
                case "pool-size": {
                    String val = asText(node);
                    target.setPoolSize(val);
                    break;
                }
                case "rejected-policy": {
                    String val = asText(node);
                    target.setRejectedPolicy(val);
                    break;
                }
                case "time-unit": {
                    String val = asText(node);
                    target.setTimeUnit(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "threads",
            types = org.apache.camel.model.ThreadsDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Threads",
            description = "Specifies that all steps after this node are processed asynchronously",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-core-thread-time-out", type = "boolean", description = "Whether idle core threads are allowed to timeout and therefore can shrink the pool size below the core pool size Is by default false", displayName = "Allow Core Thread Time Out"),
                    @YamlProperty(name = "caller-runs-when-rejected", type = "string", defaultValue = "true", description = "Whether or not to use as caller runs as fallback when a task is rejected being added to the thread pool (when its full). This is only used as fallback if no rejectedPolicy has been configured, or the thread pool has no configured rejection handler. Is by default true", displayName = "Caller Runs When Rejected"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "executor-service", type = "string", description = "To use a custom thread pool", displayName = "Executor Service"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "keep-alive-time", type = "number", description = "Sets the keep alive time for idle threads", displayName = "Keep Alive Time"),
                    @YamlProperty(name = "max-pool-size", type = "number", description = "Sets the maximum pool size", displayName = "Max Pool Size"),
                    @YamlProperty(name = "max-queue-size", type = "number", description = "Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue", displayName = "Max Queue Size"),
                    @YamlProperty(name = "pool-size", type = "number", description = "Sets the core pool size", displayName = "Pool Size"),
                    @YamlProperty(name = "rejected-policy", type = "enum:Abort,CallerRuns", description = "Sets the handler for tasks which cannot be executed by the thread pool.", displayName = "Rejected Policy"),
                    @YamlProperty(name = "thread-name", type = "string", defaultValue = "Threads", description = "Sets the thread name to use.", displayName = "Thread Name"),
                    @YamlProperty(name = "time-unit", type = "enum:NANOSECONDS,MICROSECONDS,MILLISECONDS,SECONDS,MINUTES,HOURS,DAYS", description = "Sets the keep alive time unit. By default SECONDS is used.", displayName = "Time Unit")
            }
    )
    public static class ThreadsDefinitionDeserializer extends YamlDeserializerBase<ThreadsDefinition> {
        public ThreadsDefinitionDeserializer() {
            super(ThreadsDefinition.class);
        }

        @Override
        protected ThreadsDefinition newInstance() {
            return new ThreadsDefinition();
        }

        @Override
        protected boolean setProperty(ThreadsDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-core-thread-time-out": {
                    String val = asText(node);
                    target.setAllowCoreThreadTimeOut(val);
                    break;
                }
                case "caller-runs-when-rejected": {
                    String val = asText(node);
                    target.setCallerRunsWhenRejected(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "keep-alive-time": {
                    String val = asText(node);
                    target.setKeepAliveTime(val);
                    break;
                }
                case "max-pool-size": {
                    String val = asText(node);
                    target.setMaxPoolSize(val);
                    break;
                }
                case "max-queue-size": {
                    String val = asText(node);
                    target.setMaxQueueSize(val);
                    break;
                }
                case "pool-size": {
                    String val = asText(node);
                    target.setPoolSize(val);
                    break;
                }
                case "rejected-policy": {
                    String val = asText(node);
                    target.setRejectedPolicy(val);
                    break;
                }
                case "thread-name": {
                    String val = asText(node);
                    target.setThreadName(val);
                    break;
                }
                case "time-unit": {
                    String val = asText(node);
                    target.setTimeUnit(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "thrift",
            inline = true,
            types = org.apache.camel.model.dataformat.ThriftDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Thrift",
            description = "Serialize and deserialize messages using Apache Thrift binary data format.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "content-type-format", type = "enum:binary,json,sjson", defaultValue = "binary", description = "Defines a content type format in which thrift message will be serialized/deserialized from(to) the Java been. The format can either be native or json for either native binary thrift, json or simple json fields representation. The default value is binary.", displayName = "Content Type Format"),
                    @YamlProperty(name = "content-type-header", type = "boolean", description = "Whether the data format should set the Content-Type header with the type from the data format. For example application/xml for data formats marshalling to XML, or application/json for data formats marshalling to JSON", displayName = "Content Type Header"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "instance-class", type = "string", description = "Name of class to use when unmarshalling", displayName = "Instance Class")
            }
    )
    public static class ThriftDataFormatDeserializer extends YamlDeserializerBase<ThriftDataFormat> {
        public ThriftDataFormatDeserializer() {
            super(ThriftDataFormat.class);
        }

        @Override
        protected ThriftDataFormat newInstance() {
            return new ThriftDataFormat();
        }

        @Override
        protected ThriftDataFormat newInstance(String value) {
            return new ThriftDataFormat(value);
        }

        @Override
        protected boolean setProperty(ThriftDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "content-type-format": {
                    String val = asText(node);
                    target.setContentTypeFormat(val);
                    break;
                }
                case "content-type-header": {
                    String val = asText(node);
                    target.setContentTypeHeader(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "instance-class": {
                    String val = asText(node);
                    target.setInstanceClass(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "throttle",
            types = org.apache.camel.model.ThrottleDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Throttle",
            description = "Controls the rate at which messages are passed to the next node in the route",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "async-delayed", type = "boolean", description = "Enables asynchronous delay which means the thread will not block while delaying.", displayName = "Async Delayed"),
                    @YamlProperty(name = "caller-runs-when-rejected", type = "boolean", description = "Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true", displayName = "Caller Runs When Rejected"),
                    @YamlProperty(name = "correlation-expression", type = "object:org.apache.camel.model.ExpressionSubElementDefinition", description = "The expression used to calculate the correlation key to use for throttle grouping. The Exchange which has the same correlation key is throttled together.", displayName = "Correlation Expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "executor-service", type = "string", description = "To use a custom thread pool (ScheduledExecutorService) by the throttler.", displayName = "Executor Service"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to configure the maximum number of messages to throttle per request", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "reject-execution", type = "boolean", description = "Whether or not throttler throws the ThrottlerRejectedExecutionException when the exchange exceeds the request limit Is by default false", displayName = "Reject Execution"),
                    @YamlProperty(name = "time-period-millis", type = "string", defaultValue = "1000", description = "Sets the time period during which the maximum request count is valid for", displayName = "Time Period Millis")
            }
    )
    public static class ThrottleDefinitionDeserializer extends YamlDeserializerBase<ThrottleDefinition> {
        public ThrottleDefinitionDeserializer() {
            super(ThrottleDefinition.class);
        }

        @Override
        protected ThrottleDefinition newInstance() {
            return new ThrottleDefinition();
        }

        @Override
        protected boolean setProperty(ThrottleDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "async-delayed": {
                    String val = asText(node);
                    target.setAsyncDelayed(val);
                    break;
                }
                case "caller-runs-when-rejected": {
                    String val = asText(node);
                    target.setCallerRunsWhenRejected(val);
                    break;
                }
                case "correlation-expression": {
                    org.apache.camel.model.ExpressionSubElementDefinition val = asType(node, org.apache.camel.model.ExpressionSubElementDefinition.class);
                    target.setCorrelationExpression(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "reject-execution": {
                    String val = asText(node);
                    target.setRejectExecution(val);
                    break;
                }
                case "time-period-millis": {
                    String val = asText(node);
                    target.setTimePeriodMillis(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "throw-exception",
                    "throwException"
            },
            types = org.apache.camel.model.ThrowExceptionDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Throw Exception",
            description = "Throws an exception",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "exception-type", type = "string", description = "The class of the exception to create using the message.", displayName = "Exception Type"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "message", type = "string", description = "To create a new exception instance and use the given message as caused message (supports simple language)", displayName = "Message"),
                    @YamlProperty(name = "ref", type = "string", description = "Reference to the exception instance to lookup from the registry to throw", displayName = "Ref")
            }
    )
    public static class ThrowExceptionDefinitionDeserializer extends YamlDeserializerBase<ThrowExceptionDefinition> {
        public ThrowExceptionDefinitionDeserializer() {
            super(ThrowExceptionDefinition.class);
        }

        @Override
        protected ThrowExceptionDefinition newInstance() {
            return new ThrowExceptionDefinition();
        }

        @Override
        protected boolean setProperty(ThrowExceptionDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "exception-type": {
                    String val = asText(node);
                    target.setExceptionType(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "message": {
                    String val = asText(node);
                    target.setMessage(val);
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "tidy-markup",
                    "tidyMarkup"
            },
            types = org.apache.camel.model.dataformat.TidyMarkupDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "TidyMarkup",
            description = "Parse (potentially invalid) HTML into valid HTML or DOM.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "data-object-type", type = "enum:org.w3c.dom.Node,java.lang.String", defaultValue = "org.w3c.dom.Node", description = "What data type to unmarshal as, can either be org.w3c.dom.Node or java.lang.String. Is by default org.w3c.dom.Node", displayName = "Data Object Type"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "omit-xml-declaration", type = "boolean", description = "When returning a String, do we omit the XML declaration in the top.", displayName = "Omit Xml Declaration")
            }
    )
    public static class TidyMarkupDataFormatDeserializer extends YamlDeserializerBase<TidyMarkupDataFormat> {
        public TidyMarkupDataFormatDeserializer() {
            super(TidyMarkupDataFormat.class);
        }

        @Override
        protected TidyMarkupDataFormat newInstance() {
            return new TidyMarkupDataFormat();
        }

        @Override
        protected boolean setProperty(TidyMarkupDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "data-object-type": {
                    String val = asText(node);
                    target.setDataObjectTypeName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "omit-xml-declaration": {
                    String val = asText(node);
                    target.setOmitXmlDeclaration(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "to",
            inline = true,
            types = org.apache.camel.model.ToDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "To",
            description = "Sends the message to a static endpoint",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "parameters", type = "object"),
                    @YamlProperty(name = "pattern", type = "enum:InOnly,InOut", description = "Sets the optional ExchangePattern used to invoke this endpoint", displayName = "Pattern"),
                    @YamlProperty(name = "uri", type = "string", required = true, description = "Sets the uri of the endpoint to send to.", displayName = "Uri")
            }
    )
    public static class ToDefinitionDeserializer extends YamlDeserializerEndpointAwareBase<ToDefinition> {
        public ToDefinitionDeserializer() {
            super(ToDefinition.class);
        }

        @Override
        protected ToDefinition newInstance() {
            return new ToDefinition();
        }

        @Override
        protected ToDefinition newInstance(String value) {
            return new ToDefinition(value);
        }

        @Override
        protected void setEndpointUri(CamelContext camelContext, Node node, ToDefinition target,
                Map<String, Object> parameters) {
            target.setUri(org.apache.camel.dsl.yaml.common.YamlSupport.createEndpointUri(camelContext, node, target.getUri(), parameters));
        }

        @Override
        protected boolean setProperty(ToDefinition target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "to-d",
                    "toD"
            },
            inline = true,
            types = org.apache.camel.model.ToDynamicDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "To D",
            description = "Sends the message to a dynamic endpoint",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-optimised-components", type = "boolean", description = "Whether to allow components to optimise toD if they are org.apache.camel.spi.SendDynamicAware .", displayName = "Allow Optimised Components"),
                    @YamlProperty(name = "auto-start-components", type = "boolean", description = "Whether to auto startup components when toD is starting up.", displayName = "Auto Start Components"),
                    @YamlProperty(name = "cache-size", type = "number", description = "Sets the maximum size used by the org.apache.camel.spi.ProducerCache which is used to cache and reuse producers when using this recipient list, when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.", displayName = "Cache Size"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-endpoint", type = "boolean", description = "Whether to ignore invalid endpoint URIs and skip sending the message.", displayName = "Ignore Invalid Endpoint"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "parameters", type = "object"),
                    @YamlProperty(name = "pattern", type = "enum:InOnly,InOut", description = "Sets the optional ExchangePattern used to invoke this endpoint", displayName = "Pattern"),
                    @YamlProperty(name = "uri", type = "string", required = true, description = "The uri of the endpoint to send to. The uri can be dynamic computed using the org.apache.camel.language.simple.SimpleLanguage expression.", displayName = "Uri")
            }
    )
    public static class ToDynamicDefinitionDeserializer extends YamlDeserializerEndpointAwareBase<ToDynamicDefinition> {
        public ToDynamicDefinitionDeserializer() {
            super(ToDynamicDefinition.class);
        }

        @Override
        protected ToDynamicDefinition newInstance() {
            return new ToDynamicDefinition();
        }

        @Override
        protected ToDynamicDefinition newInstance(String value) {
            return new ToDynamicDefinition(value);
        }

        @Override
        protected void setEndpointUri(CamelContext camelContext, Node node,
                ToDynamicDefinition target, Map<String, Object> parameters) {
            target.setUri(org.apache.camel.dsl.yaml.common.YamlSupport.createEndpointUri(camelContext, node, target.getUri(), parameters));
        }

        @Override
        protected boolean setProperty(ToDynamicDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-optimised-components": {
                    String val = asText(node);
                    target.setAllowOptimisedComponents(val);
                    break;
                }
                case "auto-start-components": {
                    String val = asText(node);
                    target.setAutoStartComponents(val);
                    break;
                }
                case "cache-size": {
                    String val = asText(node);
                    target.setCacheSize(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "ignore-invalid-endpoint": {
                    String val = asText(node);
                    target.setIgnoreInvalidEndpoint(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "tokenize",
            inline = true,
            types = org.apache.camel.model.language.TokenizerExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Tokenize",
            description = "Tokenize text payloads using delimiter patterns.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "end-token", type = "string", description = "The end token to use as tokenizer if using start/end token pairs. You can use simple language as the token to support dynamic tokens.", displayName = "End Token"),
                    @YamlProperty(name = "group", type = "string", description = "To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple language as the group to support dynamic group sizes.", displayName = "Group"),
                    @YamlProperty(name = "group-delimiter", type = "string", description = "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter.", displayName = "Group Delimiter"),
                    @YamlProperty(name = "header-name", type = "string", description = "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set.", displayName = "Header Name"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "include-tokens", type = "boolean", description = "Whether to include the tokens in the parts when using pairs. When including tokens then the endToken property must also be configured (to use pair mode). The default value is false", displayName = "Include Tokens"),
                    @YamlProperty(name = "inherit-namespace-tag-name", type = "string", description = "To inherit namespaces from a root/parent tag name when using XML You can use simple language as the tag name to support dynamic names.", displayName = "Inherit Namespace Tag Name"),
                    @YamlProperty(name = "property-name", type = "string", description = "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set.", displayName = "Property Name"),
                    @YamlProperty(name = "regex", type = "boolean", description = "If the token is a regular expression pattern. The default value is false", displayName = "Regex"),
                    @YamlProperty(name = "skip-first", type = "boolean", description = "To skip the very first element", displayName = "Skip First"),
                    @YamlProperty(name = "token", type = "string", required = true, description = "The (start) token to use as tokenizer, for example you can use the new line token. You can use simple language as the token to support dynamic tokens.", displayName = "Token"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
                    @YamlProperty(name = "xml", type = "boolean", description = "Whether the input is XML messages. This option must be set to true if working with XML payloads.", displayName = "Xml")
            }
    )
    public static class TokenizerExpressionDeserializer extends YamlDeserializerBase<TokenizerExpression> {
        public TokenizerExpressionDeserializer() {
            super(TokenizerExpression.class);
        }

        @Override
        protected TokenizerExpression newInstance() {
            return new TokenizerExpression();
        }

        @Override
        protected TokenizerExpression newInstance(String value) {
            return new TokenizerExpression(value);
        }

        @Override
        protected boolean setProperty(TokenizerExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "end-token": {
                    String val = asText(node);
                    target.setEndToken(val);
                    break;
                }
                case "group": {
                    String val = asText(node);
                    target.setGroup(val);
                    break;
                }
                case "group-delimiter": {
                    String val = asText(node);
                    target.setGroupDelimiter(val);
                    break;
                }
                case "header-name": {
                    String val = asText(node);
                    target.setHeaderName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "include-tokens": {
                    String val = asText(node);
                    target.setIncludeTokens(val);
                    break;
                }
                case "inherit-namespace-tag-name": {
                    String val = asText(node);
                    target.setInheritNamespaceTagName(val);
                    break;
                }
                case "property-name": {
                    String val = asText(node);
                    target.setPropertyName(val);
                    break;
                }
                case "regex": {
                    String val = asText(node);
                    target.setRegex(val);
                    break;
                }
                case "skip-first": {
                    String val = asText(node);
                    target.setSkipFirst(val);
                    break;
                }
                case "token": {
                    String val = asText(node);
                    target.setToken(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                case "xml": {
                    String val = asText(node);
                    target.setXml(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "topic",
            types = org.apache.camel.model.loadbalancer.TopicLoadBalancerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Topic",
            description = "Topic which sends to all destinations.",
            deprecated = false,
            properties = @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
    )
    public static class TopicLoadBalancerDefinitionDeserializer extends YamlDeserializerBase<TopicLoadBalancerDefinition> {
        public TopicLoadBalancerDefinitionDeserializer() {
            super(TopicLoadBalancerDefinition.class);
        }

        @Override
        protected TopicLoadBalancerDefinition newInstance() {
            return new TopicLoadBalancerDefinition();
        }

        @Override
        protected boolean setProperty(TopicLoadBalancerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "transacted",
            types = org.apache.camel.model.TransactedDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Transacted",
            description = "Enables transaction on the route",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "ref", type = "string", description = "Sets a reference to use for lookup the policy in the registry.", displayName = "Ref"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class TransactedDefinitionDeserializer extends YamlDeserializerBase<TransactedDefinition> {
        public TransactedDefinitionDeserializer() {
            super(TransactedDefinition.class);
        }

        @Override
        protected TransactedDefinition newInstance() {
            return new TransactedDefinition();
        }

        @Override
        protected boolean setProperty(TransactedDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "ref": {
                    String val = asText(node);
                    target.setRef(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "transform",
            types = org.apache.camel.model.TransformDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Transform",
            description = "Transforms the message body based on an expression",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to return the transformed message body (the new message body to use)", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "from-type", type = "string", description = "From type used in data type transformation.", displayName = "From Type"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "to-type", type = "string", description = "To type used as a target data type in the transformation.", displayName = "To Type")
            }
    )
    public static class TransformDefinitionDeserializer extends YamlDeserializerBase<TransformDefinition> {
        public TransformDefinitionDeserializer() {
            super(TransformDefinition.class);
        }

        @Override
        protected TransformDefinition newInstance() {
            return new TransformDefinition();
        }

        @Override
        protected boolean setProperty(TransformDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "from-type": {
                    String val = asText(node);
                    target.setFromType(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "to-type": {
                    String val = asText(node);
                    target.setToType(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "transformers",
            types = org.apache.camel.model.transformer.TransformersDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Transformations",
            description = "To configure transformers.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "custom-transformer", type = "object:org.apache.camel.model.transformer.CustomTransformerDefinition"),
                    @YamlProperty(name = "data-format-transformer", type = "object:org.apache.camel.model.transformer.DataFormatTransformerDefinition"),
                    @YamlProperty(name = "endpoint-transformer", type = "object:org.apache.camel.model.transformer.EndpointTransformerDefinition"),
                    @YamlProperty(name = "load-transformer", type = "object:org.apache.camel.model.transformer.LoadTransformerDefinition")
            }
    )
    public static class TransformersDefinitionDeserializer extends YamlDeserializerBase<TransformersDefinition> {
        public TransformersDefinitionDeserializer() {
            super(TransformersDefinition.class);
        }

        @Override
        protected TransformersDefinition newInstance() {
            return new TransformersDefinition();
        }

        @Override
        protected boolean setProperty(TransformersDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "transformers": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "data-format-transformer": {
                    org.apache.camel.model.transformer.DataFormatTransformerDefinition val = asType(node, org.apache.camel.model.transformer.DataFormatTransformerDefinition.class);
                    java.util.List<org.apache.camel.model.transformer.TransformerDefinition> existing = target.getTransformers();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setTransformers(existing);
                    break;
                }
                case "endpoint-transformer": {
                    org.apache.camel.model.transformer.EndpointTransformerDefinition val = asType(node, org.apache.camel.model.transformer.EndpointTransformerDefinition.class);
                    java.util.List<org.apache.camel.model.transformer.TransformerDefinition> existing = target.getTransformers();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setTransformers(existing);
                    break;
                }
                case "load-transformer": {
                    org.apache.camel.model.transformer.LoadTransformerDefinition val = asType(node, org.apache.camel.model.transformer.LoadTransformerDefinition.class);
                    java.util.List<org.apache.camel.model.transformer.TransformerDefinition> existing = target.getTransformers();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setTransformers(existing);
                    break;
                }
                case "custom-transformer": {
                    org.apache.camel.model.transformer.CustomTransformerDefinition val = asType(node, org.apache.camel.model.transformer.CustomTransformerDefinition.class);
                    java.util.List<org.apache.camel.model.transformer.TransformerDefinition> existing = target.getTransformers();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setTransformers(existing);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "do-try",
                    "doTry"
            },
            types = org.apache.camel.model.TryDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Do Try",
            description = "Marks the beginning of a try, catch, finally block",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "do-catch", type = "array:org.apache.camel.model.CatchDefinition"),
                    @YamlProperty(name = "do-finally", type = "object:org.apache.camel.model.FinallyDefinition"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class TryDefinitionDeserializer extends YamlDeserializerBase<TryDefinition> {
        public TryDefinitionDeserializer() {
            super(TryDefinition.class);
        }

        @Override
        protected TryDefinition newInstance() {
            return new TryDefinition();
        }

        @Override
        protected boolean setProperty(TryDefinition target, String propertyKey, String propertyName,
                Node node) {
            switch(propertyKey) {
                case "do-catch": {
                    java.util.List<org.apache.camel.model.CatchDefinition> val = asFlatList(node, org.apache.camel.model.CatchDefinition.class);
                    target.setCatchClauses(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "do-finally": {
                    org.apache.camel.model.FinallyDefinition val = asType(node, org.apache.camel.model.FinallyDefinition.class);
                    target.setFinallyClause(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "univocity-csv",
                    "univocityCsv"
            },
            types = org.apache.camel.model.dataformat.UniVocityCsvDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "uniVocity CSV",
            description = "Marshal and unmarshal Java objects from and to CSV (Comma Separated Values) using UniVocity Parsers.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "as-map", type = "boolean", description = "Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false", displayName = "As Map"),
                    @YamlProperty(name = "comment", type = "string", defaultValue = "#", description = "The comment symbol. The default value is #", displayName = "Comment"),
                    @YamlProperty(name = "delimiter", type = "string", defaultValue = ",", description = "The delimiter of values", displayName = "Delimiter"),
                    @YamlProperty(name = "empty-value", type = "string", description = "The String representation of an empty value", displayName = "Empty Value"),
                    @YamlProperty(name = "header-extraction-enabled", type = "boolean", description = "Whether or not the header must be read in the first line of the test document The default value is false", displayName = "Header Extraction Enabled"),
                    @YamlProperty(name = "headers-disabled", type = "boolean", description = "Whether or not the headers are disabled. When defined, this option explicitly sets the headers as null which indicates that there is no header. The default value is false", displayName = "Headers Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-leading-whitespaces", type = "boolean", description = "Whether or not the leading white spaces must be ignored. The default value is true", displayName = "Ignore Leading Whitespaces"),
                    @YamlProperty(name = "ignore-trailing-whitespaces", type = "boolean", description = "Whether or not the trailing white spaces must be ignored. The default value is true", displayName = "Ignore Trailing Whitespaces"),
                    @YamlProperty(name = "lazy-load", type = "boolean", description = "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false", displayName = "Lazy Load"),
                    @YamlProperty(name = "line-separator", type = "string", description = "The line separator of the files The default value is to use the JVM platform line separator", displayName = "Line Separator"),
                    @YamlProperty(name = "normalized-line-separator", type = "string", defaultValue = "\\n", description = "The normalized line separator of the files The default value is a new line character.", displayName = "Normalized Line Separator"),
                    @YamlProperty(name = "null-value", type = "string", description = "The string representation of a null value. The default value is null", displayName = "Null Value"),
                    @YamlProperty(name = "number-of-records-to-read", type = "number", description = "The maximum number of record to read.", displayName = "Number Of Records To Read"),
                    @YamlProperty(name = "quote", type = "string", defaultValue = "\"", description = "The quote symbol.", displayName = "Quote"),
                    @YamlProperty(name = "quote-all-fields", type = "boolean", description = "Whether or not all values must be quoted when writing them.", displayName = "Quote All Fields"),
                    @YamlProperty(name = "quote-escape", type = "string", defaultValue = "\"", description = "The quote escape symbol", displayName = "Quote Escape"),
                    @YamlProperty(name = "skip-empty-lines", type = "boolean", description = "Whether or not the empty lines must be ignored. The default value is true", displayName = "Skip Empty Lines"),
                    @YamlProperty(name = "univocity-header", type = "array:org.apache.camel.model.dataformat.UniVocityHeader")
            }
    )
    public static class UniVocityCsvDataFormatDeserializer extends YamlDeserializerBase<UniVocityCsvDataFormat> {
        public UniVocityCsvDataFormatDeserializer() {
            super(UniVocityCsvDataFormat.class);
        }

        @Override
        protected UniVocityCsvDataFormat newInstance() {
            return new UniVocityCsvDataFormat();
        }

        @Override
        protected boolean setProperty(UniVocityCsvDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "as-map": {
                    String val = asText(node);
                    target.setAsMap(val);
                    break;
                }
                case "comment": {
                    String val = asText(node);
                    target.setComment(val);
                    break;
                }
                case "delimiter": {
                    String val = asText(node);
                    target.setDelimiter(val);
                    break;
                }
                case "empty-value": {
                    String val = asText(node);
                    target.setEmptyValue(val);
                    break;
                }
                case "header-extraction-enabled": {
                    String val = asText(node);
                    target.setHeaderExtractionEnabled(val);
                    break;
                }
                case "univocity-header": {
                    java.util.List<org.apache.camel.model.dataformat.UniVocityHeader> val = asFlatList(node, org.apache.camel.model.dataformat.UniVocityHeader.class);
                    target.setHeaders(val);
                    break;
                }
                case "headers-disabled": {
                    String val = asText(node);
                    target.setHeadersDisabled(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ignore-leading-whitespaces": {
                    String val = asText(node);
                    target.setIgnoreLeadingWhitespaces(val);
                    break;
                }
                case "ignore-trailing-whitespaces": {
                    String val = asText(node);
                    target.setIgnoreTrailingWhitespaces(val);
                    break;
                }
                case "lazy-load": {
                    String val = asText(node);
                    target.setLazyLoad(val);
                    break;
                }
                case "line-separator": {
                    String val = asText(node);
                    target.setLineSeparator(val);
                    break;
                }
                case "normalized-line-separator": {
                    String val = asText(node);
                    target.setNormalizedLineSeparator(val);
                    break;
                }
                case "null-value": {
                    String val = asText(node);
                    target.setNullValue(val);
                    break;
                }
                case "number-of-records-to-read": {
                    String val = asText(node);
                    target.setNumberOfRecordsToRead(val);
                    break;
                }
                case "quote": {
                    String val = asText(node);
                    target.setQuote(val);
                    break;
                }
                case "quote-all-fields": {
                    String val = asText(node);
                    target.setQuoteAllFields(val);
                    break;
                }
                case "quote-escape": {
                    String val = asText(node);
                    target.setQuoteEscape(val);
                    break;
                }
                case "skip-empty-lines": {
                    String val = asText(node);
                    target.setSkipEmptyLines(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "univocity-fixed",
                    "univocityFixed"
            },
            types = org.apache.camel.model.dataformat.UniVocityFixedDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "uniVocity Fixed Length",
            description = "Marshal and unmarshal Java objects from and to fixed length records using UniVocity Parsers.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "as-map", type = "boolean", description = "Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false", displayName = "As Map"),
                    @YamlProperty(name = "comment", type = "string", defaultValue = "#", description = "The comment symbol. The default value is #", displayName = "Comment"),
                    @YamlProperty(name = "empty-value", type = "string", description = "The String representation of an empty value", displayName = "Empty Value"),
                    @YamlProperty(name = "header-extraction-enabled", type = "boolean", description = "Whether or not the header must be read in the first line of the test document The default value is false", displayName = "Header Extraction Enabled"),
                    @YamlProperty(name = "headers-disabled", type = "boolean", description = "Whether or not the headers are disabled. When defined, this option explicitly sets the headers as null which indicates that there is no header. The default value is false", displayName = "Headers Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-leading-whitespaces", type = "boolean", description = "Whether or not the leading white spaces must be ignored. The default value is true", displayName = "Ignore Leading Whitespaces"),
                    @YamlProperty(name = "ignore-trailing-whitespaces", type = "boolean", description = "Whether or not the trailing white spaces must be ignored. The default value is true", displayName = "Ignore Trailing Whitespaces"),
                    @YamlProperty(name = "lazy-load", type = "boolean", description = "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false", displayName = "Lazy Load"),
                    @YamlProperty(name = "line-separator", type = "string", description = "The line separator of the files The default value is to use the JVM platform line separator", displayName = "Line Separator"),
                    @YamlProperty(name = "normalized-line-separator", type = "string", defaultValue = "\\n", description = "The normalized line separator of the files The default value is a new line character.", displayName = "Normalized Line Separator"),
                    @YamlProperty(name = "null-value", type = "string", description = "The string representation of a null value. The default value is null", displayName = "Null Value"),
                    @YamlProperty(name = "number-of-records-to-read", type = "number", description = "The maximum number of record to read.", displayName = "Number Of Records To Read"),
                    @YamlProperty(name = "padding", type = "string", description = "The padding character. The default value is a space", displayName = "Padding"),
                    @YamlProperty(name = "record-ends-on-newline", type = "boolean", description = "Whether or not the record ends on new line. The default value is false", displayName = "Record Ends On Newline"),
                    @YamlProperty(name = "skip-empty-lines", type = "boolean", description = "Whether or not the empty lines must be ignored. The default value is true", displayName = "Skip Empty Lines"),
                    @YamlProperty(name = "skip-trailing-chars-until-newline", type = "boolean", description = "Whether or not the trailing characters until new line must be ignored. The default value is false", displayName = "Skip Trailing Chars Until Newline"),
                    @YamlProperty(name = "univocity-header", type = "array:org.apache.camel.model.dataformat.UniVocityHeader")
            }
    )
    public static class UniVocityFixedDataFormatDeserializer extends YamlDeserializerBase<UniVocityFixedDataFormat> {
        public UniVocityFixedDataFormatDeserializer() {
            super(UniVocityFixedDataFormat.class);
        }

        @Override
        protected UniVocityFixedDataFormat newInstance() {
            return new UniVocityFixedDataFormat();
        }

        @Override
        protected boolean setProperty(UniVocityFixedDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "as-map": {
                    String val = asText(node);
                    target.setAsMap(val);
                    break;
                }
                case "comment": {
                    String val = asText(node);
                    target.setComment(val);
                    break;
                }
                case "empty-value": {
                    String val = asText(node);
                    target.setEmptyValue(val);
                    break;
                }
                case "header-extraction-enabled": {
                    String val = asText(node);
                    target.setHeaderExtractionEnabled(val);
                    break;
                }
                case "univocity-header": {
                    java.util.List<org.apache.camel.model.dataformat.UniVocityHeader> val = asFlatList(node, org.apache.camel.model.dataformat.UniVocityHeader.class);
                    target.setHeaders(val);
                    break;
                }
                case "headers-disabled": {
                    String val = asText(node);
                    target.setHeadersDisabled(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ignore-leading-whitespaces": {
                    String val = asText(node);
                    target.setIgnoreLeadingWhitespaces(val);
                    break;
                }
                case "ignore-trailing-whitespaces": {
                    String val = asText(node);
                    target.setIgnoreTrailingWhitespaces(val);
                    break;
                }
                case "lazy-load": {
                    String val = asText(node);
                    target.setLazyLoad(val);
                    break;
                }
                case "line-separator": {
                    String val = asText(node);
                    target.setLineSeparator(val);
                    break;
                }
                case "normalized-line-separator": {
                    String val = asText(node);
                    target.setNormalizedLineSeparator(val);
                    break;
                }
                case "null-value": {
                    String val = asText(node);
                    target.setNullValue(val);
                    break;
                }
                case "number-of-records-to-read": {
                    String val = asText(node);
                    target.setNumberOfRecordsToRead(val);
                    break;
                }
                case "padding": {
                    String val = asText(node);
                    target.setPadding(val);
                    break;
                }
                case "record-ends-on-newline": {
                    String val = asText(node);
                    target.setRecordEndsOnNewline(val);
                    break;
                }
                case "skip-empty-lines": {
                    String val = asText(node);
                    target.setSkipEmptyLines(val);
                    break;
                }
                case "skip-trailing-chars-until-newline": {
                    String val = asText(node);
                    target.setSkipTrailingCharsUntilNewline(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "univocity-header",
                    "univocityHeader"
            },
            types = org.apache.camel.model.dataformat.UniVocityHeader.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "uniVocity Header",
            description = "To configure headers for UniVocity data formats.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "length", type = "string", description = "Header length", displayName = "Length"),
                    @YamlProperty(name = "name", type = "string", description = "Header name", displayName = "Name")
            }
    )
    public static class UniVocityHeaderDeserializer extends YamlDeserializerBase<UniVocityHeader> {
        public UniVocityHeaderDeserializer() {
            super(UniVocityHeader.class);
        }

        @Override
        protected UniVocityHeader newInstance() {
            return new UniVocityHeader();
        }

        @Override
        protected boolean setProperty(UniVocityHeader target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "length": {
                    String val = asText(node);
                    target.setLength(val);
                    break;
                }
                case "name": {
                    String val = asText(node);
                    target.setName(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "univocity-tsv",
                    "univocityTsv"
            },
            types = org.apache.camel.model.dataformat.UniVocityTsvDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "uniVocity TSV",
            description = "Marshal and unmarshal Java objects from and to TSV (Tab-Separated Values) records using UniVocity Parsers.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "as-map", type = "boolean", description = "Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false", displayName = "As Map"),
                    @YamlProperty(name = "comment", type = "string", defaultValue = "#", description = "The comment symbol. The default value is #", displayName = "Comment"),
                    @YamlProperty(name = "empty-value", type = "string", description = "The String representation of an empty value", displayName = "Empty Value"),
                    @YamlProperty(name = "escape-char", type = "string", defaultValue = "\\", description = "The escape character.", displayName = "Escape Char"),
                    @YamlProperty(name = "header-extraction-enabled", type = "boolean", description = "Whether or not the header must be read in the first line of the test document The default value is false", displayName = "Header Extraction Enabled"),
                    @YamlProperty(name = "headers-disabled", type = "boolean", description = "Whether or not the headers are disabled. When defined, this option explicitly sets the headers as null which indicates that there is no header. The default value is false", displayName = "Headers Disabled"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-leading-whitespaces", type = "boolean", description = "Whether or not the leading white spaces must be ignored. The default value is true", displayName = "Ignore Leading Whitespaces"),
                    @YamlProperty(name = "ignore-trailing-whitespaces", type = "boolean", description = "Whether or not the trailing white spaces must be ignored. The default value is true", displayName = "Ignore Trailing Whitespaces"),
                    @YamlProperty(name = "lazy-load", type = "boolean", description = "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false", displayName = "Lazy Load"),
                    @YamlProperty(name = "line-separator", type = "string", description = "The line separator of the files The default value is to use the JVM platform line separator", displayName = "Line Separator"),
                    @YamlProperty(name = "normalized-line-separator", type = "string", defaultValue = "\\n", description = "The normalized line separator of the files The default value is a new line character.", displayName = "Normalized Line Separator"),
                    @YamlProperty(name = "null-value", type = "string", description = "The string representation of a null value. The default value is null", displayName = "Null Value"),
                    @YamlProperty(name = "number-of-records-to-read", type = "number", description = "The maximum number of record to read.", displayName = "Number Of Records To Read"),
                    @YamlProperty(name = "skip-empty-lines", type = "boolean", description = "Whether or not the empty lines must be ignored. The default value is true", displayName = "Skip Empty Lines"),
                    @YamlProperty(name = "univocity-header", type = "array:org.apache.camel.model.dataformat.UniVocityHeader")
            }
    )
    public static class UniVocityTsvDataFormatDeserializer extends YamlDeserializerBase<UniVocityTsvDataFormat> {
        public UniVocityTsvDataFormatDeserializer() {
            super(UniVocityTsvDataFormat.class);
        }

        @Override
        protected UniVocityTsvDataFormat newInstance() {
            return new UniVocityTsvDataFormat();
        }

        @Override
        protected boolean setProperty(UniVocityTsvDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "as-map": {
                    String val = asText(node);
                    target.setAsMap(val);
                    break;
                }
                case "comment": {
                    String val = asText(node);
                    target.setComment(val);
                    break;
                }
                case "empty-value": {
                    String val = asText(node);
                    target.setEmptyValue(val);
                    break;
                }
                case "escape-char": {
                    String val = asText(node);
                    target.setEscapeChar(val);
                    break;
                }
                case "header-extraction-enabled": {
                    String val = asText(node);
                    target.setHeaderExtractionEnabled(val);
                    break;
                }
                case "univocity-header": {
                    java.util.List<org.apache.camel.model.dataformat.UniVocityHeader> val = asFlatList(node, org.apache.camel.model.dataformat.UniVocityHeader.class);
                    target.setHeaders(val);
                    break;
                }
                case "headers-disabled": {
                    String val = asText(node);
                    target.setHeadersDisabled(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "ignore-leading-whitespaces": {
                    String val = asText(node);
                    target.setIgnoreLeadingWhitespaces(val);
                    break;
                }
                case "ignore-trailing-whitespaces": {
                    String val = asText(node);
                    target.setIgnoreTrailingWhitespaces(val);
                    break;
                }
                case "lazy-load": {
                    String val = asText(node);
                    target.setLazyLoad(val);
                    break;
                }
                case "line-separator": {
                    String val = asText(node);
                    target.setLineSeparator(val);
                    break;
                }
                case "normalized-line-separator": {
                    String val = asText(node);
                    target.setNormalizedLineSeparator(val);
                    break;
                }
                case "null-value": {
                    String val = asText(node);
                    target.setNullValue(val);
                    break;
                }
                case "number-of-records-to-read": {
                    String val = asText(node);
                    target.setNumberOfRecordsToRead(val);
                    break;
                }
                case "skip-empty-lines": {
                    String val = asText(node);
                    target.setSkipEmptyLines(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "unmarshal",
            types = org.apache.camel.model.UnmarshalDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Unmarshal",
            description = "Converts the message data received from the wire into a format that Apache Camel processors can consume",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-null-body", type = "boolean", description = "Indicates whether null is allowed as value of a body to unmarshall.", displayName = "Allow Null Body"),
                    @YamlProperty(name = "asn1", type = "object:org.apache.camel.model.dataformat.ASN1DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "avro", type = "object:org.apache.camel.model.dataformat.AvroDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "barcode", type = "object:org.apache.camel.model.dataformat.BarcodeDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "base64", type = "object:org.apache.camel.model.dataformat.Base64DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "bindy", type = "object:org.apache.camel.model.dataformat.BindyDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "cbor", type = "object:org.apache.camel.model.dataformat.CBORDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "crypto", type = "object:org.apache.camel.model.dataformat.CryptoDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "csv", type = "object:org.apache.camel.model.dataformat.CsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "custom", type = "object:org.apache.camel.model.dataformat.CustomDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "fhir-json", type = "object:org.apache.camel.model.dataformat.FhirJsonDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "fhir-xml", type = "object:org.apache.camel.model.dataformat.FhirXmlDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "flatpack", type = "object:org.apache.camel.model.dataformat.FlatpackDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "grok", type = "object:org.apache.camel.model.dataformat.GrokDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "gzip-deflater", type = "object:org.apache.camel.model.dataformat.GzipDeflaterDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "hl7", type = "object:org.apache.camel.model.dataformat.HL7DataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "ical", type = "object:org.apache.camel.model.dataformat.IcalDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "jackson-xml", type = "object:org.apache.camel.model.dataformat.JacksonXMLDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "jaxb", type = "object:org.apache.camel.model.dataformat.JaxbDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "json", type = "object:org.apache.camel.model.dataformat.JsonDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "json-api", type = "object:org.apache.camel.model.dataformat.JsonApiDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "lzf", type = "object:org.apache.camel.model.dataformat.LZFDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "mime-multipart", type = "object:org.apache.camel.model.dataformat.MimeMultipartDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "parquet-avro", type = "object:org.apache.camel.model.dataformat.ParquetAvroDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "pgp", type = "object:org.apache.camel.model.dataformat.PGPDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "protobuf", type = "object:org.apache.camel.model.dataformat.ProtobufDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "rss", type = "object:org.apache.camel.model.dataformat.RssDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "soap", type = "object:org.apache.camel.model.dataformat.SoapDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "swift-mt", type = "object:org.apache.camel.model.dataformat.SwiftMtDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "swift-mx", type = "object:org.apache.camel.model.dataformat.SwiftMxDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "syslog", type = "object:org.apache.camel.model.dataformat.SyslogDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "tar-file", type = "object:org.apache.camel.model.dataformat.TarFileDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "thrift", type = "object:org.apache.camel.model.dataformat.ThriftDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "tidy-markup", type = "object:org.apache.camel.model.dataformat.TidyMarkupDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-csv", type = "object:org.apache.camel.model.dataformat.UniVocityCsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-fixed", type = "object:org.apache.camel.model.dataformat.UniVocityFixedDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "univocity-tsv", type = "object:org.apache.camel.model.dataformat.UniVocityTsvDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "xml-security", type = "object:org.apache.camel.model.dataformat.XMLSecurityDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "yaml", type = "object:org.apache.camel.model.dataformat.YAMLDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "zip-deflater", type = "object:org.apache.camel.model.dataformat.ZipDeflaterDataFormat", oneOf = "dataFormatType"),
                    @YamlProperty(name = "zip-file", type = "object:org.apache.camel.model.dataformat.ZipFileDataFormat", oneOf = "dataFormatType")
            }
    )
    public static class UnmarshalDefinitionDeserializer extends YamlDeserializerBase<UnmarshalDefinition> {
        public UnmarshalDefinitionDeserializer() {
            super(UnmarshalDefinition.class);
        }

        @Override
        protected UnmarshalDefinition newInstance() {
            return new UnmarshalDefinition();
        }

        @Override
        protected boolean setProperty(UnmarshalDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-null-body": {
                    String val = asText(node);
                    target.setAllowNullBody(val);
                    break;
                }
                case "data-format-type": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "asn1": {
                    org.apache.camel.model.dataformat.ASN1DataFormat val = asType(node, org.apache.camel.model.dataformat.ASN1DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "avro": {
                    org.apache.camel.model.dataformat.AvroDataFormat val = asType(node, org.apache.camel.model.dataformat.AvroDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "barcode": {
                    org.apache.camel.model.dataformat.BarcodeDataFormat val = asType(node, org.apache.camel.model.dataformat.BarcodeDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "base64": {
                    org.apache.camel.model.dataformat.Base64DataFormat val = asType(node, org.apache.camel.model.dataformat.Base64DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "bindy": {
                    org.apache.camel.model.dataformat.BindyDataFormat val = asType(node, org.apache.camel.model.dataformat.BindyDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "cbor": {
                    org.apache.camel.model.dataformat.CBORDataFormat val = asType(node, org.apache.camel.model.dataformat.CBORDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "crypto": {
                    org.apache.camel.model.dataformat.CryptoDataFormat val = asType(node, org.apache.camel.model.dataformat.CryptoDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "csv": {
                    org.apache.camel.model.dataformat.CsvDataFormat val = asType(node, org.apache.camel.model.dataformat.CsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "custom": {
                    org.apache.camel.model.dataformat.CustomDataFormat val = asType(node, org.apache.camel.model.dataformat.CustomDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "fhir-json": {
                    org.apache.camel.model.dataformat.FhirJsonDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirJsonDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "fhir-xml": {
                    org.apache.camel.model.dataformat.FhirXmlDataFormat val = asType(node, org.apache.camel.model.dataformat.FhirXmlDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "flatpack": {
                    org.apache.camel.model.dataformat.FlatpackDataFormat val = asType(node, org.apache.camel.model.dataformat.FlatpackDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "grok": {
                    org.apache.camel.model.dataformat.GrokDataFormat val = asType(node, org.apache.camel.model.dataformat.GrokDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "gzip-deflater": {
                    org.apache.camel.model.dataformat.GzipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.GzipDeflaterDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "hl7": {
                    org.apache.camel.model.dataformat.HL7DataFormat val = asType(node, org.apache.camel.model.dataformat.HL7DataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "ical": {
                    org.apache.camel.model.dataformat.IcalDataFormat val = asType(node, org.apache.camel.model.dataformat.IcalDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "jackson-xml": {
                    org.apache.camel.model.dataformat.JacksonXMLDataFormat val = asType(node, org.apache.camel.model.dataformat.JacksonXMLDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "jaxb": {
                    org.apache.camel.model.dataformat.JaxbDataFormat val = asType(node, org.apache.camel.model.dataformat.JaxbDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "json": {
                    org.apache.camel.model.dataformat.JsonDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "json-api": {
                    org.apache.camel.model.dataformat.JsonApiDataFormat val = asType(node, org.apache.camel.model.dataformat.JsonApiDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "lzf": {
                    org.apache.camel.model.dataformat.LZFDataFormat val = asType(node, org.apache.camel.model.dataformat.LZFDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "mime-multipart": {
                    org.apache.camel.model.dataformat.MimeMultipartDataFormat val = asType(node, org.apache.camel.model.dataformat.MimeMultipartDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "parquet-avro": {
                    org.apache.camel.model.dataformat.ParquetAvroDataFormat val = asType(node, org.apache.camel.model.dataformat.ParquetAvroDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "protobuf": {
                    org.apache.camel.model.dataformat.ProtobufDataFormat val = asType(node, org.apache.camel.model.dataformat.ProtobufDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "rss": {
                    org.apache.camel.model.dataformat.RssDataFormat val = asType(node, org.apache.camel.model.dataformat.RssDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "soap": {
                    org.apache.camel.model.dataformat.SoapDataFormat val = asType(node, org.apache.camel.model.dataformat.SoapDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "swift-mt": {
                    org.apache.camel.model.dataformat.SwiftMtDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMtDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "swift-mx": {
                    org.apache.camel.model.dataformat.SwiftMxDataFormat val = asType(node, org.apache.camel.model.dataformat.SwiftMxDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "syslog": {
                    org.apache.camel.model.dataformat.SyslogDataFormat val = asType(node, org.apache.camel.model.dataformat.SyslogDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "tar-file": {
                    org.apache.camel.model.dataformat.TarFileDataFormat val = asType(node, org.apache.camel.model.dataformat.TarFileDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "thrift": {
                    org.apache.camel.model.dataformat.ThriftDataFormat val = asType(node, org.apache.camel.model.dataformat.ThriftDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "tidy-markup": {
                    org.apache.camel.model.dataformat.TidyMarkupDataFormat val = asType(node, org.apache.camel.model.dataformat.TidyMarkupDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-csv": {
                    org.apache.camel.model.dataformat.UniVocityCsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityCsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-fixed": {
                    org.apache.camel.model.dataformat.UniVocityFixedDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityFixedDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "univocity-tsv": {
                    org.apache.camel.model.dataformat.UniVocityTsvDataFormat val = asType(node, org.apache.camel.model.dataformat.UniVocityTsvDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "xml-security": {
                    org.apache.camel.model.dataformat.XMLSecurityDataFormat val = asType(node, org.apache.camel.model.dataformat.XMLSecurityDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "pgp": {
                    org.apache.camel.model.dataformat.PGPDataFormat val = asType(node, org.apache.camel.model.dataformat.PGPDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "yaml": {
                    org.apache.camel.model.dataformat.YAMLDataFormat val = asType(node, org.apache.camel.model.dataformat.YAMLDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "zip-deflater": {
                    org.apache.camel.model.dataformat.ZipDeflaterDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipDeflaterDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "zip-file": {
                    org.apache.camel.model.dataformat.ZipFileDataFormat val = asType(node, org.apache.camel.model.dataformat.ZipFileDataFormat.class);
                    target.setDataFormatType(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "validate",
            types = org.apache.camel.model.ValidateDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Validate",
            description = "Validates a message based on an expression",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression to use for validation as a predicate. The expression should return either true or false. If returning false the message is invalid and an exception is thrown.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "predicate-exception-factory", type = "string", description = "The bean id of custom PredicateExceptionFactory to use for creating the exception when the validation fails. By default, Camel will throw PredicateValidationException. By using a custom factory you can control which exception to throw instead.", displayName = "Predicate Exception Factory")
            }
    )
    public static class ValidateDefinitionDeserializer extends YamlDeserializerBase<ValidateDefinition> {
        public ValidateDefinitionDeserializer() {
            super(ValidateDefinition.class);
        }

        @Override
        protected ValidateDefinition newInstance() {
            return new ValidateDefinition();
        }

        @Override
        protected boolean setProperty(ValidateDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "predicate-exception-factory": {
                    String val = asText(node);
                    target.setPredicateExceptionFactory(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "validators",
            types = org.apache.camel.model.validator.ValidatorsDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Validations",
            description = "To configure validators.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "custom-validator", type = "object:org.apache.camel.model.validator.CustomValidatorDefinition"),
                    @YamlProperty(name = "endpoint-validator", type = "object:org.apache.camel.model.validator.EndpointValidatorDefinition"),
                    @YamlProperty(name = "predicate-validator", type = "object:org.apache.camel.model.validator.PredicateValidatorDefinition")
            }
    )
    public static class ValidatorsDefinitionDeserializer extends YamlDeserializerBase<ValidatorsDefinition> {
        public ValidatorsDefinitionDeserializer() {
            super(ValidatorsDefinition.class);
        }

        @Override
        protected ValidatorsDefinition newInstance() {
            return new ValidatorsDefinition();
        }

        @Override
        protected boolean setProperty(ValidatorsDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "validators": {
                    MappingNode val = asMappingNode(node);
                    setProperties(target, val);
                    break;
                }
                case "endpoint-validator": {
                    org.apache.camel.model.validator.EndpointValidatorDefinition val = asType(node, org.apache.camel.model.validator.EndpointValidatorDefinition.class);
                    java.util.List<org.apache.camel.model.validator.ValidatorDefinition> existing = target.getValidators();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setValidators(existing);
                    break;
                }
                case "predicate-validator": {
                    org.apache.camel.model.validator.PredicateValidatorDefinition val = asType(node, org.apache.camel.model.validator.PredicateValidatorDefinition.class);
                    java.util.List<org.apache.camel.model.validator.ValidatorDefinition> existing = target.getValidators();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setValidators(existing);
                    break;
                }
                case "custom-validator": {
                    org.apache.camel.model.validator.CustomValidatorDefinition val = asType(node, org.apache.camel.model.validator.CustomValidatorDefinition.class);
                    java.util.List<org.apache.camel.model.validator.ValidatorDefinition> existing = target.getValidators();
                    if (existing == null) {
                        existing = new java.util.ArrayList<>();
                    }
                    existing.add(val);
                    target.setValidators(existing);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "value",
            inline = true,
            types = org.apache.camel.model.ValueDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Value",
            description = "A single value",
            deprecated = false,
            properties = @YamlProperty(name = "value", type = "string", description = "Property value", displayName = "Value")
    )
    public static class ValueDefinitionDeserializer extends YamlDeserializerBase<ValueDefinition> {
        public ValueDefinitionDeserializer() {
            super(ValueDefinition.class);
        }

        @Override
        protected ValueDefinition newInstance() {
            return new ValueDefinition();
        }

        @Override
        protected ValueDefinition newInstance(String value) {
            return new ValueDefinition(value);
        }

        @Override
        protected boolean setProperty(ValueDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "weighted",
            types = org.apache.camel.model.loadbalancer.WeightedLoadBalancerDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Weighted",
            description = "Uses a weighted load distribution ratio for each server with respect to others.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "distribution-ratio", type = "string", required = true, description = "The distribution ratio is a delimited String consisting on integer weights separated by delimiters for example 2,3,5. The distributionRatio must match the number of endpoints and/or processors specified in the load balancer list.", displayName = "Distribution Ratio"),
                    @YamlProperty(name = "distribution-ratio-delimiter", type = "string", defaultValue = ",", description = "Delimiter used to specify the distribution ratio. The default value is , (comma)", displayName = "Distribution Ratio Delimiter"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "round-robin", type = "boolean", description = "To enable round robin mode. By default the weighted distribution mode is used. The default value is false.", displayName = "Round Robin")
            }
    )
    public static class WeightedLoadBalancerDefinitionDeserializer extends YamlDeserializerBase<WeightedLoadBalancerDefinition> {
        public WeightedLoadBalancerDefinitionDeserializer() {
            super(WeightedLoadBalancerDefinition.class);
        }

        @Override
        protected WeightedLoadBalancerDefinition newInstance() {
            return new WeightedLoadBalancerDefinition();
        }

        @Override
        protected boolean setProperty(WeightedLoadBalancerDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "distribution-ratio": {
                    String val = asText(node);
                    target.setDistributionRatio(val);
                    break;
                }
                case "distribution-ratio-delimiter": {
                    String val = asText(node);
                    target.setDistributionRatioDelimiter(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "round-robin": {
                    String val = asText(node);
                    target.setRoundRobin(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "when",
            types = org.apache.camel.model.WhenDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "When",
            description = "Triggers a route when the expression evaluates to true",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression used as the predicate to evaluate whether this when should trigger and route the message or not.", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class WhenDefinitionDeserializer extends YamlDeserializerBase<WhenDefinition> {
        public WhenDefinitionDeserializer() {
            super(WhenDefinition.class);
        }

        @Override
        protected WhenDefinition newInstance() {
            return new WhenDefinition();
        }

        @Override
        protected boolean setProperty(WhenDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "when-skip-send-to-endpoint",
                    "whenSkipSendToEndpoint"
            },
            types = org.apache.camel.model.WhenSkipSendToEndpointDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "When Skip Send To Endpoint",
            description = "Predicate to determine if the message should be sent or not to the endpoint, when using interceptSentToEndpoint.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "__extends", type = "object:org.apache.camel.model.language.ExpressionDefinition", oneOf = "expression"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "expression", type = "object:org.apache.camel.model.language.ExpressionDefinition", description = "Expression used as the predicate to evaluate whether the message should be sent or not to the endpoint", displayName = "Expression", oneOf = "expression"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "steps", type = "array:org.apache.camel.model.ProcessorDefinition")
            }
    )
    public static class WhenSkipSendToEndpointDefinitionDeserializer extends YamlDeserializerBase<WhenSkipSendToEndpointDefinition> {
        public WhenSkipSendToEndpointDefinitionDeserializer() {
            super(WhenSkipSendToEndpointDefinition.class);
        }

        @Override
        protected WhenSkipSendToEndpointDefinition newInstance() {
            return new WhenSkipSendToEndpointDefinition();
        }

        @Override
        protected boolean setProperty(WhenSkipSendToEndpointDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "expression": {
                    org.apache.camel.model.language.ExpressionDefinition val = asType(node, org.apache.camel.model.language.ExpressionDefinition.class);
                    target.setExpression(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                case "steps": {
                    setSteps(target, node);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "wire-tap",
                    "wireTap"
            },
            types = org.apache.camel.model.WireTapDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Wire Tap",
            description = "Routes a copy of a message (or creates a new message) to a secondary destination while continue routing the original message.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-optimised-components", type = "boolean", description = "Whether to allow components to optimise toD if they are org.apache.camel.spi.SendDynamicAware .", displayName = "Allow Optimised Components"),
                    @YamlProperty(name = "auto-start-components", type = "boolean", description = "Whether to auto startup components when toD is starting up.", displayName = "Auto Start Components"),
                    @YamlProperty(name = "cache-size", type = "number", description = "Sets the maximum size used by the org.apache.camel.spi.ProducerCache which is used to cache and reuse producers when using this recipient list, when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.", displayName = "Cache Size"),
                    @YamlProperty(name = "copy", type = "boolean", description = "Uses a copy of the original exchange", displayName = "Copy"),
                    @YamlProperty(name = "description", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "disabled", type = "boolean", description = "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.", displayName = "Disabled"),
                    @YamlProperty(name = "dynamic-uri", type = "boolean", description = "Whether the uri is dynamic or static. If the uri is dynamic then the simple language is used to evaluate a dynamic uri to use as the wire-tap destination, for each incoming message. This works similar to how the toD EIP pattern works. If static then the uri is used as-is as the wire-tap destination.", displayName = "Dynamic Uri"),
                    @YamlProperty(name = "executor-service", type = "string", description = "Uses a custom thread pool", displayName = "Executor Service"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "ignore-invalid-endpoint", type = "boolean", description = "Whether to ignore invalid endpoint URIs and skip sending the message.", displayName = "Ignore Invalid Endpoint"),
                    @YamlProperty(name = "inherit-error-handler", type = "boolean"),
                    @YamlProperty(name = "on-prepare", type = "string", description = "Uses the Processor when preparing the org.apache.camel.Exchange to be sent. This can be used to deep-clone messages that should be sent, or any custom logic needed before the exchange is sent.", displayName = "On Prepare"),
                    @YamlProperty(name = "parameters", type = "object"),
                    @YamlProperty(name = "pattern", type = "enum:InOnly,InOut", description = "Sets the optional ExchangePattern used to invoke this endpoint", displayName = "Pattern"),
                    @YamlProperty(name = "uri", type = "string", required = true, description = "The uri of the endpoint to send to. The uri can be dynamic computed using the org.apache.camel.language.simple.SimpleLanguage expression.", displayName = "Uri")
            }
    )
    public static class WireTapDefinitionDeserializer extends YamlDeserializerEndpointAwareBase<WireTapDefinition> {
        public WireTapDefinitionDeserializer() {
            super(WireTapDefinition.class);
        }

        @Override
        protected WireTapDefinition newInstance() {
            return new WireTapDefinition();
        }

        @Override
        protected void setEndpointUri(CamelContext camelContext, Node node,
                WireTapDefinition target, Map<String, Object> parameters) {
            target.setUri(org.apache.camel.dsl.yaml.common.YamlSupport.createEndpointUri(camelContext, node, target.getUri(), parameters));
        }

        @Override
        protected boolean setProperty(WireTapDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-optimised-components": {
                    String val = asText(node);
                    target.setAllowOptimisedComponents(val);
                    break;
                }
                case "auto-start-components": {
                    String val = asText(node);
                    target.setAutoStartComponents(val);
                    break;
                }
                case "cache-size": {
                    String val = asText(node);
                    target.setCacheSize(val);
                    break;
                }
                case "copy": {
                    String val = asText(node);
                    target.setCopy(val);
                    break;
                }
                case "disabled": {
                    String val = asText(node);
                    target.setDisabled(val);
                    break;
                }
                case "dynamic-uri": {
                    String val = asText(node);
                    target.setDynamicUri(val);
                    break;
                }
                case "executor-service": {
                    String val = asText(node);
                    target.setExecutorService(val);
                    break;
                }
                case "ignore-invalid-endpoint": {
                    String val = asText(node);
                    target.setIgnoreInvalidEndpoint(val);
                    break;
                }
                case "inherit-error-handler": {
                    String val = asText(node);
                    target.setInheritErrorHandler(java.lang.Boolean.valueOf(val));
                    break;
                }
                case "on-prepare": {
                    String val = asText(node);
                    target.setOnPrepare(val);
                    break;
                }
                case "pattern": {
                    String val = asText(node);
                    target.setPattern(val);
                    break;
                }
                case "uri": {
                    String val = asText(node);
                    target.setUri(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "description": {
                    String val = asText(node);
                    target.setDescription(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "xml-security",
                    "xmlSecurity"
            },
            types = org.apache.camel.model.dataformat.XMLSecurityDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "XML Security",
            description = "Encrypt and decrypt XML payloads using Apache Santuario.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "add-key-value-for-encrypted-key", type = "boolean", description = "Whether to add the public key used to encrypt the session key as a KeyValue in the EncryptedKey structure or not.", displayName = "Add Key Value For Encrypted Key"),
                    @YamlProperty(name = "digest-algorithm", type = "enum:SHA1,SHA256,SHA512", defaultValue = "SHA1", description = "The digest algorithm to use with the RSA OAEP algorithm. The available choices are: XMLCipher.SHA1 XMLCipher.SHA256 XMLCipher.SHA512 The default value is XMLCipher.SHA1", displayName = "Digest Algorithm"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "key-cipher-algorithm", type = "enum:RSA_v1dot5,RSA_OAEP,RSA_OAEP_11", defaultValue = "RSA_OAEP", description = "The cipher algorithm to be used for encryption/decryption of the asymmetric key. The available choices are: XMLCipher.RSA_v1dot5 XMLCipher.RSA_OAEP XMLCipher.RSA_OAEP_11 The default value is XMLCipher.RSA_OAEP", displayName = "Key Cipher Algorithm"),
                    @YamlProperty(name = "key-or-trust-store-parameters-ref", type = "string", description = "Refers to a KeyStore instance to lookup in the registry, which is used for configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.", displayName = "Key Or Trust Store Parameters Ref"),
                    @YamlProperty(name = "key-password", type = "string", description = "The password to be used for retrieving the private key from the KeyStore. This key is used for asymmetric decryption.", displayName = "Key Password"),
                    @YamlProperty(name = "mgf-algorithm", type = "enum:MGF1_SHA1,MGF1_SHA256,MGF1_SHA512", defaultValue = "MGF1_SHA1", description = "The MGF Algorithm to use with the RSA OAEP algorithm. The available choices are: EncryptionConstants.MGF1_SHA1 EncryptionConstants.MGF1_SHA256 EncryptionConstants.MGF1_SHA512 The default value is EncryptionConstants.MGF1_SHA1", displayName = "Mgf Algorithm"),
                    @YamlProperty(name = "pass-phrase", type = "string", description = "A String used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided. The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm. For example using TRIPLEDES the passPhase can be a Only another 24 Byte key", displayName = "Pass Phrase"),
                    @YamlProperty(name = "pass-phrase-byte", type = "string", format = "binary", description = "A byte used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided. The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm. For example using TRIPLEDES the passPhase can be a Only another 24 Byte key", displayName = "Pass Phrase Byte"),
                    @YamlProperty(name = "recipient-key-alias", type = "string", description = "The key alias to be used when retrieving the recipient's public or private key from a KeyStore when performing asymmetric key encryption or decryption.", displayName = "Recipient Key Alias"),
                    @YamlProperty(name = "secure-tag", type = "string", description = "The XPath reference to the XML Element selected for encryption/decryption. If no tag is specified, the entire payload is encrypted/decrypted.", displayName = "Secure Tag"),
                    @YamlProperty(name = "secure-tag-contents", type = "boolean", description = "A boolean value to specify whether the XML Element is to be encrypted or the contents of the XML Element. false = Element Level. true = Element Content Level.", displayName = "Secure Tag Contents"),
                    @YamlProperty(name = "xml-cipher-algorithm", type = "enum:TRIPLEDES,AES_128,AES_128_GCM,AES_192,AES_192_GCM,AES_256,AES_256_GCM,SEED_128,CAMELLIA_128,CAMELLIA_192,CAMELLIA_256", defaultValue = "AES-256-GCM", description = "The cipher algorithm to be used for encryption/decryption of the XML message content. The available choices are: XMLCipher.TRIPLEDES XMLCipher.AES_128 XMLCipher.AES_128_GCM XMLCipher.AES_192 XMLCipher.AES_192_GCM XMLCipher.AES_256 XMLCipher.AES_256_GCM XMLCipher.SEED_128 XMLCipher.CAMELLIA_128 XMLCipher.CAMELLIA_192 XMLCipher.CAMELLIA_256 The default value is XMLCipher.AES_256_GCM", displayName = "Xml Cipher Algorithm")
            }
    )
    public static class XMLSecurityDataFormatDeserializer extends YamlDeserializerBase<XMLSecurityDataFormat> {
        public XMLSecurityDataFormatDeserializer() {
            super(XMLSecurityDataFormat.class);
        }

        @Override
        protected XMLSecurityDataFormat newInstance() {
            return new XMLSecurityDataFormat();
        }

        @Override
        protected boolean setProperty(XMLSecurityDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "add-key-value-for-encrypted-key": {
                    String val = asText(node);
                    target.setAddKeyValueForEncryptedKey(val);
                    break;
                }
                case "digest-algorithm": {
                    String val = asText(node);
                    target.setDigestAlgorithm(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "key-cipher-algorithm": {
                    String val = asText(node);
                    target.setKeyCipherAlgorithm(val);
                    break;
                }
                case "key-or-trust-store-parameters-ref": {
                    String val = asText(node);
                    target.setKeyOrTrustStoreParametersRef(val);
                    break;
                }
                case "key-password": {
                    String val = asText(node);
                    target.setKeyPassword(val);
                    break;
                }
                case "mgf-algorithm": {
                    String val = asText(node);
                    target.setMgfAlgorithm(val);
                    break;
                }
                case "pass-phrase": {
                    String val = asText(node);
                    target.setPassPhrase(val);
                    break;
                }
                case "pass-phrase-byte": {
                    byte[] val = asByteArray(node);
                    target.setPassPhraseByte(val);
                    break;
                }
                case "recipient-key-alias": {
                    String val = asText(node);
                    target.setRecipientKeyAlias(val);
                    break;
                }
                case "secure-tag": {
                    String val = asText(node);
                    target.setSecureTag(val);
                    break;
                }
                case "secure-tag-contents": {
                    String val = asText(node);
                    target.setSecureTagContents(val);
                    break;
                }
                case "xml-cipher-algorithm": {
                    String val = asText(node);
                    target.setXmlCipherAlgorithm(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "xtokenize",
            inline = true,
            types = org.apache.camel.model.language.XMLTokenizerExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "XML Tokenize",
            description = "Tokenize XML payloads.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "group", type = "number", description = "To group N parts together", displayName = "Group"),
                    @YamlProperty(name = "header-name", type = "string", description = "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set.", displayName = "Header Name"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "mode", type = "enum:i,w,u,t", defaultValue = "i", description = "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element", displayName = "Mode"),
                    @YamlProperty(name = "namespace", type = "array:org.apache.camel.model.PropertyDefinition", description = "Injects the XML Namespaces of prefix - uri mappings", displayName = "Namespace"),
                    @YamlProperty(name = "property-name", type = "string", description = "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set.", displayName = "Property Name"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class XMLTokenizerExpressionDeserializer extends YamlDeserializerBase<XMLTokenizerExpression> {
        public XMLTokenizerExpressionDeserializer() {
            super(XMLTokenizerExpression.class);
        }

        @Override
        protected XMLTokenizerExpression newInstance() {
            return new XMLTokenizerExpression();
        }

        @Override
        protected XMLTokenizerExpression newInstance(String value) {
            return new XMLTokenizerExpression(value);
        }

        @Override
        protected boolean setProperty(XMLTokenizerExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "group": {
                    String val = asText(node);
                    target.setGroup(val);
                    break;
                }
                case "header-name": {
                    String val = asText(node);
                    target.setHeaderName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "mode": {
                    String val = asText(node);
                    target.setMode(val);
                    break;
                }
                case "namespace": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setNamespace(val);
                    break;
                }
                case "property-name": {
                    String val = asText(node);
                    target.setPropertyName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "xpath",
            inline = true,
            types = org.apache.camel.model.language.XPathExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "XPath",
            description = "Evaluates an XPath expression against an XML payload.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "document-type", type = "string", description = "Name of class for document type The default value is org.w3c.dom.Document", displayName = "Document Type"),
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "factory-ref", type = "string", description = "References to a custom XPathFactory to lookup in the registry", displayName = "Factory Ref"),
                    @YamlProperty(name = "header-name", type = "string", description = "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set.", displayName = "Header Name"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "log-namespaces", type = "boolean", description = "Whether to log namespaces which can assist during troubleshooting", displayName = "Log Namespaces"),
                    @YamlProperty(name = "namespace", type = "array:org.apache.camel.model.PropertyDefinition", description = "Injects the XML Namespaces of prefix - uri mappings", displayName = "Namespace"),
                    @YamlProperty(name = "object-model", type = "string", description = "The XPath object model to use", displayName = "Object Model"),
                    @YamlProperty(name = "pre-compile", type = "boolean", description = "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime.", displayName = "Pre Compile"),
                    @YamlProperty(name = "property-name", type = "string", description = "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set.", displayName = "Property Name"),
                    @YamlProperty(name = "result-type", type = "enum:NUMBER,STRING,BOOLEAN,NODESET,NODE", defaultValue = "NODESET", description = "Sets the class name of the result type (type from output) The default result type is NodeSet", displayName = "Result Type"),
                    @YamlProperty(name = "saxon", type = "boolean", description = "Whether to use Saxon.", displayName = "Saxon"),
                    @YamlProperty(name = "thread-safety", type = "boolean", description = "Whether to enable thread-safety for the returned result of the xpath expression. This applies to when using NODESET as the result type, and the returned set has multiple elements. In this situation there can be thread-safety issues if you process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode. This option prevents concurrency issues by doing defensive copies of the nodes. It is recommended to turn this option on if you are using camel-saxon or Saxon in your application. Saxon has thread-safety issues which can be prevented by turning this option on.", displayName = "Thread Safety"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
            }
    )
    public static class XPathExpressionDeserializer extends YamlDeserializerBase<XPathExpression> {
        public XPathExpressionDeserializer() {
            super(XPathExpression.class);
        }

        @Override
        protected XPathExpression newInstance() {
            return new XPathExpression();
        }

        @Override
        protected XPathExpression newInstance(String value) {
            return new XPathExpression(value);
        }

        @Override
        protected boolean setProperty(XPathExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "document-type": {
                    String val = asText(node);
                    target.setDocumentTypeName(val);
                    break;
                }
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "factory-ref": {
                    String val = asText(node);
                    target.setFactoryRef(val);
                    break;
                }
                case "header-name": {
                    String val = asText(node);
                    target.setHeaderName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "log-namespaces": {
                    String val = asText(node);
                    target.setLogNamespaces(val);
                    break;
                }
                case "namespace": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setNamespace(val);
                    break;
                }
                case "object-model": {
                    String val = asText(node);
                    target.setObjectModel(val);
                    break;
                }
                case "pre-compile": {
                    String val = asText(node);
                    target.setPreCompile(val);
                    break;
                }
                case "property-name": {
                    String val = asText(node);
                    target.setPropertyName(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "saxon": {
                    String val = asText(node);
                    target.setSaxon(val);
                    break;
                }
                case "thread-safety": {
                    String val = asText(node);
                    target.setThreadSafety(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "xquery",
            inline = true,
            types = org.apache.camel.model.language.XQueryExpression.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "XQuery",
            description = "Evaluates an XQuery expressions against an XML payload.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "configuration-ref", type = "string", description = "Reference to a saxon configuration instance in the registry to use for xquery (requires camel-saxon). This may be needed to add custom functions to a saxon configuration, so these custom functions can be used in xquery expressions.", displayName = "Configuration Ref"),
                    @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                    @YamlProperty(name = "header-name", type = "string", description = "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set.", displayName = "Header Name"),
                    @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                    @YamlProperty(name = "namespace", type = "array:org.apache.camel.model.PropertyDefinition", description = "Injects the XML Namespaces of prefix - uri mappings", displayName = "Namespace"),
                    @YamlProperty(name = "property-name", type = "string", description = "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set.", displayName = "Property Name"),
                    @YamlProperty(name = "result-type", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
                    @YamlProperty(name = "type", type = "string", description = "Sets the class name of the result type (type from output) The default result type is NodeSet", displayName = "Type")
            }
    )
    public static class XQueryExpressionDeserializer extends YamlDeserializerBase<XQueryExpression> {
        public XQueryExpressionDeserializer() {
            super(XQueryExpression.class);
        }

        @Override
        protected XQueryExpression newInstance() {
            return new XQueryExpression();
        }

        @Override
        protected XQueryExpression newInstance(String value) {
            return new XQueryExpression(value);
        }

        @Override
        protected boolean setProperty(XQueryExpression target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "configuration-ref": {
                    String val = asText(node);
                    target.setConfigurationRef(val);
                    break;
                }
                case "expression": {
                    String val = asText(node);
                    target.setExpression(val);
                    break;
                }
                case "header-name": {
                    String val = asText(node);
                    target.setHeaderName(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "namespace": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setNamespace(val);
                    break;
                }
                case "property-name": {
                    String val = asText(node);
                    target.setPropertyName(val);
                    break;
                }
                case "result-type": {
                    String val = asText(node);
                    target.setResultTypeName(val);
                    break;
                }
                case "trim": {
                    String val = asText(node);
                    target.setTrim(val);
                    break;
                }
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                default: {
                    ExpressionDefinition ed = target.getExpressionType();
                    if (ed != null) {
                        throw new org.apache.camel.dsl.yaml.common.exception.DuplicateFieldException(node, propertyName, "as an expression");
                    }
                    ed = ExpressionDeserializers.constructExpressionType(propertyKey, node);
                    if (ed != null) {
                        target.setExpressionType(ed);
                    } else {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = "yaml",
            types = org.apache.camel.model.dataformat.YAMLDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "YAML",
            description = "Marshal and unmarshal Java objects to and from YAML.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-any-type", type = "boolean", description = "Allow any class to be un-marshaled", displayName = "Allow Any Type"),
                    @YamlProperty(name = "allow-recursive-keys", type = "boolean", description = "Set whether recursive keys are allowed.", displayName = "Allow Recursive Keys"),
                    @YamlProperty(name = "constructor", type = "string", description = "BaseConstructor to construct incoming documents.", displayName = "Constructor"),
                    @YamlProperty(name = "dumper-options", type = "string", description = "DumperOptions to configure outgoing objects.", displayName = "Dumper Options"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "library", type = "enum:SnakeYAML", defaultValue = "SnakeYAML", description = "Which yaml library to use. By default it is SnakeYAML", displayName = "Library"),
                    @YamlProperty(name = "max-aliases-for-collections", type = "number", defaultValue = "50", description = "Set the maximum amount of aliases allowed for collections.", displayName = "Max Aliases For Collections"),
                    @YamlProperty(name = "pretty-flow", type = "boolean", description = "Force the emitter to produce a pretty YAML document when using the flow style.", displayName = "Pretty Flow"),
                    @YamlProperty(name = "representer", type = "string", description = "Representer to emit outgoing objects.", displayName = "Representer"),
                    @YamlProperty(name = "resolver", type = "string", description = "Resolver to detect implicit type", displayName = "Resolver"),
                    @YamlProperty(name = "type-filter", type = "array:org.apache.camel.model.dataformat.YAMLTypeFilterDefinition", description = "Set the types SnakeYAML is allowed to un-marshall", displayName = "Type Filter"),
                    @YamlProperty(name = "unmarshal-type", type = "string", description = "Class name of the java type to use when unmarshalling", displayName = "Unmarshal Type"),
                    @YamlProperty(name = "use-application-context-class-loader", type = "boolean", description = "Use ApplicationContextClassLoader as custom ClassLoader", displayName = "Use Application Context Class Loader")
            }
    )
    public static class YAMLDataFormatDeserializer extends YamlDeserializerBase<YAMLDataFormat> {
        public YAMLDataFormatDeserializer() {
            super(YAMLDataFormat.class);
        }

        @Override
        protected YAMLDataFormat newInstance() {
            return new YAMLDataFormat();
        }

        @Override
        protected boolean setProperty(YAMLDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-any-type": {
                    String val = asText(node);
                    target.setAllowAnyType(val);
                    break;
                }
                case "allow-recursive-keys": {
                    String val = asText(node);
                    target.setAllowRecursiveKeys(val);
                    break;
                }
                case "constructor": {
                    String val = asText(node);
                    target.setConstructor(val);
                    break;
                }
                case "dumper-options": {
                    String val = asText(node);
                    target.setDumperOptions(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "library": {
                    target.setLibrary(asEnum(node, org.apache.camel.model.dataformat.YAMLLibrary.class));
                    break;
                }
                case "max-aliases-for-collections": {
                    String val = asText(node);
                    target.setMaxAliasesForCollections(val);
                    break;
                }
                case "pretty-flow": {
                    String val = asText(node);
                    target.setPrettyFlow(val);
                    break;
                }
                case "representer": {
                    String val = asText(node);
                    target.setRepresenter(val);
                    break;
                }
                case "resolver": {
                    String val = asText(node);
                    target.setResolver(val);
                    break;
                }
                case "type-filter": {
                    java.util.List<org.apache.camel.model.dataformat.YAMLTypeFilterDefinition> val = asFlatList(node, org.apache.camel.model.dataformat.YAMLTypeFilterDefinition.class);
                    target.setTypeFilters(val);
                    break;
                }
                case "unmarshal-type": {
                    String val = asText(node);
                    target.setUnmarshalTypeName(val);
                    break;
                }
                case "use-application-context-class-loader": {
                    String val = asText(node);
                    target.setUseApplicationContextClassLoader(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "type-filter",
                    "typeFilter"
            },
            types = org.apache.camel.model.dataformat.YAMLTypeFilterDefinition.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "YAML Type Filter",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "type", type = "string", description = "Whether to filter by class type or regular expression", displayName = "Type"),
                    @YamlProperty(name = "value", type = "string", description = "Value of type such as class name or regular expression", displayName = "Value")
            }
    )
    public static class YAMLTypeFilterDefinitionDeserializer extends YamlDeserializerBase<YAMLTypeFilterDefinition> {
        public YAMLTypeFilterDefinitionDeserializer() {
            super(YAMLTypeFilterDefinition.class);
        }

        @Override
        protected YAMLTypeFilterDefinition newInstance() {
            return new YAMLTypeFilterDefinition();
        }

        @Override
        protected boolean setProperty(YAMLTypeFilterDefinition target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "type": {
                    String val = asText(node);
                    target.setType(val);
                    break;
                }
                case "value": {
                    String val = asText(node);
                    target.setValue(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "zip-deflater",
                    "zipDeflater"
            },
            types = org.apache.camel.model.dataformat.ZipDeflaterDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Zip Deflater",
            description = "Compress and decompress streams using java.util.zip.Deflater and java.util.zip.Inflater.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "compression-level", type = "enum:-1,0,1,2,3,4,5,6,7,8,9", defaultValue = "-1", description = "To specify a specific compression between 0-9. -1 is default compression, 0 is no compression, and 9 is the best compression.", displayName = "Compression Level"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id")
            }
    )
    public static class ZipDeflaterDataFormatDeserializer extends YamlDeserializerBase<ZipDeflaterDataFormat> {
        public ZipDeflaterDataFormatDeserializer() {
            super(ZipDeflaterDataFormat.class);
        }

        @Override
        protected ZipDeflaterDataFormat newInstance() {
            return new ZipDeflaterDataFormat();
        }

        @Override
        protected boolean setProperty(ZipDeflaterDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "compression-level": {
                    String val = asText(node);
                    target.setCompressionLevel(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "zip-file",
                    "zipFile"
            },
            types = org.apache.camel.model.dataformat.ZipFileDataFormat.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Zip File",
            description = "Compression and decompress streams using java.util.zip.ZipStream.",
            deprecated = false,
            properties = {
                    @YamlProperty(name = "allow-empty-directory", type = "boolean", description = "If the zip file has more than one entry, setting this option to true, allows to get the iterator even if the directory is empty", displayName = "Allow Empty Directory"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "max-decompressed-size", type = "number", defaultValue = "1073741824", description = "Set the maximum decompressed size of a zip file (in bytes). The default value if not specified corresponds to 1 gigabyte. An IOException will be thrown if the decompressed size exceeds this amount. Set to -1 to disable setting a maximum decompressed size.", displayName = "Max Decompressed Size"),
                    @YamlProperty(name = "preserve-path-elements", type = "boolean", description = "If the file name contains path elements, setting this option to true, allows the path to be maintained in the zip file.", displayName = "Preserve Path Elements"),
                    @YamlProperty(name = "using-iterator", type = "boolean", description = "If the zip file has more than one entry, the setting this option to true, allows working with the splitter EIP, to split the data using an iterator in a streaming mode.", displayName = "Using Iterator")
            }
    )
    public static class ZipFileDataFormatDeserializer extends YamlDeserializerBase<ZipFileDataFormat> {
        public ZipFileDataFormatDeserializer() {
            super(ZipFileDataFormat.class);
        }

        @Override
        protected ZipFileDataFormat newInstance() {
            return new ZipFileDataFormat();
        }

        @Override
        protected boolean setProperty(ZipFileDataFormat target, String propertyKey,
                String propertyName, Node node) {
            switch(propertyKey) {
                case "allow-empty-directory": {
                    String val = asText(node);
                    target.setAllowEmptyDirectory(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "max-decompressed-size": {
                    String val = asText(node);
                    target.setMaxDecompressedSize(val);
                    break;
                }
                case "preserve-path-elements": {
                    String val = asText(node);
                    target.setPreservePathElements(val);
                    break;
                }
                case "using-iterator": {
                    String val = asText(node);
                    target.setUsingIterator(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }

    @YamlType(
            nodes = {
                    "zookeeper-service-discovery",
                    "zookeeperServiceDiscovery"
            },
            types = org.apache.camel.model.cloud.ZooKeeperServiceCallServiceDiscoveryConfiguration.class,
            order = org.apache.camel.dsl.yaml.common.YamlDeserializerResolver.ORDER_LOWEST - 1,
            displayName = "Zookeeper Service Discovery",
            deprecated = true,
            properties = {
                    @YamlProperty(name = "base-path", type = "string", required = true, description = "Set the base path to store in ZK", displayName = "Base Path"),
                    @YamlProperty(name = "connection-timeout", type = "string", description = "Connection timeout.", displayName = "Connection Timeout"),
                    @YamlProperty(name = "id", type = "string", description = "The id of this node", displayName = "Id"),
                    @YamlProperty(name = "namespace", type = "string", description = "As ZooKeeper is a shared space, users of a given cluster should stay within a pre-defined namespace. If a namespace is set here, all paths will get pre-pended with the namespace", displayName = "Namespace"),
                    @YamlProperty(name = "nodes", type = "string", required = true, description = "A comma separate list of servers to connect to in the form host:port", displayName = "Nodes"),
                    @YamlProperty(name = "properties", type = "array:org.apache.camel.model.PropertyDefinition", description = "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using a different one, then the client properties are defined according to the specific service in use.", displayName = "Properties"),
                    @YamlProperty(name = "reconnect-base-sleep-time", type = "string", description = "Initial amount of time to wait between retries.", displayName = "Reconnect Base Sleep Time"),
                    @YamlProperty(name = "reconnect-max-retries", type = "string", description = "Max number of times to retry", displayName = "Reconnect Max Retries"),
                    @YamlProperty(name = "reconnect-max-sleep-time", type = "string", description = "Max time in ms to sleep on each retry", displayName = "Reconnect Max Sleep Time"),
                    @YamlProperty(name = "session-timeout", type = "string", description = "Session timeout.", displayName = "Session Timeout")
            }
    )
    public static class ZooKeeperServiceCallServiceDiscoveryConfigurationDeserializer extends YamlDeserializerBase<ZooKeeperServiceCallServiceDiscoveryConfiguration> {
        public ZooKeeperServiceCallServiceDiscoveryConfigurationDeserializer() {
            super(ZooKeeperServiceCallServiceDiscoveryConfiguration.class);
        }

        @Override
        protected ZooKeeperServiceCallServiceDiscoveryConfiguration newInstance() {
            return new ZooKeeperServiceCallServiceDiscoveryConfiguration();
        }

        @Override
        protected boolean setProperty(ZooKeeperServiceCallServiceDiscoveryConfiguration target,
                String propertyKey, String propertyName, Node node) {
            switch(propertyKey) {
                case "base-path": {
                    String val = asText(node);
                    target.setBasePath(val);
                    break;
                }
                case "connection-timeout": {
                    String val = asText(node);
                    target.setConnectionTimeout(val);
                    break;
                }
                case "id": {
                    String val = asText(node);
                    target.setId(val);
                    break;
                }
                case "namespace": {
                    String val = asText(node);
                    target.setNamespace(val);
                    break;
                }
                case "nodes": {
                    String val = asText(node);
                    target.setNodes(val);
                    break;
                }
                case "properties": {
                    java.util.List<org.apache.camel.model.PropertyDefinition> val = asFlatList(node, org.apache.camel.model.PropertyDefinition.class);
                    target.setProperties(val);
                    break;
                }
                case "reconnect-base-sleep-time": {
                    String val = asText(node);
                    target.setReconnectBaseSleepTime(val);
                    break;
                }
                case "reconnect-max-retries": {
                    String val = asText(node);
                    target.setReconnectMaxRetries(val);
                    break;
                }
                case "reconnect-max-sleep-time": {
                    String val = asText(node);
                    target.setReconnectMaxSleepTime(val);
                    break;
                }
                case "session-timeout": {
                    String val = asText(node);
                    target.setSessionTimeout(val);
                    break;
                }
                default: {
                    return false;
                }
            }
            return true;
        }
    }
}
