/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dsl.jbang.core.commands.k;

import java.io.InputStream;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

import org.apache.camel.dsl.jbang.core.commands.CamelJBangMain;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.v1.integrationspec.Traits;
import org.apache.camel.v1.integrationspec.traits.ServiceBinding;
import picocli.CommandLine;
import picocli.CommandLine.Command;

@Command(name = "bind",
         description = "Bind Kubernetes resources such as Kamelets in a new integration pipe connecting a source and a sink",
         sortOptions = false)
public class Bind extends KubeBaseCommand {

    private final org.apache.camel.dsl.jbang.core.commands.Bind delegate;

    @CommandLine.Parameters(description = "Name of pipe", arity = "1",
                            paramLabel = "<name>", parameterConsumer = NameConsumer.class)
    Path pipeName; // Defined only for code completion; the field never used
    String name;

    @CommandLine.Option(names = { "--source" }, description = "Source (from) such as a Kamelet or Camel endpoint uri",
                        required = true)
    String source;

    @CommandLine.Option(names = { "--step" }, description = "Optional steps such as a Kamelet or Camel endpoint uri")
    String[] steps;

    @CommandLine.Option(names = { "--sink" }, description = "Sink (to) such as a Kamelet or Camel endpoint uri",
                        required = true)
    String sink;

    @CommandLine.Option(names = { "--error-handler" },
                        description = "Add error handler (none|log|sink:<endpoint>). Sink endpoints are expected in the format \"[[apigroup/]version:]kind:[namespace/]name\", plain Camel URIs or Kamelet name.")
    String errorHandler;

    @CommandLine.Option(names = { "--property" },
                        description = "Adds a pipe property in the form of [source|sink|step-<n>].<key>=<value> where <n> is the step number starting from 1",
                        arity = "0")
    String[] properties;

    @CommandLine.Option(names = { "--output" },
                        defaultValue = "file",
                        description = "Output format generated by this command (supports: file, yaml or json).")
    String output;

    @CommandLine.Option(names = { "--operator-id" },
                        defaultValue = "camel-k",
                        description = "Operator id selected to manage this integration.")
    String operatorId = "camel-k";

    @CommandLine.Option(names = { "--connect" },
                        description = "A Service that the integration should bind to, specified as [[apigroup/]version:]kind:[namespace/]name.")
    String[] connects;

    @CommandLine.Option(names = { "--annotation" },
                        description = "Add an annotation to the integration. Use name values pairs like \"--annotation my.company=hello\".")
    String[] annotations;

    @CommandLine.Option(names = { "--traits" },
                        description = "Add a label to the integration. Use name values pairs like \"--label my.company=hello\".")
    String[] traits;

    public Bind(CamelJBangMain main) {
        super(main);
        delegate = new org.apache.camel.dsl.jbang.core.commands.Bind(
                main, new org.apache.camel.dsl.jbang.core.commands.Bind.TemplateProvider() {
                    @Override
                    public InputStream getPipeTemplate(String in, String out) {
                        return Bind.class.getClassLoader()
                                .getResourceAsStream("templates/pipe-" + in + "-" + out + ".yaml.tmpl");
                    }
                });
    }

    @Override
    public Integer doCall() throws Exception {
        // Operator id must be set
        if (ObjectHelper.isEmpty(operatorId)) {
            printer().println("Operator id must be set");
            return -1;
        }

        delegate.setFile(name);
        delegate.setSource(source);
        delegate.setSink(sink);
        delegate.setSteps(steps);
        delegate.setErrorHandler(errorHandler);
        delegate.setProperties(properties);
        delegate.setOutput(output);

        String pipe = delegate.constructPipe();

        if (pipe.isEmpty()) {
            // Error in delegate exit now
            printer().println("Failed to construct Pipe resource");
            return -1;
        }

        // --operator-id={id} is a syntax sugar for '--annotation camel.apache.org/operator.id={id}'
        if (annotations == null) {
            annotations = new String[] { "%s=%s".formatted(KubeCommand.OPERATOR_ID_LABEL, operatorId) };
        } else {
            annotations = Arrays.copyOf(annotations, annotations.length + 1);
            annotations[annotations.length - 1] = "%s=%s".formatted(KubeCommand.OPERATOR_ID_LABEL, operatorId);
        }

        String annotationsContext = "";
        if (annotations != null) {
            StringBuilder sb = new StringBuilder("  annotations:\n");

            for (String annotation : annotations) {
                String[] keyValue = annotation.split("=", 2);
                if (keyValue.length != 2) {
                    printer().printf(
                            "annotation '%s' does not follow format <key>=<value>%n",
                            annotation);
                    continue;
                }

                sb.append("    ").append(keyValue[0]).append(": ").append(keyValue[1]).append("\n");
            }

            annotationsContext = sb.toString();
        }

        pipe = pipe.replaceFirst("\\{\\{ \\.Annotations }}\n", annotationsContext);

        String integrationSpec = "";
        Traits traitsSpec = null;
        if (traits != null && traits.length > 0) {
            traitsSpec = TraitHelper.parseTraits(traits);
        }

        if (connects != null && connects.length > 0) {
            if (traitsSpec == null) {
                traitsSpec = new Traits();
            }

            ServiceBinding serviceBindingTrait = new ServiceBinding();
            serviceBindingTrait.setServices(List.of(connects));
            traitsSpec.setServiceBinding(serviceBindingTrait);
        }

        if (traitsSpec != null) {
            String traitYaml = KubernetesHelper.yaml().dumpAsMap(traitsSpec).replaceAll("\n", "\n        ");
            integrationSpec = "  integration:\n    spec:\n      traits:\n        %s\n".formatted(traitYaml.trim());
        }

        pipe = pipe.replaceFirst("\\{\\{ \\.IntegrationSpec }}\n", integrationSpec);

        return delegate.dumpPipe(pipe);
    }

    static class NameConsumer extends ParameterConsumer<Bind> {
        @Override
        protected void doConsumeParameters(Stack<String> args, Bind cmd) {
            cmd.name = args.pop();
        }
    }

}
