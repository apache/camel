{
  "component": {
    "kind": "component",
    "name": "rabbitmq",
    "title": "RabbitMQ",
    "description": "Send and receive messages from RabbitMQ instances.",
    "deprecated": false,
    "firstVersion": "2.12.0",
    "label": "messaging",
    "javaType": "org.apache.camel.component.rabbitmq.RabbitMQComponent",
    "supportLevel": "Stable",
    "groupId": "org.apache.camel",
    "artifactId": "camel-rabbitmq",
    "version": "3.7.0-SNAPSHOT",
    "scheme": "rabbitmq",
    "extendsScheme": "",
    "syntax": "rabbitmq:exchangeName",
    "async": true,
    "api": false,
    "consumerOnly": false,
    "producerOnly": false,
    "lenientProperties": false
  },
  "componentProperties": {
    "addresses": { "kind": "property", "displayName": "Addresses", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "If this option is set, camel-rabbitmq will try to create connection based on the setting of option addresses. The addresses value is a string which looks like server1:12345, server2:12345" },
    "autoDelete": { "kind": "property", "displayName": "Auto Delete", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If it is true, the exchange will be deleted when it is no longer in use" },
    "connectionFactory": { "kind": "property", "displayName": "Connection Factory", "group": "common", "label": "common", "required": false, "type": "object", "javaType": "com.rabbitmq.client.ConnectionFactory", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom RabbitMQ connection factory. When this option is set, all connection options (connectionTimeout, requestedChannelMax...) set on URI are not used" },
    "deadLetterExchange": { "kind": "property", "displayName": "Dead Letter Exchange", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The name of the dead letter exchange" },
    "deadLetterExchangeType": { "kind": "property", "displayName": "Dead Letter Exchange Type", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "enum": [ "direct", "fanout", "headers", "topic" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "direct", "description": "The type of the dead letter exchange" },
    "deadLetterQueue": { "kind": "property", "displayName": "Dead Letter Queue", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The name of the dead letter queue" },
    "deadLetterRoutingKey": { "kind": "property", "displayName": "Dead Letter Routing Key", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The routing key for the dead letter exchange" },
    "declare": { "kind": "property", "displayName": "Declare", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If the option is true, camel declare the exchange and queue name and bind them together. If the option is false, camel won't declare the exchange and queue name on the server." },
    "durable": { "kind": "property", "displayName": "Durable", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If we are declaring a durable exchange (the exchange will survive a server restart)" },
    "exclusive": { "kind": "property", "displayName": "Exclusive", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes." },
    "hostname": { "kind": "property", "displayName": "Hostname", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The hostname of the running RabbitMQ instance or cluster." },
    "passive": { "kind": "property", "displayName": "Passive", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Passive queues depend on the queue already to be available at RabbitMQ." },
    "portNumber": { "kind": "property", "displayName": "Port Number", "group": "common", "label": "common", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 5672, "description": "Port number for the host with the running rabbitmq instance or cluster." },
    "skipExchangeDeclare": { "kind": "property", "displayName": "Skip Exchange Declare", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "This can be used if we need to declare the queue but not the exchange" },
    "skipQueueBind": { "kind": "property", "displayName": "Skip Queue Bind", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true the queue will not be bound to the exchange after declaring it" },
    "skipQueueDeclare": { "kind": "property", "displayName": "Skip Queue Declare", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key." },
    "vhost": { "kind": "property", "displayName": "Vhost", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "\/", "description": "The vhost for the channel" },
    "autoAck": { "kind": "property", "displayName": "Auto Ack", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If messages should be auto acknowledged" },
    "bridgeErrorHandler": { "kind": "property", "displayName": "Bridge Error Handler", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
    "exclusiveConsumer": { "kind": "property", "displayName": "Exclusive Consumer", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful when you want a long-lived shared queue to be temporarily accessible by just one consumer." },
    "prefetchCount": { "kind": "property", "displayName": "Prefetch Count", "group": "consumer", "label": "consumer", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The maximum number of messages that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "prefetchEnabled": { "kind": "property", "displayName": "Prefetch Enabled", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Enables the quality of service on the RabbitMQConsumer side. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "prefetchGlobal": { "kind": "property", "displayName": "Prefetch Global", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the settings should be applied to the entire channel rather than each consumer You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "prefetchSize": { "kind": "property", "displayName": "Prefetch Size", "group": "consumer", "label": "consumer", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The maximum amount of content (measured in octets) that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "threadPoolSize": { "kind": "property", "displayName": "Thread Pool Size", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 10, "description": "The consumer uses a Thread Pool Executor with a fixed number of threads. This setting allows you to set that number of threads." },
    "additionalHeaders": { "kind": "property", "displayName": "Additional Headers", "group": "producer", "label": "producer", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Map of additional headers. These headers will be set only when the 'allowCustomHeaders' is set to true" },
    "additionalProperties": { "kind": "property", "displayName": "Additional Properties", "group": "producer", "label": "producer", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Map of additional properties. These are standard RabbitMQ properties as defined in com.rabbitmq.client.AMQP.BasicProperties The map keys should be from org.apache.camel.component.rabbitmq.RabbitMQConstants. Any other keys will be ignored. When the message already contains these headers they will be given precedence over these properties." },
    "allowNullHeaders": { "kind": "property", "displayName": "Allow Null Headers", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allow pass null values to header" },
    "channelPoolMaxSize": { "kind": "property", "displayName": "Channel Pool Max Size", "group": "producer", "label": "producer", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 10, "description": "Get maximum number of opened channel in pool" },
    "channelPoolMaxWait": { "kind": "property", "displayName": "Channel Pool Max Wait", "group": "producer", "label": "producer", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Set the maximum number of milliseconds to wait for a channel from the pool" },
    "guaranteedDeliveries": { "kind": "property", "displayName": "Guaranteed Deliveries", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "When true, an exception will be thrown when the message cannot be delivered (basic.return) and the message is marked as mandatory. PublisherAcknowledgement will also be activated in this case. See also publisher acknowledgements - When will messages be confirmed." },
    "immediate": { "kind": "property", "displayName": "Immediate", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is zero, the server will queue the message, but with no guarantee that it will ever be consumed. If the header is present rabbitmq.IMMEDIATE it will override this option." },
    "lazyStartProducer": { "kind": "property", "displayName": "Lazy Start Producer", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
    "mandatory": { "kind": "property", "displayName": "Mandatory", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set, the server will return an unroutable message with a Return method. If this flag is zero, the server silently drops the message. If the header is present rabbitmq.MANDATORY it will override this option." },
    "publisherAcknowledgements": { "kind": "property", "displayName": "Publisher Acknowledgements", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "When true, the message will be published with publisher acknowledgements turned on" },
    "publisherAcknowledgementsTimeout": { "kind": "property", "displayName": "Publisher Acknowledgements Timeout", "group": "producer", "label": "producer", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "description": "The amount of time in milliseconds to wait for a basic.ack response from RabbitMQ server" },
    "args": { "kind": "property", "displayName": "Args", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each: Exchange: arg.exchange. Queue: arg.queue. Binding: arg.binding. DLQ: arg.dlq.queue. DLQ Binding: arg.dlq.binding. For example to declare a queue with message ttl argument: http:\/\/localhost:5672\/exchange\/queueargs=arg.queue.x-message-ttl=60000" },
    "autoDetectConnectionFactory": { "kind": "property", "displayName": "Auto Detect Connection Factory", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to auto-detect looking up RabbitMQ connection factory from the registry. When enabled and a single instance of the connection factory is found then it will be used. An explicit connection factory can be configured on the component or endpoint level which takes precedence." },
    "automaticRecoveryEnabled": { "kind": "property", "displayName": "Automatic Recovery Enabled", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "description": "Enables connection automatic recovery (uses connection implementation that performs automatic recovery when connection shutdown is not initiated by the application)" },
    "autowiredEnabled": { "kind": "property", "displayName": "Autowired Enabled", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc." },
    "clientProperties": { "kind": "property", "displayName": "Client Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Connection client properties (client info used in negotiating with the server)" },
    "connectionFactoryExceptionHandler": { "kind": "property", "displayName": "Connection Factory Exception Handler", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "com.rabbitmq.client.ExceptionHandler", "deprecated": false, "autowired": false, "secret": false, "description": "Custom rabbitmq ExceptionHandler for ConnectionFactory" },
    "connectionTimeout": { "kind": "property", "displayName": "Connection Timeout", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 60000, "description": "Connection timeout" },
    "networkRecoveryInterval": { "kind": "property", "displayName": "Network Recovery Interval", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "java.lang.Integer", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "5000", "description": "Network recovery interval in milliseconds (interval used when recovering from network failure)" },
    "requestedChannelMax": { "kind": "property", "displayName": "Requested Channel Max", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 2047, "description": "Connection requested channel max (max number of channels offered)" },
    "requestedFrameMax": { "kind": "property", "displayName": "Requested Frame Max", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Connection requested frame max (max size of frame offered)" },
    "requestedHeartbeat": { "kind": "property", "displayName": "Requested Heartbeat", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 60, "description": "Connection requested heartbeat (heart-beat in seconds offered)" },
    "requestTimeout": { "kind": "property", "displayName": "Request Timeout", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 20000, "description": "Set timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds)" },
    "requestTimeoutCheckerInterval": { "kind": "property", "displayName": "Request Timeout Checker Interval", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Set requestTimeoutCheckerInterval for inOut exchange" },
    "topologyRecoveryEnabled": { "kind": "property", "displayName": "Topology Recovery Enabled", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "description": "Enables connection topology recovery (should topology recovery be performed)" },
    "transferException": { "kind": "property", "displayName": "Transfer Exception", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "When true and an inOut Exchange failed on the consumer side send the caused Exception back in the response" },
    "password": { "kind": "property", "displayName": "Password", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "defaultValue": "guest", "description": "Password for authenticated access" },
    "sslProtocol": { "kind": "property", "displayName": "Ssl Protocol", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Enables SSL on connection, accepted value are true, TLS and 'SSLv3" },
    "trustManager": { "kind": "property", "displayName": "Trust Manager", "group": "security", "label": "security", "required": false, "type": "object", "javaType": "javax.net.ssl.TrustManager", "deprecated": false, "autowired": false, "secret": false, "description": "Configure SSL trust manager, SSL should be enabled for this option to be effective" },
    "username": { "kind": "property", "displayName": "Username", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "defaultValue": "guest", "description": "Username in case of authenticated access" }
  },
  "properties": {
    "exchangeName": { "kind": "path", "displayName": "Exchange Name", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The exchange name determines the exchange to which the produced messages will be sent to. In the case of consumers, the exchange name determines the exchange the queue will be bound to." },
    "addresses": { "kind": "parameter", "displayName": "Addresses", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "If this option is set, camel-rabbitmq will try to create connection based on the setting of option addresses. The addresses value is a string which looks like server1:12345, server2:12345" },
    "autoDelete": { "kind": "parameter", "displayName": "Auto Delete", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If it is true, the exchange will be deleted when it is no longer in use" },
    "automaticRecoveryEnabled": { "kind": "parameter", "displayName": "Automatic Recovery Enabled", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "true", "description": "Enables connection automatic recovery (uses connection implementation that performs automatic recovery when existing connection has failures)" },
    "connectionFactory": { "kind": "parameter", "displayName": "Connection Factory", "group": "common", "label": "common", "required": false, "type": "object", "javaType": "com.rabbitmq.client.ConnectionFactory", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom RabbitMQ connection factory. When this option is set, all connection options (connectionTimeout, requestedChannelMax...) set on URI are not used" },
    "deadLetterExchange": { "kind": "parameter", "displayName": "Dead Letter Exchange", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The name of the dead letter exchange" },
    "deadLetterExchangeType": { "kind": "parameter", "displayName": "Dead Letter Exchange Type", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "enum": [ "direct", "fanout", "headers", "topic" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "direct", "description": "The type of the dead letter exchange" },
    "deadLetterQueue": { "kind": "parameter", "displayName": "Dead Letter Queue", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The name of the dead letter queue" },
    "deadLetterRoutingKey": { "kind": "parameter", "displayName": "Dead Letter Routing Key", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The routing key for the dead letter exchange" },
    "declare": { "kind": "parameter", "displayName": "Declare", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If the option is true, camel declare the exchange and queue name and bind them together. If the option is false, camel won't declare the exchange and queue name on the server." },
    "durable": { "kind": "parameter", "displayName": "Durable", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If we are declaring a durable exchange (the exchange will survive a server restart)" },
    "exchangeType": { "kind": "parameter", "displayName": "Exchange Type", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "enum": [ "direct", "fanout", "headers", "topic" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "direct", "description": "The exchange type such as direct or topic." },
    "exclusive": { "kind": "parameter", "displayName": "Exclusive", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes." },
    "hostname": { "kind": "parameter", "displayName": "Hostname", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The hostname of the running rabbitmq instance or cluster." },
    "passive": { "kind": "parameter", "displayName": "Passive", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Passive queues depend on the queue already to be available at RabbitMQ." },
    "portNumber": { "kind": "parameter", "displayName": "Port Number", "group": "common", "label": "common", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "Port number for the host with the running rabbitmq instance or cluster. Default value is 5672." },
    "queue": { "kind": "parameter", "displayName": "Queue", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The queue to receive messages from" },
    "routingKey": { "kind": "parameter", "displayName": "Routing Key", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The routing key to use when binding a consumer queue to the exchange. For producer routing keys, you set the header rabbitmq.ROUTING_KEY." },
    "skipDlqDeclare": { "kind": "parameter", "displayName": "Skip Dlq Declare", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true the producer will not declare and bind a dead letter queue. This can be used if you have also DLQ rabbitmq consumer and you want to avoid argument clashing between Producer and Consumer. This option have no effect, if DLQ configured (deadLetterExchange option is not set)." },
    "skipExchangeDeclare": { "kind": "parameter", "displayName": "Skip Exchange Declare", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "This can be used if we need to declare the queue but not the exchange" },
    "skipQueueBind": { "kind": "parameter", "displayName": "Skip Queue Bind", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true the queue will not be bound to the exchange after declaring it" },
    "skipQueueDeclare": { "kind": "parameter", "displayName": "Skip Queue Declare", "group": "common", "label": "common", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key." },
    "vhost": { "kind": "parameter", "displayName": "Vhost", "group": "common", "label": "common", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "\/", "description": "The vhost for the channel" },
    "autoAck": { "kind": "parameter", "displayName": "Auto Ack", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "If messages should be auto acknowledged" },
    "bridgeErrorHandler": { "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
    "concurrentConsumers": { "kind": "parameter", "displayName": "Concurrent Consumers", "group": "consumer", "label": "consumer", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1, "description": "Number of concurrent consumers when consuming from broker. (eg similar as to the same option for the JMS component)." },
    "consumerTag": { "kind": "parameter", "displayName": "Consumer Tag", "group": "consumer", "label": "consumer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Specify a client-generated consumer tag to establish context when invoking the consume operation" },
    "exclusiveConsumer": { "kind": "parameter", "displayName": "Exclusive Consumer", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful when you want a long-lived shared queue to be temporarily accessible by just one consumer." },
    "prefetchCount": { "kind": "parameter", "displayName": "Prefetch Count", "group": "consumer", "label": "consumer", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The maximum number of messages that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "prefetchEnabled": { "kind": "parameter", "displayName": "Prefetch Enabled", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Enables the quality of service on the RabbitMQConsumer side. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "prefetchGlobal": { "kind": "parameter", "displayName": "Prefetch Global", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the settings should be applied to the entire channel rather than each consumer You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "prefetchSize": { "kind": "parameter", "displayName": "Prefetch Size", "group": "consumer", "label": "consumer", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The maximum amount of content (measured in octets) that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time" },
    "reQueue": { "kind": "parameter", "displayName": "Re Queue", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "This is used by the consumer to control rejection of the message. When the consumer is complete processing the exchange, and if the exchange failed, then the consumer is going to reject the message from the RabbitMQ broker. If the header CamelRabbitmqRequeue is present then the value of the header will be used, otherwise this endpoint value is used as fallback. If the value is false (by default) then the message is discarded\/dead-lettered. If the value is true, then the message is re-queued." },
    "exceptionHandler": { "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
    "exchangePattern": { "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut", "InOptionalOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
    "threadPoolSize": { "kind": "parameter", "displayName": "Thread Pool Size", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 10, "description": "The consumer uses a Thread Pool Executor with a fixed number of threads. This setting allows you to set that number of threads." },
    "additionalHeaders": { "kind": "parameter", "displayName": "Additional Headers", "group": "producer", "label": "producer", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Map of additional headers. These headers will be set only when the 'allowCustomHeaders' is set to true" },
    "additionalProperties": { "kind": "parameter", "displayName": "Additional Properties", "group": "producer", "label": "producer", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Map of additional properties. These are standard RabbitMQ properties as defined in com.rabbitmq.client.AMQP.BasicProperties. The map keys should be from org.apache.camel.component.rabbitmq.RabbitMQConstants. Any other keys will be ignored." },
    "allowCustomHeaders": { "kind": "parameter", "displayName": "Allow Custom Headers", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allow pass custom values to header" },
    "allowNullHeaders": { "kind": "parameter", "displayName": "Allow Null Headers", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allow pass null values to header" },
    "bridgeEndpoint": { "kind": "parameter", "displayName": "Bridge Endpoint", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the bridgeEndpoint is true, the producer will ignore the message header of rabbitmq.EXCHANGE_NAME and rabbitmq.ROUTING_KEY" },
    "channelPoolMaxSize": { "kind": "parameter", "displayName": "Channel Pool Max Size", "group": "producer", "label": "producer", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 10, "description": "Get maximum number of opened channel in pool" },
    "channelPoolMaxWait": { "kind": "parameter", "displayName": "Channel Pool Max Wait", "group": "producer", "label": "producer", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Set the maximum number of milliseconds to wait for a channel from the pool" },
    "guaranteedDeliveries": { "kind": "parameter", "displayName": "Guaranteed Deliveries", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "When true, an exception will be thrown when the message cannot be delivered (basic.return) and the message is marked as mandatory. PublisherAcknowledgement will also be activated in this case. See also publisher acknowledgements - When will messages be confirmed." },
    "immediate": { "kind": "parameter", "displayName": "Immediate", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is zero, the server will queue the message, but with no guarantee that it will ever be consumed. If the header is present rabbitmq.IMMEDIATE it will override this option." },
    "lazyStartProducer": { "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
    "mandatory": { "kind": "parameter", "displayName": "Mandatory", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set, the server will return an unroutable message with a Return method. If this flag is zero, the server silently drops the message. If the header is present rabbitmq.MANDATORY it will override this option." },
    "publisherAcknowledgements": { "kind": "parameter", "displayName": "Publisher Acknowledgements", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "When true, the message will be published with publisher acknowledgements turned on" },
    "publisherAcknowledgementsTimeout": { "kind": "parameter", "displayName": "Publisher Acknowledgements Timeout", "group": "producer", "label": "producer", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "description": "The amount of time in milliseconds to wait for a basic.ack response from RabbitMQ server" },
    "args": { "kind": "parameter", "displayName": "Args", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "arg.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each: Exchange: arg.exchange. Queue: arg.queue. Binding: arg.binding. DLQ: arg.dlq.queue. DLQ binding: arg.dlq.binding. For example to declare a queue with message ttl argument: http:\/\/localhost:5672\/exchange\/queueargs=arg.queue.x-message-ttl=60000" },
    "clientProperties": { "kind": "parameter", "displayName": "Client Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Connection client properties (client info used in negotiating with the server)" },
    "connectionFactoryExceptionHandler": { "kind": "parameter", "displayName": "Connection Factory Exception Handler", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "com.rabbitmq.client.ExceptionHandler", "deprecated": false, "autowired": false, "secret": false, "description": "Custom rabbitmq ExceptionHandler for ConnectionFactory" },
    "connectionTimeout": { "kind": "parameter", "displayName": "Connection Timeout", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 60000, "description": "Connection timeout" },
    "networkRecoveryInterval": { "kind": "parameter", "displayName": "Network Recovery Interval", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "java.lang.Integer", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "5000", "description": "Network recovery interval in milliseconds (interval used when recovering from network failure)" },
    "requestedChannelMax": { "kind": "parameter", "displayName": "Requested Channel Max", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 2047, "description": "Connection requested channel max (max number of channels offered)" },
    "requestedFrameMax": { "kind": "parameter", "displayName": "Requested Frame Max", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Connection requested frame max (max size of frame offered)" },
    "requestedHeartbeat": { "kind": "parameter", "displayName": "Requested Heartbeat", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 60, "description": "Connection requested heartbeat (heart-beat in seconds offered)" },
    "requestTimeout": { "kind": "parameter", "displayName": "Request Timeout", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 20000, "description": "Set timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds)" },
    "requestTimeoutCheckerInterval": { "kind": "parameter", "displayName": "Request Timeout Checker Interval", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Set requestTimeoutCheckerInterval for inOut exchange" },
    "synchronous": { "kind": "parameter", "displayName": "Synchronous", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported)." },
    "topologyRecoveryEnabled": { "kind": "parameter", "displayName": "Topology Recovery Enabled", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "description": "Enables connection topology recovery (should topology recovery be performed)" },
    "transferException": { "kind": "parameter", "displayName": "Transfer Exception", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "When true and an inOut Exchange failed on the consumer side send the caused Exception back in the response" },
    "allowMessageBodySerialization": { "kind": "parameter", "displayName": "Allow Message Body Serialization", "group": "allowMessageBodySerialization", "label": "allowMessageBodySerialization", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to allow Java serialization of the message body or not. If this value is true, the message body will be serialized on the producer side using Java serialization, if no type converter can handle the message body. On the consumer side, it will deserialize the message body if this value is true and the message contains a CamelSerialize header. Setting this value to true may introduce a security vulnerability as it allows an attacker to attempt to deserialize to a gadget object which could result in a RCE or other security vulnerability." },
    "password": { "kind": "parameter", "displayName": "Password", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "defaultValue": "guest", "description": "Password for authenticated access" },
    "sslProtocol": { "kind": "parameter", "displayName": "Ssl Protocol", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Enables SSL on connection, accepted value are true, TLS and 'SSLv3" },
    "trustManager": { "kind": "parameter", "displayName": "Trust Manager", "group": "security", "label": "security", "required": false, "type": "object", "javaType": "javax.net.ssl.TrustManager", "deprecated": false, "autowired": false, "secret": false, "description": "Configure SSL trust manager, SSL should be enabled for this option to be effective" },
    "username": { "kind": "parameter", "displayName": "Username", "group": "security", "label": "security", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": true, "defaultValue": "guest", "description": "Username in case of authenticated access" }
  }
}
