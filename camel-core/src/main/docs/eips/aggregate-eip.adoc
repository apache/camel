## Aggregate EIP

*This applies for Camel version 2.3 or newer. If you use an older
version then use this link:aggregator.html[Aggregator] link instead.*

The
http://www.enterpriseintegrationpatterns.com/Aggregator.html[Aggregator]
from the link:enterprise-integration-patterns.html[EIP patterns] allows
you to combine a number of messages together into a single message.

image:http://www.enterpriseintegrationpatterns.com/img/Aggregator.gif[image]

A correlation link:expression.html[Expression] is used to determine the
messages which should be aggregated together. If you want to aggregate
all messages into a single message, just use a constant expression. An
AggregationStrategy is used to combine all the message exchanges for a
single correlation key into a single message exchange.

### Aggregator options

// eip options: START
The Aggregate EIP supports 25 options which are listed below:


[width="100%",cols="3,1m,6",options="header"]
|=======================================================================
| Name | Java Type | Description
| correlationExpression | NamespaceAwareExpression | *Required* The expression used to calculate the correlation key to use for aggregation. The Exchange which has the same correlation key is aggregated together. If the correlation key could not be evaluated an Exception is thrown. You can disable this by using the ignoreBadCorrelationKeys option.
| completionPredicate | NamespaceAwareExpression | A Predicate to indicate when an aggregated exchange is complete. If this is not specified and the AggregationStrategy object implements Predicate the aggregationStrategy object will be used as the completionPredicate.
| completionTimeout | NamespaceAwareExpression | Time in millis that an aggregated exchange should be inactive before its complete (timeout). This option can be set as either a fixed value or using an Expression which allows you to evaluate a timeout dynamically - will use Long as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0. You cannot use this option together with completionInterval only one of the two can be used.
| completionSize | NamespaceAwareExpression | Number of messages aggregated before the aggregation is complete. This option can be set as either a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.
| optimisticLockRetryPolicy | OptimisticLockRetryPolicyDefinition | Allows to configure retry settings when using optimistic locking.
| parallelProcessing | Boolean | When aggregated are completed they are being send out of the aggregator. This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency. If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.
| optimisticLocking | Boolean | Turns on using optimistic locking which requires the aggregationRepository being used is supporting this by implementing org.apache.camel.spi.OptimisticLockingAggregationRepository.
| executorServiceRef | String | If using parallelProcessing you can specify a custom thread pool to be used. In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.
| timeoutCheckerExecutorServiceRef | String | If using either of the completionTimeout completionTimeoutExpression or completionInterval options a background thread is created to check for the completion for every aggregator. Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.
| aggregationRepositoryRef | String | Sets the custom aggregate repository to use Will by default use org.apache.camel.processor.aggregate.MemoryAggregationRepository
| strategyRef | String | A reference to lookup the AggregationStrategy in the Registry. Configuring an AggregationStrategy is required and is used to merge the incoming Exchange with the existing already merged exchanges. At first call the oldExchange parameter is null. On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.
| strategyMethodName | String | This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.
| strategyMethodAllowNull | Boolean | If this option is false then the aggregate method is not used for the very first aggregation. If this option is true then null values is used as the oldExchange (at the very first aggregation) when using POJOs as the AggregationStrategy.
| completionSize | Integer | Number of messages aggregated before the aggregation is complete. This option can be set as either a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.
| completionInterval | Long | A repeating period in millis by which the aggregator will complete all current aggregated exchanges. Camel has a background task which is triggered every period. You cannot use this option together with completionTimeout only one of them can be used.
| completionTimeout | Long | Time in millis that an aggregated exchange should be inactive before its complete (timeout). This option can be set as either a fixed value or using an Expression which allows you to evaluate a timeout dynamically - will use Long as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0. You cannot use this option together with completionInterval only one of the two can be used.
| completionFromBatchConsumer | Boolean | Enables the batch completion mode where we aggregate from a org.apache.camel.BatchConsumer and aggregate the total number of exchanges the org.apache.camel.BatchConsumer has reported as total by checking the exchange property link org.apache.camel.ExchangeBATCH_COMPLETE when its complete.
| groupExchanges | Boolean | Enables grouped exchanges so the aggregator will group all aggregated exchanges into a single combined Exchange holding all the aggregated exchanges in a java.util.List.
| eagerCheckCompletion | Boolean | Use eager completion checking which means that the completionPredicate will use the incoming Exchange. As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.
| ignoreInvalidCorrelationKeys | Boolean | If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just ignore the incoming Exchange.
| closeCorrelationKeyOnCompletion | Integer | Closes a correlation key when its complete. Any late received exchanges which has a correlation key that has been closed it will be defined and a ClosedCorrelationKeyException is thrown.
| discardOnCompletionTimeout | Boolean | Discards the aggregated message on completion timeout. This means on timeout the aggregated message is dropped and not sent out of the aggregator.
| forceCompletionOnStop | Boolean | Indicates to complete all current aggregated exchanges when the context is stopped
| completeAllOnStop | Boolean | Indicates to wait to complete all current and partial (pending) aggregated exchanges when the context is stopped. This also means that we will wait for all pending exchanges which are stored in the aggregation repository to complete so the repository is empty before we can stop. You may want to enable this when using the memory based aggregation repository that is memory based only and do not store data on disk. When this option is enabled then the aggregator is waiting to complete all those exchanges before its stopped when stopping CamelContext or the route using it.
| aggregateControllerRef | String | To use a org.apache.camel.processor.aggregate.AggregateController to allow external sources to control this aggregator.
|=======================================================================
// eip options: END

### About AggregationStrategy

The `AggregationStrategy` is used for aggregating the old (lookup by its
correlation id) and the new exchanges together into a single exchange.
Possible implementations include performing some kind of combining or
delta processing, such as adding line items together into an invoice or
just using the newest exchange and removing old exchanges such as for
state tracking or market data prices; where old values are of little
use.

Notice the aggregation strategy is a mandatory option and must be
provided to the aggregator.

Here are a few example AggregationStrategy implementations that should
help you create your own custom strategy.

[source,java]
---------------------------------------------------------------------------
//simply combines Exchange String body values using '+' as a delimiter
class StringAggregationStrategy implements AggregationStrategy {

    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        if (oldExchange == null) {
            return newExchange;
        }

        String oldBody = oldExchange.getIn().getBody(String.class);
        String newBody = newExchange.getIn().getBody(String.class);
        oldExchange.getIn().setBody(oldBody + "+" + newBody);
        return oldExchange;
    }
}

//simply combines Exchange body values into an ArrayList<Object>
class ArrayListAggregationStrategy implements AggregationStrategy {

    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        Object newBody = newExchange.getIn().getBody();
        ArrayList<Object> list = null;
        if (oldExchange == null) {
            list = new ArrayList<Object>();
            list.add(newBody);
            newExchange.getIn().setBody(list);
            return newExchange;
        } else {
            list = oldExchange.getIn().getBody(ArrayList.class);
            list.add(newBody);
            return oldExchange;
        }
    }
}
---------------------------------------------------------------------------

### About completion

When aggregation link:exchange.html[Exchange]s at some point you need to
indicate that the aggregated exchanges is complete, so they can be send
out of the aggregator. Camel allows you to indicate completion in
various ways as follows:

* completionTimeout - Is an inactivity timeout in which is triggered if
no new exchanges have been aggregated for that particular correlation
key within the period.
* completionInterval - Once every X period all the current aggregated
exchanges are completed.
* completionSize - Is a number indicating that after X aggregated
exchanges it's complete.
* completionPredicate - Runs a link:predicate.html[Predicate] when a new
exchange is aggregated to determine if we are complete or not. Staring
in *Camel 2.15*, the configured aggregationStrategy can implement the
Predicate interface and will be used as the completionPredicate if no
completionPredicate is configured. From *Camel 2.16*, the configured
aggregationStrategy can
implement `PreCompletionAwareAggregationStrategy` and will be used as
the completionPredicate in pre-complete check mode. See further below
for more details.
* completionFromBatchConsumer - Special option for
link:batch-consumer.html[Batch Consumer] which allows you to complete
when all the messages from the batch has been aggregated.
* forceCompletionOnStop - *Camel 2.9* Indicates to complete all current
aggregated exchanges when the context is stopped
* Using a `AggregateController` - *Camel 2.16* which allows to use an
external source to complete groups or all groups. This can be done using
Java or JMX API.

Notice that all the completion ways are per correlation key. And you can
combine them in any way you like. It's basically the first which
triggers that wins. So you can use a completion size together with a
completion timeout. Only completionTimeout and completionInterval cannot
be used at the same time.

Notice the completion is a mandatory option and must be provided to the
aggregator. If not provided Camel will thrown an Exception on startup.

### Pre-completion mode

*available as of Camel 2.16*

There can be use-cases where you want the incoming
link:exchange.html[Exchange] to determine if the correlation group
should pre-complete, and then the incoming
link:exchange.html[Exchange] is starting a new group from scratch. To
determine this the `AggregationStrategy` can
implement `PreCompletionAwareAggregationStrategy` which has
a `preComplete` method:

[source,java]
----------------------------------------------------------------------------------------------------------------------
    /**
     * Determines if the aggregation should complete the current group, and start a new group, or the aggregation
     * should continue using the current group.
     *
     * @param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)
     * @param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)
     * @return <tt>true</tt> to complete current group and start a new group, or <tt>false</tt> to keep using current
     */
    boolean preComplete(Exchange oldExchange, Exchange newExchange);
----------------------------------------------------------------------------------------------------------------------

If the preComplete method returns true, then the existing groups is
completed (without aggregating the incoming exchange (newExchange). And
then the newExchange is used to start the correlation group from scratch
so the group would contain only that new incoming exchange. This is
known as pre-completion mode. And when the aggregation is in
pre-completion mode, then only the following completions are in use

* aggregationStrategy must
implement `PreCompletionAwareAggregationStrategy` xxx
* completionTimeout or completionInterval can also be used as fallback
completions
* any other completion are not used (such as by size, from batch
consumer etc)
* eagerCheckCompletion is implied as true, but the option has no effect

### Persistent AggregationRepository

The aggregator provides a pluggable repository which you can implement
your own `org.apache.camel.spi.AggregationRepository`. +
 If you need persistent repository then you can use either Camel
link:hawtdb.html[HawtDB], link:leveldb.html[LevelDB], or
link:sql-component.html[SQL Component] components.

### Using TimeoutAwareAggregationStrategy

*Available as of Camel 2.9.2*

If your aggregation strategy implements
`TimeoutAwareAggregationStrategy`, then Camel will invoke the `timeout`
method when the timeout occurs. Notice that the values for index and
total parameters will be -1, and the timeout parameter will be provided
only if configured as a fixed value. You must *not* throw any exceptions
from the `timeout` method.

### Using CompletionAwareAggregationStrategy

*Available as of Camel 2.9.3*

If your aggregation strategy implements
`CompletionAwareAggregationStrategy`, then Camel will invoke the
`onComplete` method when the aggregated Exchange is completed. This
allows you to do any last minute custom logic such as to cleanup some
resources, or additional work on the exchange as it's now completed. +
 You must *not* throw any exceptions from the `onCompletion` method.

### Completing current group decided from the AggregationStrategy

*Available as of Camel 2.15*

The `AggregationStrategy` can now included a property on the
returned `Exchange` that contains a boolean to indicate if the current
group should be completed. This allows to overrule any existing
completion predicates / sizes / timeouts etc, and complete the group.

For example the following logic (from an unit test) will complete the
group if the message body size is larger than 5. This is done by setting
the property Exchange.AGGREGATION_COMPLETE_CURRENT_GROUP to true.

[source,java]
-------------------------------------------------------------------------------------------
    public final class MyCompletionStrategy implements AggregationStrategy {
        @Override
        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
            if (oldExchange == null) {
                return newExchange;
            }
            String body = oldExchange.getIn().getBody(String.class) + "+" 
                + newExchange.getIn().getBody(String.class);
            oldExchange.getIn().setBody(body);
            if (body.length() >= 5) {
                oldExchange.setProperty(Exchange.AGGREGATION_COMPLETE_CURRENT_GROUP, true);
            }
            return oldExchange;
        }
    }
-------------------------------------------------------------------------------------------

 
### Manually Force the Completion of All Aggregated Exchanges Immediately

*Available as of Camel 2.9* +
 You can manually trigger completion of all current aggregated exchanges
by sending a message containing the header
Exchange.AGGREGATION_COMPLETE_ALL_GROUPS set to true. The message is
considered a signal message only, the message headers/contents will not
be processed otherwise.

*Available as of Camel 2.11* +
 You can alternatively set the header
Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE to true to trigger
completion of all groups after processing the current message.

### Using a List<V> in AggregationStrategy

*Available as of Camel 2.11*

If you want to aggregate some value from the messages <V> into a List<V>
then we have added a
`org.apache.camel.processor.aggregate.AbstractListAggregationStrategy`
abstract class in *Camel 2.11* that makes this easier. The completed
Exchange that is sent out of the aggregator will contain the List<V> in
the message body.

For example to aggregate a List<Integer> you can extend this class as
shown below, and implement the `getValue` method:

### Using AggregateController

*Available as of Camel 2.16*

The `org.apache.camel.processor.aggregate.AggregateController` allows
you to control the aggregate at runtime using Java or JMX API. This can
be used to force completing groups of exchanges, or query its current
runtime statistics.

The aggregator provides a default implementation if no custom have been
configured, which can be accessed
using `getAggregateController()` method. Though it may be easier to
configure a controller in the route using aggregateController as shown
below:

[source,java]
----------------------------------------------------------------------------------------------
private AggregateController controller = new DefaultAggregateController();
 
from("direct:start")
   .aggregate(header("id"), new MyAggregationStrategy()).completionSize(10).id("myAggregator")
      .aggregateController(controller)
      .to("mock:aggregated");
----------------------------------------------------------------------------------------------

Then there is API on AggregateController to force completion. For
example to complete a group with key foo

[source,java]
------------------------------------------------------
int groups = controller.forceCompletionOfGroup("foo");
------------------------------------------------------

The number return would be the number of groups completed. In this case
it would be 1 if the foo group existed and was completed. If foo does
not exists then 0 is returned.

There is also an api to complete all groups

[source,java]
-----------------------------------------------------
int groups = controller.forceCompletionOfAllGroups();
-----------------------------------------------------

 

To configure this from XML DSL

[source,java]
----------------------------------------------------------------------------------------------------------
<bean id="myController" class="org.apache.camel.processor.aggregate.DefaultAggregateController"/>
 
  <camelContext xmlns="http://camel.apache.org/schema/spring">
        <route>
            <from uri="direct:start"/>
            <aggregate strategyRef="myAppender" completionSize="10" aggregateControllerRef="myController">
                <correlationExpression>
                    <header>id</header>
                </correlationExpression>
                <to uri="mock:result"/>
            </aggregate>
        </route>
    </camelContext>
----------------------------------------------------------------------------------------------------------

 

There is also JMX API on the aggregator which is available under the
processors node in the Camel JMX tree.

### Using GroupedExchanges

In the route below we group all the exchanges together using
`groupExchanges()`:

[source,java]
--------------------------------------------------------------------------------------------------
                from("direct:start")
                    // aggregate all using same expression
                    .aggregate(constant(true))
                    // wait for 0.5 seconds to aggregate
                    .completionTimeout(500L)
                    // group the exchanges so we get one single exchange containing all the others
                    .groupExchanges()
                    .to("mock:result");
--------------------------------------------------------------------------------------------------

As a result we have one outgoing link:exchange.html[Exchange] being
routed the the "mock:result" endpoint. The exchange is a holder
containing all the incoming Exchanges. +
 To get access to these exchanges you need to access them from a
property on the outgoing exchange as shown:

[source,java]
--------------------------------------------------------------------------------
List<Exchange> grouped = out.getProperty(Exchange.GROUPED_EXCHANGE, List.class);
--------------------------------------------------------------------------------

From *Camel 2.13* onwards this behavior has changed to store these
exchanges directly on the message body which is more intuitive:

[source,java]
--------------------------------------------------------------
List<Exchange> grouped = exchange.getIn().getBody(List.class);
--------------------------------------------------------------

### Using POJOs as AggregationStrategy

*Available as of Camel 2.12*

To use the `AggregationStrategy` you had to implement the
`org.apache.camel.processor.aggregate.AggregationStrategy` interface,
which means your logic would be tied to the Camel API. From *Camel 2.12*
onwards you can use a POJO for the logic and let Camel adapt to your
POJO. To use a POJO a convention must be followed:

* there must be a public method to use
* the method must not be void
* the method can be static or non-static
* the method must have 2 or more parameters
* the parameters is paired so the first 50% is applied to the
`oldExchange` and the reminder 50% is for the `newExchange`
* .. meaning that there must be an equal number of parameters, eg 2, 4,
6 etc.

The paired methods is expected to be ordered as follows:

* the first parameter is the message body
* the 2nd parameter is a Map of the headers
* the 3rd parameter is a Map of the Exchange properties

This convention is best explained with some examples.

In the method below, we have only 2 parameters, so the 1st parameter is
the body of the `oldExchange`, and the 2nd is paired to the body of the
`newExchange`:

[source,java]
----------------------------------------------------
public String append(String existing, String next) {
  return existing + next;
}
----------------------------------------------------

In the method below, we have only 4 parameters, so the 1st parameter is
the body of the `oldExchange`, and the 2nd is the Map of the
`oldExchange} headers, and the 3rd is paired to the body of the {{newExchange`,
and the 4th parameter is the Map of the `newExchange` headers:

[source,java]
------------------------------------------------------------------------------------------
public String append(String existing, Map existingHeaders, String next, Map nextHeaders) {
  return existing + next;
}
------------------------------------------------------------------------------------------

And finally if we have 6 parameters the we also have the properties of
the link:exchange.html[Exchange]s:

[source,java]
--------------------------------------------------------------------------------------------------------------------------------------
public String append(String existing, Map existingHeaders, Map existingProperties, String next, Map nextHeaders, Map nextProperties) {
  return existing + next;
}
--------------------------------------------------------------------------------------------------------------------------------------

To use this with the link:aggregator2.html[Aggregate] EIP we can use a
POJO with the aggregate logic as follows:

[source,java]
--------------------------------------------------------
public class MyBodyAppender {

    public String append(String existing, String next) {
        return next + existing;
    }

}
--------------------------------------------------------

And then in the Camel route we create an instance of our bean, and then
refer to the bean in the route using `bean` method from
`org.apache.camel.util.toolbox.AggregationStrategies` as shown:

[source,java]
--------------------------------------------------------------------------------------
    private MyBodyAppender appender = new MyBodyAppender();

    public void configure() throws Exception {
        from("direct:start")
            .aggregate(constant(true), AggregationStrategies.bean(appender, "append"))
                .completionSize(3)
                .to("mock:result");
    }
--------------------------------------------------------------------------------------

We can also provide the bean type directly:

[source,java]
--------------------------------------------------------------------------------------------------
    public void configure() throws Exception {
        from("direct:start")
            .aggregate(constant(true), AggregationStrategies.bean(MyBodyAppender.class, "append"))
                .completionSize(3)
                .to("mock:result");
    }
--------------------------------------------------------------------------------------------------

And if the bean has only one method we do not need to specify the name
of the method:

[source,java]
----------------------------------------------------------------------------------------
    public void configure() throws Exception {
        from("direct:start")
            .aggregate(constant(true), AggregationStrategies.bean(MyBodyAppender.class))
                .completionSize(3)
                .to("mock:result");
    }
----------------------------------------------------------------------------------------

And the `append` method could be static:

[source,java]
---------------------------------------------------------------
public class MyBodyAppender {

    public static String append(String existing, String next) {
        return next + existing;
    }

}
---------------------------------------------------------------

If you are using XML DSL then we need to declare a <bean> with the POJO:

[source,xml]
----------------------------------------------------------
    <bean id="myAppender" class="com.foo.MyBodyAppender"/>
----------------------------------------------------------

And in the Camel route we use `strategyRef` to refer to the bean by its
id, and the `strategyMethodName` can be used to define the method name
to call:

[source,xml]
-----------------------------------------------------------------------------------------------
    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <route>
            <from uri="direct:start"/>
            <aggregate strategyRef="myAppender" strategyMethodName="append" completionSize="3">
                <correlationExpression>
                    <constant>true</constant>
                </correlationExpression>
                <to uri="mock:result"/>
            </aggregate>
        </route>
    </camelContext>
-----------------------------------------------------------------------------------------------

When using XML DSL you must define the POJO as a <bean>.

### Aggregating when no data

By default when using POJOs as AggregationStrategy, then the method is
*only* invoked when there is data to be aggregated (by default). You can
use the option `strategyMethodAllowNull` to configure this. Where as
without using POJOs then you may have `null` as `oldExchange` or
`newExchange` parameters. For example the
link:aggregator2.html[Aggregate] EIP will invoke the
`AggregationStrategy` with `oldExchange` as null, for the first
link:exchange.html[Exchange] incoming to the aggregator. And then for
subsequent link:exchange.html[Exchange]s then `oldExchange` and
`newExchange` parameters are both not null.

Example with link:content-enricher.html[Content Enricher] and no data

Though with POJOs as AggregationStrategy we made this simpler and only
call the method when `oldExchange` and `newExchange` is not null, as
that would be the most common use-case. If you need to allow
`oldExchange` or `newExchange` to be null, then you can configure this
with the POJO using the `AggregationStrategyBeanAdapter` as shown below.
On the bean adapter we call `setAllowNullNewExchange` to allow the new
exchange to be null.

[source,java]
-----------------------------------------------------------------------------------------------------------
    public void configure() throws Exception {
        AggregationStrategyBeanAdapter myStrategy = new AggregationStrategyBeanAdapter(appender, "append");
        myStrategy.setAllowNullOldExchange(true);
        myStrategy.setAllowNullNewExchange(true);

        from("direct:start")
            .pollEnrich("seda:foo", 1000, myStrategy)
                .to("mock:result");
    }
-----------------------------------------------------------------------------------------------------------

This can be configured a bit easier using the `beanAllowNull` method
from `AggregationStrategies` as shown:

[source,java]
--------------------------------------------------------------------------------------------------
    public void configure() throws Exception {
        from("direct:start")
            .pollEnrich("seda:foo", 1000, AggregationStrategies.beanAllowNull(appender, "append"))
                .to("mock:result");
    }
--------------------------------------------------------------------------------------------------

Then the `append` method in the POJO would need to deal with the
situation that `newExchange` can be null:

[source,java]
------------------------------------------------------------
    public class MyBodyAppender {

        public String append(String existing, String next) {
            if (next == null) {
                return "NewWasNull" + existing;
            } else {
                return existing + next;
            }
        }

    }
------------------------------------------------------------

In the example above we use the link:content-enricher.html[Content
Enricher] EIP using `pollEnrich`. The `newExchange` will be null in the
situation we could not get any data from the "seda:foo" endpoint, and
therefore the timeout was hit after 1 second. So if we need to do some
special merge logic we would need to set `setAllowNullNewExchange=true`,
so the `append` method will be invoked. If we do not do that then when
the timeout was hit, then the append method would normally not be
invoked, meaning the link:content-enricher.html[Content Enricher] did
not merge/change the message.

In XML DSL you would configure the `strategyMethodAllowNull` option and
set it to true as shown below:

[source,xml]
------------------------------------------------------------------------------------------------------------------------------
    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <route>
            <from uri="direct:start"/>
            <aggregate strategyRef="myAppender" strategyMethodName="append" strategyMethodAllowNull="true" completionSize="3">
                <correlationExpression>
                    <constant>true</constant>
                </correlationExpression>
                <to uri="mock:result"/>
            </aggregate>
        </route>
    </camelContext>
------------------------------------------------------------------------------------------------------------------------------

### Different body types

When for example using `strategyMethodAllowNull` as true, then the
parameter types of the message bodies does not have to be the same. For
example suppose we want to aggregate from a `com.foo.User` type to a
`List<String>` that contains the user name. We could code a POJO doing
this as follows:

[source,java]
-----------------------------------------------------
    public static final class MyUserAppender {

        public List addUsers(List names, User user) {
            if (names == null) {
                names = new ArrayList();
            }
            names.add(user.getName());
            return names;
        }
    }
-----------------------------------------------------

Notice that the return type is a List which we want to contain the user
names. The 1st parameter is the list of names, and then notice the 2nd
parameter is the incoming `com.foo.User` type.

### See also

* The link:loan-broker-example.html[Loan Broker Example] which uses an
aggregator
*
http://tmielke.blogspot.com/2009/01/using-camel-aggregator-correctly.html[Blog
post by Torsten Mielke] about using the aggregator correctly.
* The old link:aggregator.html[Aggregator]
* link:hawtdb.html[HawtDB], link:leveldb.html[LevelDB] or
link:sql-component.html[SQL Component] for persistence support
* link:aggregate-example.html[Aggregate Example] for an example
application
=======
## Aggregator
*This applies for Camel version 2.3 or newer. If you use an older version then use this link:./aggregate-old-eip.adoc[Aggregator] link instead.*

The Aggregator from the EIP patterns allows you to combine a number of messages together into a single message.

image:http://www.enterpriseintegrationpatterns.com/img/Aggregator.gif[image]

A correlation link:../../../../../docs/user-manual/en/expression.adoc[Expression] is used to determine the messages which should be aggregated together. If you want to aggregate all messages into a single message, just use a constant expression. An AggregationStrategy is used to combine all the message exchanges for a single correlation key into a single message exchange. The default strategy just chooses the latest message; so its ideal for throttling messages.

For example, imagine a stock market data system; you are receiving 30,000 messages per second; you may want to throttle down the updates as, say, a GUI cannot cope with such massive update rates. So you may want to aggregate these messages together so that within a window (defined by a maximum number of messages or a timeout), messages for the same stock are aggregated together; by just choosing the latest message and discarding the older prices. (You could apply a delta processing algorithm if you prefer to capture some of the history).

Using the aggregator correctly::
Torsten Mielke wrote a nice link:http://tmielke.blogspot.com/2009/01/using-camel-aggregator-correctly.html[blog entry] with his thoughts and experience on using the aggregator. Its a well worth read.

[NOTE]
.AggregationStrategy changed in Camel 2.0
====
In Camel 2.0 the `AggregationStrategy` callback have been changed to also be invoked on the very first Exchange.

On the first invocation of the `aggregate` method the `oldExchange` parameter is `null`. The reason is that we have not aggregated anything yet.
So its only the `newExchange` that has a value. Usually you just return the newExchange in this situation. But you still have the power to decide what to do, for example you can do some alternation on the exchange or remove some headers. And a more common use case is for instance to count some values from the body payload. That could be to sum up a total amount etc.
====

[IMPORTANT]
.BatchTimeout and CompletionPredicate
====
You cannot use both batchTimeout and completionPredicate to trigger a completion based on either on reaching its goal first. The batch timeout will always trigger first, at that given interval.
====

### Using the Fluent Builders
The following example shows how to aggregate messages so that only the latest message for a specific value of the cheese header is sent:

[source,java]
--------------------------------------------------------
// in this route we aggregate all from direct:state based on the header id cheese
from("direct:start").aggregate(header("cheese")).to("mock:result");

from("seda:header").setHeader("visited", constant(true)).aggregate(header("cheese")).to("mock:result");

// in this sample we aggregate using our own strategy with a completion predicate
// stating that the aggregated header is equal to 5.
from("direct:predicate").aggregate(header("cheese"), new MyAggregationStrategy()).
        completionPredicate(header("aggregated").isEqualTo(5)).to("mock:result");

// this sample is similar to the one above but it also illustrates the use of outBatchSize
// to send exchanges to mock:endpoint in batches of 10.
from("direct:outBatchPredicate").aggregate(header("cheese"), new MyAggregationStrategy()).
        completionPredicate(header("aggregated").isEqualTo(5)).outBatchSize(10).to("mock:result");
--------------------------------------------------------

If you were using JMS then you may wish to use the JMSDestination header as the correlation key; or some custom header for the stock symbol (using the above stock market example):

[source,java]
--------------------------------------------------------
from("activemq:someReallyFastTopic").aggregator(header("JMSDestination")).to("activemq:someSlowTopicForGuis");
--------------------------------------------------------

You can of course use many different link:../../../../../docs/user-manual/en/expression.adoc[Expression] languages such as XPath, XQuery, SQL or various Scripting Languages.
Here is an example using *XPath*:

[source,java]
--------------------------------------------------------
//aggregate based on the message content using an XPath expression
//example assumes an XML document starting with <stockQuote symbol='...'>
//aggregate messages based on their symbol attribute within the <stockQuote> element
from("seda:start").aggregate().xpath("/stockQuote/@symbol", String.class).batchSize(5).to("mock:result");

//this example will aggregate all messages starting with <stockQuote symbol='APACHE'> into
//one exchange and all the other messages (different symbol or different root element) into another exchange.
from("seda:start").aggregate().xpath("name(/stockQuote[@symbol=&#39;APACHE&#39;])", String.class).batchSize(5).to("mock:result");
--------------------------------------------------------

For further examples of this pattern in use you could look at the junit test case.

### Using the Spring XML Extensions

[NOTE]
====
The correlationExpression element is in Camel 2.0. For earlier versions of Camel you will need to specify your expression without the enclosing correlationExpression element.

[source,java]
--------------------------------------------------------
<aggregator>
  <simple>header.cheese</simple>
  <to uri="mock:result"/>
</aggregator>
--------------------------------------------------------
====

The following example shows how to create a simple aggregator using the XML notation; using an link:../../../../../docs/user-manual/en/expression.adoc[Expression] for the correlation value used to aggregate messages together:

[source,xml]
--------------------------------------------------------
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:start"/>
    <aggregate>
      <correlationExpression>
        <simple>header.cheese</simple>
      </correlationExpression>
      <to uri="mock:result"/>
    </aggregate>
  </route>

  <route>
    <from uri="seda:header"/>
    <process ref="setHeaderProcessor"/>
    <to uri="direct:temp"/>
  </route>

  <route>
    <from uri="direct:temp"/>
    <aggregate>
      <correlationExpression>
        <simple>header.cheese</simple>
      </correlationExpression>
      <to uri="mock:result"/>
    </aggregate>
  </route>

  <route>
    <from uri="direct:predicate"/>
    <aggregate strategyRef="myAggregatorStrategy">
      <correlationExpression>
        <simple>header.cheese</simple>
      </correlationExpression>
      <to uri="mock:result"/>
      <completionPredicate>
        <method bean="myAggregatorStrategy" method="isCompleted"/>
      </completionPredicate>
    </aggregate>
  </route>

  <route>
    <from uri="direct:outBatchPredicate"/>
    <aggregate strategyRef="myAggregatorStrategy" outBatchSize="10">
      <correlationExpression>
        <simple>header.cheese</simple>
      </correlationExpression>
      <to uri="mock:result"/>
      <completionPredicate>
        <method bean="myAggregatorStrategy" method="isCompleted"/>
      </completionPredicate>
    </aggregate>
  </route>

  <!--  This route turns off in batching by setting batchSize to 1 to run unit test for out batching.
        Normal use cases may not want to disable in batching
  -->
  <route>
    <from uri="direct:outBatchNoInBatching"/>
    <aggregate strategyRef="myAggregatorStrategy" batchSize="1" outBatchSize="10">
      <correlationExpression>
        <simple>header.cheese</simple>
      </correlationExpression>
      <to uri="mock:result"/>
      <completionPredicate>
        <method bean="myAggregatorStrategy" method="isCompleted"/>
      </completionPredicate>
    </aggregate>
  </route>
</camelContext>
--------------------------------------------------------

You can specify your own AggregationStrategy if you prefer as shown in the following example:
[source,xml]
--------------------------------------------------------
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:start"/>
    <aggregate strategyRef="aggregatorStrategy">
      <correlationExpression>
        <simple>header.cheese</simple>
      </correlationExpression>
      <to uri="mock:result"/>
    </aggregate>
  </route>
</camelContext>

<bean id="aggregatorStrategy" class="org.apache.camel.spring.processor.MyAggregator"/>
--------------------------------------------------------

Notice how the `strategyRef` attribute is used on the `<aggregator>` element to refer to the custom strategy in Spring.

### Exchange Properties
The following properties is set on each Exchange that are aggregated:

[width="100%",cols="3,1,6",options="header"]
|=======================================================================
| Header | Type | Description
| `org.apache.camel.Exchange.AggregatedCount` | int | Camel 1.x: The total number of Exchanges aggregated in this combined Exchange.
| `CamelAggregatedSize` | int | Camel 2.0: The total number of Exchanges aggregated into this combined Exchange.
| `CamelAggregatedIndex` | int | Camel 2.0: The current index of this Exchange in the batch.
|=======================================================================


[width="100%",cols="3,1,6",options="header"]
|=======================================================================
| Option | Default | Description
| batchSize | 100 | The `in` batch size. This is the number of incoming exchanges that is processed by the aggregator and when this threshold is reached the batch is completed and send. *Camel 1.6.2/2.0*: You can disable the batch size so the Aggregator is only triggered by timeout by setting the `batchSize` to 0 (or negative). In *Camel 1.6.1* or older you can set the `batchSize` to a very large number to archive the same.
| outBatchSize | 0 | *Camel 1.5*: The `out` batch size. This is the number of exchanges currently aggregated in the `AggregationCollection`. When this threshold is reached the batch is completed and send. By default this option is disabled. The difference to the `batchSize` options is that this is for outgoing, so setting this size to e.g. 50 ensures that this batch will at maximum contain 50 exchanges when its sent.
| batchTimeout | 1000L | Timeout in millis. How long should the aggregator wait before its completed and sends whatever it has currently aggregated.
| groupExchanges | false | *Camel 2.0*: If enabled then Camel will group all aggregated Exchanges into a single combined `org.apache.camel.impl.GroupedExchange` holder class that holds all the aggregated Exchanges. And as a result only one Exchange is being sent out from the aggregator. Can be used to combine many incoming Exchanges into a single output Exchange without coding a custom AggregationStrategy yourself.
| batchConsumer | false | *Camel 2.0*: This option is if the exchanges are coming from a Batch Consumer. Then when enabled the Aggregator will use the batch size determined by the Batch Consumer in the message header `CamelBatchSize`. See more details at Batch Consumer. This can be used to aggregate all files consumed from a File endpoint in that given poll.
| completionPredicate | null | Allows you to use a Predicate to signal when an aggregation is complete. See *warning* in top of this page.
|=======================================================================

### AggregationCollection and AggregationStrategy
This aggregator uses an AggregationCollection to store the exchanges that are currently aggregated. The AggregationCollection uses a correlation link:../../../../../docs/user-manual/en/expression.adoc[Expression] and an AggregationStrategy:

* The correlation link:../../../../../docs/user-manual/en/expression.adoc[Expression] is used to correlate the incoming exchanges. The default implementation will group messages based on the correlation expression. Other implementations could for instance just add all exchanges as a batch.
* The strategy is used for aggregate the old (lookup by its correlation id) and the new exchanges together into a single exchange. Possible implementations include performing some kind of combining or delta processing, such as adding line items together into an invoice or just using the newest exchange and removing old exchanges such as for state tracking or market data prices; where old values are of little use.

Camel provides these implementations:

* `DefaultAggregationCollection`
* `PredicateAggregationCollection`
* `UseLatestAggregationStrategy`

### Examples
#### Default example
By default Camel uses `DefaultAggregationCollection` and `UseLatestAggregationStrategy`, so this simple example will just keep the latest received exchange for the given correlation link:../../../../../docs/user-manual/en/expression.adoc[Expression]:

[source,java]
--------------------------------------------------------
// our route is aggregating from the direct queue and sending the response to the mock
from("direct:start")
    // aggregated by header id
    // as we have not configured more on the aggregator it will default to aggregate the
    // latest exchange only
    .aggregate().header("id")
    // wait for 0.5 seconds to aggregate
    .batchTimeout(500L)
    .to("mock:result");
--------------------------------------------------------

#### Using PredicateAggregationCollection
The `PredicateAggregationCollection` is an extension to `DefaultAggregationCollection` that uses a Predicate as well to determine the completion. For instance the Predicate can test for a special header value, a number of maximum aggregated so far etc. To use this the routing is a bit more complex as we need to create our `AggregationCollection` object as follows:
[source,java]
--------------------------------------------------------
// create the aggregation collection we will use.
// - we will correlate the received message based on the id header
// - as we will just keep the latest message we use the latest strategy
// - and finally we stop aggregate if we receive 2 or more messages
AggregationCollection ag = new PredicateAggregationCollection(header("id"),
    new UseLatestAggregationStrategy(),
    property(Exchange.AGGREGATED_SIZE).isEqualTo(3));

// our route is aggregating from the direct queue and sending the response to the mock
from("direct:start")
    // we use the collection based aggregator we already have configured
    .aggregate(ag)
    // wait for 0.5 seconds to aggregate
    .batchTimeout(500L)
    .to("mock:result");
--------------------------------------------------------

In this sample we use the predicate that we want at most 3 exchanges aggregated by the same correlation id, this is defined as:
[source,java]
--------------------------------------------------------
header(Exchange.AGGREGATED_COUNT).isEqualTo(3)
--------------------------------------------------------

Using this the aggregator will complete if we receive 3 exchanges with the same correlation id or when the specified timeout of 500 msecs has elapsed (whichever criteria is met first).

#### Using custom aggregation strategy
In this example we will aggregate incoming bids and want to aggregate the highest bid. So we provide our own strategy where we implement the code logic:
[source,java]
--------------------------------------------------------
private static class MyAggregationStrategy implements AggregationStrategy {

    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        if (oldExchange == null) {
            // the first time we only have the new exchange so it wins the first round
            return newExchange;
        }
        int oldPrice = oldExchange.getIn().getBody(Integer.class);
        int newPrice = newExchange.getIn().getBody(Integer.class);
        // return the "winner" that has the highest price
        return newPrice > oldPrice ? newExchange : oldExchange;
    }
}
--------------------------------------------------------

Then we setup the routing as follows:
[source,java]
--------------------------------------------------------
// our route is aggregating from the direct queue and sending the response to the mock
from("direct:start")
    // aggregated by header id and use our own strategy how to aggregate
    .aggregate(new MyAggregationStrategy()).header("id")
    // wait for 0.5 seconds to aggregate
    .batchTimeout(500L)
    .to("mock:result");
--------------------------------------------------------

And since this is based on an unit test we show the test code that send the bids and what is expected as the *winners*:
[source,java]
--------------------------------------------------------
MockEndpoint result = getMockEndpoint("mock:result");

// we expect to find the two winners with the highest bid
result.expectedMessageCount(2);
result.expectedBodiesReceived("200", "150");

// then we sent all the message at once
template.sendBodyAndHeader("direct:start", "100", "id", "1");
template.sendBodyAndHeader("direct:start", "150", "id", "2");
template.sendBodyAndHeader("direct:start", "130", "id", "2");
template.sendBodyAndHeader("direct:start", "200", "id", "1");
template.sendBodyAndHeader("direct:start", "190", "id", "1");

assertMockEndpointsSatisfied();
--------------------------------------------------------

#### Using custom aggregation collection
In this example we will aggregate incoming bids and want to aggregate the bids in reverse order (this is just an example). So we provide our own collection where we implement the code logic:
[source,java]
--------------------------------------------------------
class MyReverseAggregationCollection extends AbstractCollection<Exchange> implements AggregationCollection {

    private List<Exchange> collection = new ArrayList<Exchange>();
    private Expression correlation;
    private AggregationStrategy strategy;

    public Expression getCorrelationExpression() {
        return correlation;
    }

    public void setCorrelationExpression(Expression correlationExpression) {
        this.correlation = correlationExpression;
    }

    public AggregationStrategy getAggregationStrategy() {
        return strategy;
    }

    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.strategy = aggregationStrategy;
    }

    public boolean add(Exchange exchange) {
        return collection.add(exchange);
    }

    public Iterator<Exchange> iterator() {
        // demonstrate the we can do something with this collection, so we reverse it
        Collections.reverse(collection);

        return collection.iterator();
    }

    public int size() {
        return collection.size();
    }

    public void clear() {
        collection.clear();
    }

    public void onAggregation(Object correlationKey, Exchange newExchange) {
        add(newExchange);
    }
}
--------------------------------------------------------

Then we setup the routing as follows:
[source,java]
--------------------------------------------------------
// our route is aggregating from the direct queue and sending the response to the mock
from("direct:start")
    // use our own collection for aggregation
    .aggregate(new MyReverseAggregationCollection())
    // wait for 0.5 seconds to aggregate
    .batchTimeout(500L)
    .to("mock:result");
And since this is based on an unit test we show the test code that send the bids and what is expected as the expected reverse order:
MockEndpoint result = getMockEndpoint("mock:result");

// we expect 5 messages since our custom aggregation collection just gets it all
// but returns them in reverse order
result.expectedMessageCount(5);
result.expectedBodiesReceived("190", "200", "130", "150", "100");

// then we sent all the message at once
template.sendBodyAndHeader("direct:start", "100", "id", "1");
template.sendBodyAndHeader("direct:start", "150", "id", "2");
template.sendBodyAndHeader("direct:start", "130", "id", "2");
template.sendBodyAndHeader("direct:start", "200", "id", "1");
template.sendBodyAndHeader("direct:start", "190", "id", "1");

assertMockEndpointsSatisfied();
--------------------------------------------------------

*Custom aggregation collection in Spring DSL*
You can also specify a custom aggregation collection in the Spring DSL. Here is an example for Camel 2.0
[source,xml]
--------------------------------------------------------
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:start"/>
    <aggregate batchTimeout="500" collectionRef="aggregatorCollection">
      <to uri="mock:result"/>
    </aggregate>
  </route>
</camelContext>

<bean id="aggregatorCollection" class="org.apache.camel.processor.aggregator.MyReverseAggregationCollection"/>
--------------------------------------------------------

In Camel 1.5.1 you will need to specify the aggregator as
[source,xml]
--------------------------------------------------------
<aggregator batchTimeout="500" collectionRef="aggregatorCollection">
  <expression/>
  <to uri="mock:result"/>
</aggregator>
--------------------------------------------------------


#### Using Grouped Exchanges
*Available as of Camel 2.0*
You can enable grouped exchanges to combine all aggregated exchanges into a single `org.apache.camel.impl.GroupedExchange` holder class that contains all the individual aggregated exchanges. This allows you to process a single Exchange containing all the aggregated exchange. Lets start with how to configure this in the router:
[source,java]
--------------------------------------------------------
// our route is aggregating from the direct queue and sending the response to the mock
from("direct:start")
    // aggregate all using same expression
    .aggregate().constant(true)
    // wait for 0.5 seconds to aggregate
    .batchTimeout(500L)
    // group the exchanges so we get one single exchange containing all the others
    .groupExchanges()
    .to("mock:result");
--------------------------------------------------------

And the next part is part of an unit code that demonstrates this feature as we send in 5 exchanges each with a different value in the body.
And we will only get 1 exchange out of the aggregator, but we can access all the individual aggregated exchanges from the List which we can extract as a property from the Exchange using the key `Exchange.GROUPED_EXCHANGE`.
[source,java]
--------------------------------------------------------
MockEndpoint result = getMockEndpoint("mock:result");

// we expect 1 messages since we group all we get in using the same correlation key
result.expectedMessageCount(1);

// then we sent all the message at once
template.sendBody("direct:start", "100");
template.sendBody("direct:start", "150");
template.sendBody("direct:start", "130");
template.sendBody("direct:start", "200");
template.sendBody("direct:start", "190");

assertMockEndpointsSatisfied();

Exchange out = result.getExchanges().get(0);
List<Exchange> grouped = out.getProperty(Exchange.GROUPED_EXCHANGE, List.class);

assertEquals(5, grouped.size());

assertEquals("100", grouped.get(0).getIn().getBody(String.class));
assertEquals("150", grouped.get(1).getIn().getBody(String.class));
assertEquals("130", grouped.get(2).getIn().getBody(String.class));
assertEquals("200", grouped.get(3).getIn().getBody(String.class));
assertEquals("190", grouped.get(4).getIn().getBody(String.class));
--------------------------------------------------------

#### Using Batch Consumer
*Available as of Camel 2.0*
The Aggregator can work together with the Batch Consumer to aggregate the total number of messages that the Batch Consumer have reported. This allows you for instance to aggregate all files polled using the File consumer.
For example:
[source,java]
--------------------------------------------------------
from("file://inbox")
   .aggregate(xpath("//order/@customerId"), new AggregateCustomerOrderStrategy()).batchConsumer().batchTimeout(60000).to("bean:processOrder");
--------------------------------------------------------

When using `batchConsumer` Camel will automatic adjust the batchSize according to reported by the Batch Consumer in this case the file consumer.
So if we poll in 7 files then the aggregator will aggregate all 7 files before it completes. As the timeout is still in play we set it to 60 seconds.

#### Using This Pattern
If you would like to use this EIP Pattern then please read the Getting Started, you may also find the Architecture useful particularly the description of Endpoint and URIs. Then you could try out some of the Examples first before trying this pattern out.

### See also

* The Loan Broker Example which uses an aggregator
* link:http://tmielke.blogspot.com/2009/01/using-camel-aggregator-correctly.html[Blog post by Torsten Mielke] about using the aggregator correctly.

