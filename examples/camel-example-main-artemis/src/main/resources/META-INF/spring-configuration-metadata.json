{
  "properties": [
    {
      "name": "camel.main.allow-use-original-message",
      "type": "java.lang.Boolean",
      "description": "Sets whether to allow access to the original message from Camel's error handler, or from org.apache.camel.spi.UnitOfWork.getOriginalInMessage(). Turning this off can optimize performance, as defensive copy of the original message is not needed. Default is false."
    },
    {
      "name": "camel.main.auto-configuration-enabled",
      "type": "java.lang.Boolean",
      "description": "Whether auto configuration of components/dataformats/languages is enabled or not. When enabled the configuration parameters are loaded from the properties component and optionally from the classpath file META-INF/services/org/apache/camel/autowire.properties. You can prefix the parameters in the properties file with: - camel.component.name.option1=value1 - camel.component.name.option2=value2 - camel.dataformat.name.option1=value1 - camel.dataformat.name.option2=value2 - camel.language.name.option1=value1 - camel.language.name.option2=value2 Where name is the name of the component, dataformat or language such as seda,direct,jaxb. <p/> The auto configuration also works for any options on components that is a complex type (not standard Java type) and there has been an explicit single bean instance registered to the Camel registry via the  {@link org.apache.camel.spi.Registry#bind(String,Object)}  method or by using the  {@link org.apache.camel.BindToRegistry}  annotation style. <p/> This option is default enabled.",
      "defaultValue": true
    },
    {
      "name": "camel.main.auto-startup",
      "type": "java.lang.Boolean",
      "description": "Sets whether the object should automatically start when Camel starts. Important: Currently only routes can be disabled, as CamelContext's are always started. Note: When setting auto startup false on CamelContext then that takes precedence and no routes is started. You would need to start CamelContext explicit using the org.apache.camel.CamelContext.start() method, to start the context, and then you would need to start the routes manually using CamelContext.getRouteController().startRoute(String). Default is true to always start up.",
      "defaultValue": true
    },
    {
      "name": "camel.main.autowire-component-properties",
      "type": "java.lang.Boolean",
      "description": "Whether autowiring components with properties that are of same type, which has been added to the Camel registry, as a singleton instance. This is used for convention over configuration to inject DataSource, AmazonLogin instances to the components. <p/> This option is default enabled.",
      "defaultValue": true
    },
    {
      "name": "camel.main.autowire-component-properties-allow-private-setter",
      "type": "java.lang.Boolean",
      "description": "Whether autowiring components allows to use private setter method when setting the value. This may be needed in some rare situations when some configuration classes may configure via constructors over setters. But constructor configuration is more cumbersome to use via .properties files etc.",
      "defaultValue": true
    },
    {
      "name": "camel.main.autowire-component-properties-deep",
      "type": "java.lang.Boolean",
      "description": "Whether autowiring components (with deep nesting by attempting to walk as deep down the object graph by creating new empty objects on the way if needed) with properties that are of same type, which has been added to the Camel registry, as a singleton instance. This is used for convention over configuration to inject DataSource, AmazonLogin instances to the components. <p/> This option is default disabled."
    },
    {
      "name": "camel.main.consumer-template-cache-size",
      "type": "java.lang.Integer",
      "description": "Consumer template endpoints cache size.",
      "defaultValue": 1000
    },
    {
      "name": "camel.main.duration",
      "type": "java.lang.Long",
      "description": "Sets the duration (in seconds) to run the application until it should be terminated. Defaults to -1. Any value <= 0 will run forever.",
      "defaultValue": -1
    },
    {
      "name": "camel.main.duration-hit-exit-code",
      "type": "java.lang.Integer",
      "description": "Sets the exit code for the application if duration was hit"
    },
    {
      "name": "camel.main.duration-max-idle-seconds",
      "type": "java.lang.Integer",
      "description": "To specify for how long time in seconds Camel can be idle before automatic terminating the JVM. You can use this to run Camel for a short while."
    },
    {
      "name": "camel.main.duration-max-messages",
      "type": "java.lang.Integer",
      "description": "To specify how many messages to process by Camel before automatic terminating the JVM. You can use this to run Camel for a short while."
    },
    {
      "name": "camel.main.duration-max-seconds",
      "type": "java.lang.Integer",
      "description": "To specify for how long time in seconds to keep running the JVM before automatic terminating the JVM. You can use this to run Camel for a short while."
    },
    {
      "name": "camel.main.endpoint-runtime-statistics-enabled",
      "type": "java.lang.Boolean",
      "description": "Sets whether endpoint runtime statistics is enabled (gathers runtime usage of each incoming and outgoing endpoints). The default value is false."
    },
    {
      "name": "camel.main.file-configurations",
      "type": "java.lang.String",
      "description": "Directory to load additional configuration files that contains configuration values that takes precedence over any other configuration. This can be used to refer to files that may have secret configuration that has been mounted on the file system for containers. You can specify a pattern to load from sub directories and a name pattern such as /var/app/secret/*.properties, multiple directories can be separated by comma."
    },
    {
      "name": "camel.main.handle-fault",
      "type": "java.lang.Boolean",
      "description": "Sets whether fault handling is enabled or not. Default is false."
    },
    {
      "name": "camel.main.hangup-interceptor-enabled",
      "type": "java.lang.Boolean",
      "description": "Whether to use graceful hangup when Camel is stopping or when the JVM terminates.",
      "defaultValue": true
    },
    {
      "name": "camel.main.hystrix.allow-maximum-size-to-diverge-from-core-size",
      "type": "java.lang.Boolean",
      "description": "Allows the configuration for maximumSize to take effect. That value can then be equal to, or higher, than coreSize"
    },
    {
      "name": "camel.main.hystrix.circuit-breaker-enabled",
      "type": "java.lang.Boolean",
      "description": "Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted. <p> This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it should be open/closed, this property results in not even instantiating a circuit-breaker."
    },
    {
      "name": "camel.main.hystrix.circuit-breaker-error-threshold-percentage",
      "type": "java.lang.Integer",
      "description": "Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests. <p> It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds; <p> The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts()."
    },
    {
      "name": "camel.main.hystrix.circuit-breaker-force-closed",
      "type": "java.lang.Boolean",
      "description": "If true the HystrixCircuitBreaker#allowRequest() will always return true to allow requests regardless of the error percentage from HystrixCommandMetrics.getHealthCounts(). <p> The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing."
    },
    {
      "name": "camel.main.hystrix.circuit-breaker-force-open",
      "type": "java.lang.Boolean",
      "description": "If true the HystrixCircuitBreaker.allowRequest() will always return false, causing the circuit to be open (tripped) and reject all requests. <p> This property takes precedence over circuitBreakerForceClosed();"
    },
    {
      "name": "camel.main.hystrix.circuit-breaker-request-volume-threshold",
      "type": "java.lang.Integer",
      "description": "Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip. <p> If below this number the circuit will not trip regardless of error percentage."
    },
    {
      "name": "camel.main.hystrix.circuit-breaker-sleep-window-in-milliseconds",
      "type": "java.lang.Integer",
      "description": "The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again."
    },
    {
      "name": "camel.main.hystrix.core-pool-size",
      "type": "java.lang.Integer",
      "description": "Core thread-pool size that gets passed to  {@link java.util.concurrent.ThreadPoolExecutor#setCorePoolSize(int)}"
    },
    {
      "name": "camel.main.hystrix.execution-isolation-semaphore-max-concurrent-requests",
      "type": "java.lang.Integer",
      "description": "Number of concurrent requests permitted to HystrixCommand.run(). Requests beyond the concurrent limit will be rejected. <p> Applicable only when executionIsolationStrategy == SEMAPHORE."
    },
    {
      "name": "camel.main.hystrix.execution-isolation-strategy",
      "type": "java.lang.String",
      "description": "What isolation strategy HystrixCommand.run() will be executed with. <p> If THREAD then it will be executed on a separate thread and concurrent requests limited by the number of threads in the thread-pool. <p> If SEMAPHORE then it will be executed on the calling thread and concurrent requests limited by the semaphore count."
    },
    {
      "name": "camel.main.hystrix.execution-isolation-thread-interrupt-on-timeout",
      "type": "java.lang.Boolean",
      "description": "Whether the execution thread should attempt an interrupt (using  {@link Future#cancel} ) when a thread times out. <p> Applicable only when executionIsolationStrategy() == THREAD."
    },
    {
      "name": "camel.main.hystrix.execution-timeout-enabled",
      "type": "java.lang.Boolean",
      "description": "Whether the timeout mechanism is enabled for this command"
    },
    {
      "name": "camel.main.hystrix.execution-timeout-in-milliseconds",
      "type": "java.lang.Integer",
      "description": "Time in milliseconds at which point the command will timeout and halt execution. <p> If  {@link #executionIsolationThreadInterruptOnTimeout}  == true and the command is thread-isolated, the executing thread will be interrupted. If the command is semaphore-isolated and a HystrixObservableCommand, that command will get unsubscribed."
    },
    {
      "name": "camel.main.hystrix.fallback-enabled",
      "type": "java.lang.Boolean",
      "description": "Whether HystrixCommand.getFallback() should be attempted when failure occurs."
    },
    {
      "name": "camel.main.hystrix.fallback-isolation-semaphore-max-concurrent-requests",
      "type": "java.lang.Integer",
      "description": "Number of concurrent requests permitted to HystrixCommand.getFallback(). Requests beyond the concurrent limit will fail-fast and not attempt retrieving a fallback."
    },
    {
      "name": "camel.main.hystrix.group-key",
      "type": "java.lang.String",
      "description": "Sets the group key to use. The default value is CamelHystrix."
    },
    {
      "name": "camel.main.hystrix.keep-alive-time",
      "type": "java.lang.Integer",
      "description": "Keep-alive time in minutes that gets passed to  {@link ThreadPoolExecutor#setKeepAliveTime(long,TimeUnit)}"
    },
    {
      "name": "camel.main.hystrix.maximum-size",
      "type": "java.lang.Integer",
      "description": "Maximum thread-pool size that gets passed to  {@link ThreadPoolExecutor#setMaximumPoolSize(int)} . This is the maximum amount of concurrency that can be supported without starting to reject HystrixCommands. Please note that this setting only takes effect if you also set allowMaximumSizeToDivergeFromCoreSize"
    },
    {
      "name": "camel.main.hystrix.max-queue-size",
      "type": "java.lang.Integer",
      "description": "Max queue size that gets passed to  {@link BlockingQueue}  in HystrixConcurrencyStrategy.getBlockingQueue(int) This should only affect the instantiation of a threadpool - it is not eliglible to change a queue size on the fly. For that, use queueSizeRejectionThreshold()."
    },
    {
      "name": "camel.main.hystrix.metrics-health-snapshot-interval-in-milliseconds",
      "type": "java.lang.Integer",
      "description": "Time in milliseconds to wait between allowing health snapshots to be taken that calculate success and error percentages and affect HystrixCircuitBreaker.isOpen() status. <p> On high-volume circuits the continual calculation of error percentage can become CPU intensive thus this controls how often it is calculated."
    },
    {
      "name": "camel.main.hystrix.metrics-rolling-percentile-bucket-size",
      "type": "java.lang.Integer",
      "description": "Maximum number of values stored in each bucket of the rolling percentile. This is passed into HystrixRollingPercentile inside HystrixCommandMetrics."
    },
    {
      "name": "camel.main.hystrix.metrics-rolling-percentile-enabled",
      "type": "java.lang.Boolean",
      "description": "Whether percentile metrics should be captured using HystrixRollingPercentile inside HystrixCommandMetrics."
    },
    {
      "name": "camel.main.hystrix.metrics-rolling-percentile-window-buckets",
      "type": "java.lang.Integer",
      "description": "Number of buckets the rolling percentile window is broken into. This is passed into HystrixRollingPercentile inside HystrixCommandMetrics."
    },
    {
      "name": "camel.main.hystrix.metrics-rolling-percentile-window-in-milliseconds",
      "type": "java.lang.Integer",
      "description": "Duration of percentile rolling window in milliseconds. This is passed into HystrixRollingPercentile inside HystrixCommandMetrics."
    },
    {
      "name": "camel.main.hystrix.metrics-rolling-statistical-window-buckets",
      "type": "java.lang.Integer",
      "description": "Number of buckets the rolling statistical window is broken into. This is passed into HystrixRollingNumber inside HystrixCommandMetrics."
    },
    {
      "name": "camel.main.hystrix.metrics-rolling-statistical-window-in-milliseconds",
      "type": "java.lang.Integer",
      "description": "This property sets the duration of the statistical rolling window, in milliseconds. This is how long metrics are kept for the thread pool. The window is divided into buckets and “rolls” by those increments."
    },
    {
      "name": "camel.main.hystrix.queue-size-rejection-threshold",
      "type": "java.lang.Integer",
      "description": "Queue size rejection threshold is an artificial max size at which rejections will occur even if  {@link #maxQueueSize}  has not been reached. This is done because the  {@link #maxQueueSize} of a  {@link BlockingQueue}  can not be dynamically changed and we want to support dynamically changing the queue size that affects rejections. <p> This is used by HystrixCommand when queuing a thread for execution."
    },
    {
      "name": "camel.main.hystrix.request-log-enabled",
      "type": "java.lang.Boolean",
      "description": "Whether HystrixCommand execution and events should be logged to HystrixRequestLog."
    },
    {
      "name": "camel.main.hystrix.thread-pool-key",
      "type": "java.lang.String",
      "description": "Sets the thread pool key to use. Will by default use the same value as groupKey has been configured to use."
    },
    {
      "name": "camel.main.hystrix.thread-pool-rolling-number-statistical-window-buckets",
      "type": "java.lang.Integer",
      "description": "Number of buckets the rolling statistical window is broken into. This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance."
    },
    {
      "name": "camel.main.hystrix.thread-pool-rolling-number-statistical-window-in-milliseconds",
      "type": "java.lang.Integer",
      "description": "Duration of statistical rolling window in milliseconds. This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance."
    },
    {
      "name": "camel.main.jmx-create-connector",
      "type": "java.lang.Boolean",
      "description": "Whether JMX connector is created, allowing clients to connect remotely The default value is false."
    },
    {
      "name": "camel.main.jmx-enabled",
      "type": "java.lang.Boolean",
      "description": "Enable JMX in your Camel application.",
      "defaultValue": true
    },
    {
      "name": "camel.main.jmx-management-name-pattern",
      "type": "java.lang.String",
      "description": "The naming pattern for creating the CamelContext JMX management name. The default pattern is #name#",
      "defaultValue": "#name#"
    },
    {
      "name": "camel.main.jmx-management-statistics-level",
      "type": "org.apache.camel.ManagementStatisticsLevel",
      "description": "Sets the JMX statistics level The level can be set to Extended to gather additional information The default value is Default.",
      "defaultValue": "ManagementStatisticsLevel.Default"
    },
    {
      "name": "camel.main.load-type-converters",
      "type": "java.lang.Boolean",
      "description": "Whether to load custom type converters by scanning classpath. This is used for backwards compatibility with Camel 2.x. Its recommended to migrate to use fast type converter loading by setting <tt>@Converter(loader = true)</tt> on your custom type converter classes.",
      "defaultValue": true
    },
    {
      "name": "camel.main.log-debug-max-chars",
      "type": "java.lang.Integer",
      "description": "Is used to limit the maximum length of the logging Camel message bodies. If the message body is longer than the limit, the log message is clipped. Use -1 to have unlimited length. Use for example 1000 to log at most 1000 characters."
    },
    {
      "name": "camel.main.log-exhausted-message-body",
      "type": "java.lang.Boolean",
      "description": "Sets whether to log exhausted message body with message history. Default is false."
    },
    {
      "name": "camel.main.log-mask",
      "type": "java.lang.Boolean",
      "description": "Sets whether log mask is enabled or not. Default is false."
    },
    {
      "name": "camel.main.message-history",
      "type": "java.lang.Boolean",
      "description": "Sets whether message history is enabled or not. Default is true.",
      "defaultValue": true
    },
    {
      "name": "camel.main.name",
      "type": "java.lang.String",
      "description": "Sets the name of the CamelContext."
    },
    {
      "name": "camel.main.producer-template-cache-size",
      "type": "java.lang.Integer",
      "description": "Producer template endpoints cache size.",
      "defaultValue": 1000
    },
    {
      "name": "camel.main.route-filter-exclude-pattern",
      "type": "java.lang.String",
      "description": "Used for filtering routes routes matching the given pattern, which follows the following rules: - Match by route id - Match by route input endpoint uri The matching is using exact match, by wildcard and regular expression as documented by  {@link PatternHelper#matchPattern(String,String)} . For example to only include routes which starts with foo in their route id's, use: include=foo&#42; And to exclude routes which starts from JMS endpoints, use: exclude=jms:&#42; Multiple patterns can be separated by comma, for example to exclude both foo and bar routes, use: exclude=foo&#42;,bar&#42; Exclude takes precedence over include."
    },
    {
      "name": "camel.main.route-filter-include-pattern",
      "type": "java.lang.String",
      "description": "Used for filtering routes routes matching the given pattern, which follows the following rules: - Match by route id - Match by route input endpoint uri The matching is using exact match, by wildcard and regular expression as documented by  {@link PatternHelper#matchPattern(String,String)} . For example to only include routes which starts with foo in their route id's, use: include=foo&#42; And to exclude routes which starts from JMS endpoints, use: exclude=jms:&#42; Multiple patterns can be separated by comma, for example to exclude both foo and bar routes, use: exclude=foo&#42;,bar&#42; Exclude takes precedence over include."
    },
    {
      "name": "camel.main.shutdown-log-inflight-exchanges-on-timeout",
      "type": "java.lang.Boolean",
      "description": "Sets whether to log information about the inflight Exchanges which are still running during a shutdown which didn't complete without the given timeout.",
      "defaultValue": true
    },
    {
      "name": "camel.main.shutdown-now-on-timeout",
      "type": "java.lang.Boolean",
      "description": "Sets whether to force shutdown of all consumers when a timeout occurred and thus not all consumers was shutdown within that period. You should have good reasons to set this option to false as it means that the routes keep running and is halted abruptly when CamelContext has been shutdown.",
      "defaultValue": true
    },
    {
      "name": "camel.main.shutdown-routes-in-reverse-order",
      "type": "java.lang.Boolean",
      "description": "Sets whether routes should be shutdown in reverse or the same order as they where started.",
      "defaultValue": true
    },
    {
      "name": "camel.main.shutdown-suppress-logging-on-timeout",
      "type": "java.lang.Boolean",
      "description": "Whether Camel should try to suppress logging during shutdown and timeout was triggered, meaning forced shutdown is happening. And during forced shutdown we want to avoid logging errors/warnings et all in the logs as a side-effect of the forced timeout. Notice the suppress is a best effort as there may still be some logs coming from 3rd party libraries and whatnot, which Camel cannot control. This option is default false."
    },
    {
      "name": "camel.main.shutdown-timeout",
      "type": "java.lang.Integer",
      "description": "Timeout in seconds to graceful shutdown Camel.",
      "defaultValue": 300
    },
    {
      "name": "camel.main.stream-caching-any-spool-rules",
      "type": "java.lang.Boolean",
      "description": "Sets whether if just any of the org.apache.camel.spi.StreamCachingStrategy.SpoolRule rules returns true then shouldSpoolCache(long) returns true, to allow spooling to disk. If this option is false, then all the org.apache.camel.spi.StreamCachingStrategy.SpoolRule must return true. The default value is false which means that all the rules must return true."
    },
    {
      "name": "camel.main.stream-caching-buffer-size",
      "type": "java.lang.Integer",
      "description": "Sets the stream caching buffer size to use when allocating in-memory buffers used for in-memory stream caches. The default size is 4096."
    },
    {
      "name": "camel.main.stream-caching-enabled",
      "type": "java.lang.Boolean",
      "description": "Sets whether stream caching is enabled or not. Default is false."
    },
    {
      "name": "camel.main.stream-caching-remove-spool-directory-when-stopping",
      "type": "java.lang.Boolean",
      "description": "Whether to remove stream caching temporary directory when stopping. This option is default true.",
      "defaultValue": true
    },
    {
      "name": "camel.main.stream-caching-spool-cipher",
      "type": "java.lang.String",
      "description": "Sets a stream caching cipher name to use when spooling to disk to write with encryption. By default the data is not encrypted."
    },
    {
      "name": "camel.main.stream-caching-spool-directory",
      "type": "java.lang.String",
      "description": "Sets the stream caching spool (temporary) directory to use for overflow and spooling to disk. If no spool directory has been explicit configured, then a temporary directory is created in the java.io.tmpdir directory."
    },
    {
      "name": "camel.main.stream-caching-spool-threshold",
      "type": "java.lang.Long",
      "description": "Stream caching threshold in bytes when overflow to disk is activated. The default threshold is 128kb. Use -1 to disable overflow to disk."
    },
    {
      "name": "camel.main.stream-caching-spool-used-heap-memory-limit",
      "type": "java.lang.String",
      "description": "Sets what the upper bounds should be when streamCachingSpoolUsedHeapMemoryThreshold is in use."
    },
    {
      "name": "camel.main.stream-caching-spool-used-heap-memory-threshold",
      "type": "java.lang.Integer",
      "description": "Sets a percentage (1-99) of used heap memory threshold to activate stream caching spooling to disk."
    },
    {
      "name": "camel.main.stream-caching-statistics-enabled",
      "type": "java.lang.Boolean",
      "description": "Sets whether stream caching statistics is enabled."
    },
    {
      "name": "camel.main.thread-name-pattern",
      "type": "java.lang.String",
      "description": "Sets the thread name pattern used for creating the full thread name. The default pattern is: Camel (#camelId#) thread ##counter# - #name# Where #camelId# is the name of the CamelContext. and #counter# is a unique incrementing counter. and #name# is the regular thread name. You can also use #longName# which is the long thread name which can includes endpoint parameters etc."
    },
    {
      "name": "camel.main.tracing",
      "type": "java.lang.Boolean",
      "description": "Sets whether tracing is enabled or not. Default is false."
    },
    {
      "name": "camel.main.use-breadcrumb",
      "type": "java.lang.Boolean",
      "description": "Set whether breadcrumb is enabled. The default value is false."
    },
    {
      "name": "camel.main.use-data-type",
      "type": "java.lang.Boolean",
      "description": "Whether to enable using data type on Camel messages. Data type are automatic turned on if one ore more routes has been explicit configured with input and output types. Otherwise data type is default off."
    },
    {
      "name": "camel.main.use-mdc-logging",
      "type": "java.lang.Boolean",
      "description": "To turn on MDC logging"
    },
    {
      "name": "camel.component.bean.cache",
      "type": "java.lang.Boolean",
      "description": "If enabled, Camel will cache the result of the first Registry look-up. Cache can be enabled if the bean in the Registry is defined as a singleton scope."
    },
    {
      "name": "camel.component.bean.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.bean.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.browse.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.browse.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.class.cache",
      "type": "java.lang.Boolean",
      "description": "If enabled, Camel will cache the result of the first Registry look-up. Cache can be enabled if the bean in the Registry is defined as a singleton scope."
    },
    {
      "name": "camel.component.class.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.class.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.controlbus.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.controlbus.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.dataformat.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.dataformat.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.dataset.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.dataset.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.dataset-test.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.dataset-test.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.direct.block",
      "type": "java.lang.Boolean",
      "description": "If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active.",
      "defaultValue": true
    },
    {
      "name": "camel.component.direct.timeout",
      "type": "java.lang.Long",
      "description": "The timeout value to use if block is enabled.",
      "defaultValue": 30000
    },
    {
      "name": "camel.component.direct.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.direct.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.direct-vm.block",
      "type": "java.lang.Boolean",
      "description": "If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active.",
      "defaultValue": true
    },
    {
      "name": "camel.component.direct-vm.timeout",
      "type": "java.lang.Long",
      "description": "The timeout value to use if block is enabled.",
      "defaultValue": 30000
    },
    {
      "name": "camel.component.direct-vm.header-filter-strategy",
      "type": "org.apache.camel.spi.HeaderFilterStrategy",
      "description": "Sets a HeaderFilterStrategy that will only be applied on producer endpoints (on both directions: request and response). Default value: none."
    },
    {
      "name": "camel.component.direct-vm.propagate-properties",
      "type": "java.lang.Boolean",
      "description": "Whether to propagate or not properties from the producer side to the consumer side, and vice versa. Default value: true.",
      "defaultValue": true
    },
    {
      "name": "camel.component.direct-vm.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.direct-vm.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.file.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.file.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.configuration",
      "type": "org.apache.camel.component.jms.JmsConfiguration",
      "description": "To use a shared JMS configuration"
    },
    {
      "name": "camel.component.jms.accept-messages-while-stopping",
      "type": "java.lang.Boolean",
      "description": "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.allow-reply-manager-quick-stop",
      "type": "java.lang.Boolean",
      "description": "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.acknowledgement-mode",
      "type": "java.lang.Integer",
      "description": "The JMS acknowledgement mode defined as an Integer. Allows you to set vendor-specific extensions to the acknowledgment mode. For the regular modes, it is preferable to use the acknowledgementModeName instead."
    },
    {
      "name": "camel.component.jms.eager-loading-of-properties",
      "type": "java.lang.Boolean",
      "description": "Enables eager loading of JMS properties as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.acknowledgement-mode-name",
      "type": "java.lang.String",
      "description": "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
      "defaultValue": "AUTO_ACKNOWLEDGE"
    },
    {
      "name": "camel.component.jms.auto-startup",
      "type": "java.lang.Boolean",
      "description": "Specifies whether the consumer container should auto-startup.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.cache-level",
      "type": "java.lang.Integer",
      "description": "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details."
    },
    {
      "name": "camel.component.jms.cache-level-name",
      "type": "java.lang.String",
      "description": "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
      "defaultValue": "CACHE_AUTO"
    },
    {
      "name": "camel.component.jms.reply-to-cache-level-name",
      "type": "java.lang.String",
      "description": "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION."
    },
    {
      "name": "camel.component.jms.client-id",
      "type": "java.lang.String",
      "description": "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead."
    },
    {
      "name": "camel.component.jms.concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.jms.reply-to-concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.jms.connection-factory",
      "type": "javax.jms.ConnectionFactory",
      "description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint."
    },
    {
      "name": "camel.component.jms.username",
      "type": "java.lang.String",
      "description": "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory."
    },
    {
      "name": "camel.component.jms.password",
      "type": "java.lang.String",
      "description": "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory."
    },
    {
      "name": "camel.component.jms.delivery-persistent",
      "type": "java.lang.Boolean",
      "description": "Specifies whether persistent delivery is used by default.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.delivery-mode",
      "type": "java.lang.Integer",
      "description": "Specifies the delivery mode to be used. Possibles values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2."
    },
    {
      "name": "camel.component.jms.durable-subscription-name",
      "type": "java.lang.String",
      "description": "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well."
    },
    {
      "name": "camel.component.jms.exception-listener",
      "type": "javax.jms.ExceptionListener",
      "description": "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions."
    },
    {
      "name": "camel.component.jms.error-handler",
      "type": "org.springframework.util.ErrorHandler",
      "description": "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler."
    },
    {
      "name": "camel.component.jms.error-handler-logging-level",
      "type": "org.apache.camel.LoggingLevel",
      "description": "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
      "defaultValue": "WARN"
    },
    {
      "name": "camel.component.jms.error-handler-log-stack-trace",
      "type": "java.lang.Boolean",
      "description": "Allows to control whether stacktraces should be logged or not, by the default errorHandler.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.explicit-qos-enabled",
      "type": "java.lang.Boolean",
      "description": "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.expose-listener-session",
      "type": "java.lang.Boolean",
      "description": "Specifies whether the listener session should be exposed when consuming messages.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.idle-task-execution-limit",
      "type": "java.lang.Integer",
      "description": "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.jms.idle-consumer-limit",
      "type": "java.lang.Integer",
      "description": "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.jms.max-concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener."
    },
    {
      "name": "camel.component.jms.reply-to-max-concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads."
    },
    {
      "name": "camel.component.jms.reply-on-timeout-to-max-concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.jms.max-messages-per-task",
      "type": "java.lang.Integer",
      "description": "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
      "defaultValue": -1
    },
    {
      "name": "camel.component.jms.message-converter",
      "type": "org.springframework.jms.support.converter.MessageConverter",
      "description": "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a javax.jms.Message."
    },
    {
      "name": "camel.component.jms.map-jms-message",
      "type": "java.lang.Boolean",
      "description": "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc. See section about how mapping works below for more details.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.message-id-enabled",
      "type": "java.lang.Boolean",
      "description": "When sending, specifies whether message IDs should be added. This is just an hint to the JMS Broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.message-timestamp-enabled",
      "type": "java.lang.Boolean",
      "description": "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.always-copy-message",
      "type": "java.lang.Boolean",
      "description": "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set).",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.use-message-id-as-correlation-id",
      "type": "java.lang.Boolean",
      "description": "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.priority",
      "type": "java.lang.Integer",
      "description": "Values greater than 1 specify the message priority when sending (where 0 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
      "defaultValue": 4
    },
    {
      "name": "camel.component.jms.pub-sub-no-local",
      "type": "java.lang.Boolean",
      "description": "Specifies whether to inhibit the delivery of messages published by its own connection.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.receive-timeout",
      "type": "java.lang.Long",
      "description": "The timeout for receiving messages (in milliseconds).",
      "defaultValue": 1000
    },
    {
      "name": "camel.component.jms.recovery-interval",
      "type": "java.lang.Long",
      "description": "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
      "defaultValue": 5000
    },
    {
      "name": "camel.component.jms.task-executor",
      "type": "org.springframework.core.task.TaskExecutor",
      "description": "Allows you to specify a custom task executor for consuming messages."
    },
    {
      "name": "camel.component.jms.time-to-live",
      "type": "java.lang.Long",
      "description": "When sending messages, specifies the time-to-live of the message (in milliseconds).",
      "defaultValue": -1
    },
    {
      "name": "camel.component.jms.transacted",
      "type": "java.lang.Boolean",
      "description": "Specifies whether to use transacted mode",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.lazy-create-transaction-manager",
      "type": "java.lang.Boolean",
      "description": "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.transaction-manager",
      "type": "org.springframework.transaction.PlatformTransactionManager",
      "description": "The Spring transaction manager to use."
    },
    {
      "name": "camel.component.jms.transaction-name",
      "type": "java.lang.String",
      "description": "The name of the transaction to use."
    },
    {
      "name": "camel.component.jms.transaction-timeout",
      "type": "java.lang.Integer",
      "description": "The timeout value of the transaction (in seconds), if using transacted mode.",
      "defaultValue": -1
    },
    {
      "name": "camel.component.jms.test-connection-on-startup",
      "type": "java.lang.Boolean",
      "description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.async-start-listener",
      "type": "java.lang.Boolean",
      "description": "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.async-stop-listener",
      "type": "java.lang.Boolean",
      "description": "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.force-send-original-message",
      "type": "java.lang.Boolean",
      "description": "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.request-timeout",
      "type": "java.lang.Long",
      "description": "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
      "defaultValue": 20000
    },
    {
      "name": "camel.component.jms.request-timeout-checker-interval",
      "type": "java.lang.Long",
      "description": "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
      "defaultValue": 1000
    },
    {
      "name": "camel.component.jms.transfer-exchange",
      "type": "java.lang.Boolean",
      "description": "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.transfer-exception",
      "type": "java.lang.Boolean",
      "description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a javax.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.transfer-fault",
      "type": "java.lang.Boolean",
      "description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed with a SOAP fault (not exception) on the consumer side, then the fault flag on org.apache.camel.Message#isFault() will be send back in the response as a JMS header with the key JmsConstants#JMS_TRANSFER_FAULT. If the client is Camel, the returned fault flag will be set on the org.apache.camel.Message#setFault(boolean). You may want to enable this when using Camel components that support faults such as SOAP based such as cxf or spring-ws.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.jms-operations",
      "type": "org.springframework.jms.core.JmsOperations",
      "description": "Allows you to use your own implementation of the org.springframework.jms.core.JmsOperations interface. Camel uses JmsTemplate as default. Can be used for testing purpose, but not used much as stated in the spring API docs."
    },
    {
      "name": "camel.component.jms.destination-resolver",
      "type": "org.springframework.jms.support.destination.DestinationResolver",
      "description": "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry)."
    },
    {
      "name": "camel.component.jms.reply-to-type",
      "type": "org.apache.camel.component.jms.ReplyToType",
      "description": "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive."
    },
    {
      "name": "camel.component.jms.preserve-message-qos",
      "type": "java.lang.Boolean",
      "description": "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.async-consumer",
      "type": "java.lang.Boolean",
      "description": "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously (Camel 3.0 may support async transactions).",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.allow-null-body",
      "type": "java.lang.Boolean",
      "description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.include-sent-jms-message-id",
      "type": "java.lang.Boolean",
      "description": "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.include-all-jmsx-properties",
      "type": "java.lang.Boolean",
      "description": "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.default-task-executor-type",
      "type": "org.apache.camel.component.jms.DefaultTaskExecutorType",
      "description": "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers."
    },
    {
      "name": "camel.component.jms.jms-key-format-strategy",
      "type": "org.apache.camel.component.jms.JmsKeyFormatStrategy",
      "description": "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation."
    },
    {
      "name": "camel.component.jms.allow-additional-headers",
      "type": "java.lang.String",
      "description": "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example some message systems such as WMQ do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching."
    },
    {
      "name": "camel.component.jms.queue-browse-strategy",
      "type": "org.apache.camel.component.jms.QueueBrowseStrategy",
      "description": "To use a custom QueueBrowseStrategy when browsing queues"
    },
    {
      "name": "camel.component.jms.message-created-strategy",
      "type": "org.apache.camel.component.jms.MessageCreatedStrategy",
      "description": "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message."
    },
    {
      "name": "camel.component.jms.wait-for-provision-correlation-to-be-updated-counter",
      "type": "java.lang.Integer",
      "description": "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
      "defaultValue": 50
    },
    {
      "name": "camel.component.jms.wait-for-provision-correlation-to-be-updated-thread-sleeping-time",
      "type": "java.lang.Long",
      "description": "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
      "defaultValue": 100
    },
    {
      "name": "camel.component.jms.correlation-property",
      "type": "java.lang.String",
      "description": "Use this JMS property to correlate messages in InOut exchange pattern (request-reply) instead of JMSCorrelationID property. This allows you to exchange messages with systems that do not correlate messages using JMSCorrelationID JMS property. If used JMSCorrelationID will not be used or set by Camel. The value of here named property will be generated if not supplied in the header of the message under the same name."
    },
    {
      "name": "camel.component.jms.subscription-durable",
      "type": "java.lang.Boolean",
      "description": "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.subscription-shared",
      "type": "java.lang.Boolean",
      "description": "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.subscription-name",
      "type": "java.lang.String",
      "description": "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0)."
    },
    {
      "name": "camel.component.jms.stream-message-type-enabled",
      "type": "java.lang.Boolean",
      "description": "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.format-date-headers-to-iso8601",
      "type": "java.lang.Boolean",
      "description": "Sets whether date headers should be formatted according to the ISO 8601 standard.",
      "defaultValue": false
    },
    {
      "name": "camel.component.jms.header-filter-strategy",
      "type": "org.apache.camel.spi.HeaderFilterStrategy",
      "description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter header to and from Camel message."
    },
    {
      "name": "camel.component.jms.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.jms.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.language.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.language.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.log.exchange-formatter",
      "type": "org.apache.camel.spi.ExchangeFormatter",
      "description": "Sets a custom ExchangeFormatter to convert the Exchange to a String suitable for logging. If not specified, we default to DefaultExchangeFormatter."
    },
    {
      "name": "camel.component.log.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.log.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.mock.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.mock.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.properties.locations",
      "type": "java.util.List",
      "description": "A list of locations to load properties. This option will override any default locations and only use the locations from this option."
    },
    {
      "name": "camel.component.properties.location",
      "type": "java.lang.String",
      "description": "A list of locations to load properties. You can use comma to separate multiple locations. This option will override any default locations and only use the locations from this option."
    },
    {
      "name": "camel.component.properties.encoding",
      "type": "java.lang.String",
      "description": "Encoding to use when loading properties file from the file system or classpath. If no encoding has been set, then the properties files is loaded using ISO-8859-1 encoding (latin-1) as documented by java.util.Properties#load(java.io.InputStream)"
    },
    {
      "name": "camel.component.properties.properties-resolver",
      "type": "org.apache.camel.component.properties.PropertiesResolver",
      "description": "To use a custom PropertiesResolver"
    },
    {
      "name": "camel.component.properties.properties-parser",
      "type": "org.apache.camel.component.properties.PropertiesParser",
      "description": "To use a custom PropertiesParser"
    },
    {
      "name": "camel.component.properties.cache",
      "type": "java.lang.Boolean",
      "description": "Whether or not to cache loaded properties. The default value is true.",
      "defaultValue": true
    },
    {
      "name": "camel.component.properties.property-prefix",
      "type": "java.lang.String",
      "description": "Optional prefix prepended to property names before resolution."
    },
    {
      "name": "camel.component.properties.property-suffix",
      "type": "java.lang.String",
      "description": "Optional suffix appended to property names before resolution."
    },
    {
      "name": "camel.component.properties.fallback-to-unaugmented-property",
      "type": "java.lang.Boolean",
      "description": "If true, first attempt resolution of property name augmented with propertyPrefix and propertySuffix before falling back the plain property name specified. If false, only the augmented property name is searched.",
      "defaultValue": true
    },
    {
      "name": "camel.component.properties.default-fallback-enabled",
      "type": "java.lang.Boolean",
      "description": "If false, the component does not attempt to find a default for the key by looking after the colon separator.",
      "defaultValue": true
    },
    {
      "name": "camel.component.properties.ignore-missing-location",
      "type": "java.lang.Boolean",
      "description": "Whether to silently ignore if a location cannot be located, such as a properties file not found.",
      "defaultValue": false
    },
    {
      "name": "camel.component.properties.prefix-token",
      "type": "java.lang.String",
      "description": "Sets the value of the prefix token used to identify properties to replace. Setting a value of null restores the default token (link DEFAULT_PREFIX_TOKEN).",
      "defaultValue": "{{"
    },
    {
      "name": "camel.component.properties.suffix-token",
      "type": "java.lang.String",
      "description": "Sets the value of the suffix token used to identify properties to replace. Setting a value of null restores the default token (link DEFAULT_SUFFIX_TOKEN).",
      "defaultValue": "}}"
    },
    {
      "name": "camel.component.properties.initial-properties",
      "type": "java.util.Properties",
      "description": "Sets initial properties which will be used before any locations are resolved."
    },
    {
      "name": "camel.component.properties.override-properties",
      "type": "java.util.Properties",
      "description": "Sets a special list of override properties that take precedence and will use first, if a property exist."
    },
    {
      "name": "camel.component.properties.system-properties-mode",
      "type": "java.lang.Integer",
      "description": "Sets the system property mode. The default mode (override) is to use system properties if present, and override any existing properties.",
      "defaultValue": 2
    },
    {
      "name": "camel.component.properties.environment-variable-mode",
      "type": "java.lang.Integer",
      "description": "Sets the OS environment variables mode. The default mode (override) is to use OS environment variables if present, and override any existing properties.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.properties.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.properties.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.quartz2.auto-start-scheduler",
      "type": "java.lang.Boolean",
      "description": "Whether or not the scheduler should be auto started. This options is default true",
      "defaultValue": true
    },
    {
      "name": "camel.component.quartz2.start-delayed-seconds",
      "type": "java.lang.Integer",
      "description": "Seconds to wait before starting the quartz scheduler."
    },
    {
      "name": "camel.component.quartz2.prefix-job-name-with-endpoint-id",
      "type": "java.lang.Boolean",
      "description": "Whether to prefix the quartz job with the endpoint id. This option is default false.",
      "defaultValue": false
    },
    {
      "name": "camel.component.quartz2.enable-jmx",
      "type": "java.lang.Boolean",
      "description": "Whether to enable Quartz JMX which allows to manage the Quartz scheduler from JMX. This options is default true",
      "defaultValue": true
    },
    {
      "name": "camel.component.quartz2.properties",
      "type": "java.util.Properties",
      "description": "Properties to configure the Quartz scheduler."
    },
    {
      "name": "camel.component.quartz2.properties-file",
      "type": "java.lang.String",
      "description": "File name of the properties to load from the classpath"
    },
    {
      "name": "camel.component.quartz2.prefix-instance-name",
      "type": "java.lang.Boolean",
      "description": "Whether to prefix the Quartz Scheduler instance name with the CamelContext name. This is enabled by default, to let each CamelContext use its own Quartz scheduler instance by default. You can set this option to false to reuse Quartz scheduler instances between multiple CamelContext's.",
      "defaultValue": true
    },
    {
      "name": "camel.component.quartz2.interrupt-jobs-on-shutdown",
      "type": "java.lang.Boolean",
      "description": "Whether to interrupt jobs on shutdown which forces the scheduler to shutdown quicker and attempt to interrupt any running jobs. If this is enabled then any running jobs can fail due to being interrupted.",
      "defaultValue": false
    },
    {
      "name": "camel.component.quartz2.scheduler-factory",
      "type": "org.quartz.SchedulerFactory",
      "description": "To use the custom SchedulerFactory which is used to create the Scheduler."
    },
    {
      "name": "camel.component.quartz2.scheduler",
      "type": "org.quartz.Scheduler",
      "description": "To use the custom configured Quartz scheduler, instead of creating a new Scheduler."
    },
    {
      "name": "camel.component.quartz2.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.quartz2.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.ref.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.ref.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.rest.consumer-component-name",
      "type": "java.lang.String",
      "description": "The Camel Rest component to use for (consumer) the REST transport, such as jetty, servlet, undertow. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used."
    },
    {
      "name": "camel.component.rest.producer-component-name",
      "type": "java.lang.String",
      "description": "The Camel Rest component to use for (producer) the REST transport, such as http, undertow. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestProducerFactory is registered in the registry. If either one is found, then that is being used."
    },
    {
      "name": "camel.component.rest.component-name",
      "type": "java.lang.String",
      "description": "The Camel Rest component to use for (producer) the REST transport, such as http, undertow. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestProducerFactory is registered in the registry. If either one is found, then that is being used."
    },
    {
      "name": "camel.component.rest.api-doc",
      "type": "java.lang.String",
      "description": "The swagger api doc resource to use. The resource is loaded from classpath by default and must be in JSon format."
    },
    {
      "name": "camel.component.rest.host",
      "type": "java.lang.String",
      "description": "Host and port of HTTP service to use (override host in swagger schema)"
    },
    {
      "name": "camel.component.rest.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.rest.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.rest-api.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.rest-api.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.saga.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.saga.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.scheduler.concurrent-tasks",
      "type": "java.lang.Integer",
      "description": "Number of threads used by the scheduling thread pool. Is by default using a single thread",
      "defaultValue": 1
    },
    {
      "name": "camel.component.scheduler.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.scheduler.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.seda.queue-size",
      "type": "java.lang.Integer",
      "description": "Sets the default maximum capacity of the SEDA queue (i.e., the number of messages it can hold).",
      "defaultValue": 1000
    },
    {
      "name": "camel.component.seda.concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Sets the default number of concurrent threads processing exchanges.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.seda.default-queue-factory",
      "type": "org.apache.camel.component.seda.BlockingQueueFactory",
      "description": "Sets the default queue factory."
    },
    {
      "name": "camel.component.seda.default-block-when-full",
      "type": "java.lang.Boolean",
      "description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
      "defaultValue": false
    },
    {
      "name": "camel.component.seda.default-offer-timeout",
      "type": "java.lang.Long",
      "description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, where a configured timeout can be added to the block case. Utilizing the .offer(timeout) method of the underlining java queue"
    },
    {
      "name": "camel.component.seda.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.seda.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.spring-event.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.spring-event.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.stub.queue-size",
      "type": "java.lang.Integer",
      "description": "Sets the default maximum capacity of the SEDA queue (i.e., the number of messages it can hold).",
      "defaultValue": 1000
    },
    {
      "name": "camel.component.stub.concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Sets the default number of concurrent threads processing exchanges.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.stub.default-queue-factory",
      "type": "org.apache.camel.component.seda.BlockingQueueFactory",
      "description": "Sets the default queue factory."
    },
    {
      "name": "camel.component.stub.default-block-when-full",
      "type": "java.lang.Boolean",
      "description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
      "defaultValue": false
    },
    {
      "name": "camel.component.stub.default-offer-timeout",
      "type": "java.lang.Long",
      "description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, where a configured timeout can be added to the block case. Utilizing the .offer(timeout) method of the underlining java queue"
    },
    {
      "name": "camel.component.stub.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.stub.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.timer.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.timer.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.validator.resource-resolver-factory",
      "type": "org.apache.camel.component.validator.ValidatorResourceResolverFactory",
      "description": "To use a custom LSResourceResolver which depends on a dynamic endpoint resource URI"
    },
    {
      "name": "camel.component.validator.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.validator.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.vm.queue-size",
      "type": "java.lang.Integer",
      "description": "Sets the default maximum capacity of the SEDA queue (i.e., the number of messages it can hold).",
      "defaultValue": 1000
    },
    {
      "name": "camel.component.vm.concurrent-consumers",
      "type": "java.lang.Integer",
      "description": "Sets the default number of concurrent threads processing exchanges.",
      "defaultValue": 1
    },
    {
      "name": "camel.component.vm.default-queue-factory",
      "type": "org.apache.camel.component.seda.BlockingQueueFactory",
      "description": "Sets the default queue factory."
    },
    {
      "name": "camel.component.vm.default-block-when-full",
      "type": "java.lang.Boolean",
      "description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
      "defaultValue": false
    },
    {
      "name": "camel.component.vm.default-offer-timeout",
      "type": "java.lang.Long",
      "description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, where a configured timeout can be added to the block case. Utilizing the .offer(timeout) method of the underlining java queue"
    },
    {
      "name": "camel.component.vm.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.vm.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    },
    {
      "name": "camel.component.xslt.uri-resolver-factory",
      "type": "org.apache.camel.component.xslt.XsltUriResolverFactory",
      "description": "To use a custom UriResolver which depends on a dynamic endpoint resource URI. Should not be used together with the option 'uriResolver'."
    },
    {
      "name": "camel.component.xslt.uri-resolver",
      "type": "javax.xml.transform.URIResolver",
      "description": "To use a custom UriResolver. Should not be used together with the option 'uriResolverFactory'."
    },
    {
      "name": "camel.component.xslt.content-cache",
      "type": "java.lang.Boolean",
      "description": "Cache for the resource content (the stylesheet file) when it is loaded. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
      "defaultValue": true
    },
    {
      "name": "camel.component.xslt.saxon",
      "type": "java.lang.Boolean",
      "description": "Whether to use Saxon as the transformerFactoryClass. If enabled then the class net.sf.saxon.TransformerFactoryImpl. You would need to add Saxon to the classpath.",
      "defaultValue": false
    },
    {
      "name": "camel.component.xslt.saxon-extension-functions",
      "type": "java.lang.String",
      "description": "Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition. You would need to add camel-saxon to the classpath. The function is looked up in the registry, where you can comma to separate multiple values to lookup."
    },
    {
      "name": "camel.component.xslt.saxon-configuration",
      "type": "java.lang.Object",
      "description": "To use a custom Saxon configuration"
    },
    {
      "name": "camel.component.xslt.saxon-configuration-properties",
      "type": "java.util.Map",
      "description": "To set custom Saxon configuration properties"
    },
    {
      "name": "camel.component.xslt.resolve-property-placeholders",
      "type": "java.lang.Boolean",
      "description": "Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.",
      "defaultValue": true
    },
    {
      "name": "camel.component.xslt.basic-property-binding",
      "type": "java.lang.Boolean",
      "description": "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities",
      "defaultValue": false
    }
  ]
}
